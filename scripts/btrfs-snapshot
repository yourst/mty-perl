#!/usr/bin/perl -w
# -*- cperl -*-
#
# btrfs-snapshot:
#
# Create, delete, rotate and list BtrFS subvolume snapshots in arbitrary
# periodic categories (hourly, daily, weekly, monthly, etc)., automatically
# named as e.g. 'daily@2014.mm.dd-HH-MM-SS', with a specified number of
# snapshots in each category with descending timestamps in the past.
#
# Copyright 2012 - 2014 Matt T. Yourst <yourst@yourst.com>
#

use integer; use warnings;

use MTY::Common::Common;
use MTY::Common::Strings;
use MTY::Filesystem::Files;
use MTY::Filesystem::FileStats;
use MTY::Common::CommandLine;

use MTY::Display::Colorize;
use MTY::Display::ColorizeErrorsAndWarnings;
use MTY::Display::TextInABox;
use MTY::Display::Tree;
use MTY::Display::PrintableSymbols;
use MTY::Display::PrintableSymbolTools;

use MTY::RegExp::Define;
use MTY::RegExp::Tools;
use MTY::RegExp::Blocks;
use MTY::RegExp::Numeric;
use MTY::RegExp::Strings;
use MTY::RegExp::FilesAndPaths;

use MTY::System::POSIX;
use MTY::Filesystem::ExtAttrs;
use MTY::Filesystem::BtrFS;
use MTY::Filesystem::ProcFS;
use MTY::Filesystem::Mounts;
use MTY::System::Misc;

my $max_backup_count = 0;
my $fs_root = undef;
my $subvolume = undef;
my $snapshot_name = undef;
my $force_create_snapshots_dir = 0;
my $delete_snapshot = undef;
my $list_subvols = 0;
my $list_snapshots = 0;
my $diff = 0;

my %command_line_options = (
  'backups' => [ \$max_backup_count, OPTION_VALUE_REQUIRED, [ 'n' ] ],
  'backup' => [ \$max_backup_count, OPTION_ASSIGN_BOOL, [ 'b' ], 1, 0 ],
  'force' => [ \$force_create_snapshots_dir, 0, [ 'f' ] ],
  'subvolume' => [ \$subvolume, OPTION_VALUE_REQUIRED, [qw(subvol sub volume vol v)] ],
  'snapshot' => [ \$snapshot_name, OPTION_VALUE_REQUIRED, [qw(ss s)] ],
  'delete' => [ \$delete_snapshot, OPTION_VALUE_REQUIRED, [qw(d del destroy remove rm r)] ],
  'list-subvols' => [ \$list_subvols, 0, [ 'lsvols' ], ],
  'list-snapshots' => [ \$list_snapshots, 0, [ qw(l ls lssnap) ], ],
  'diff' => [ \$diff, OPTION_VALUE_REQUIRED, [ qw(list-changes lschanges changes lsdiff) ], ],
);

my @command_line_options_help = (
  [ OPTION_HELP_SYNTAX ] => 'Syntax',

  [ OPTION_HELP_WRAPPED ] => 'Creates a snapshot of subvolume '.Y.'/path/of/subvolume'.X.' in '.
    Y.U.'/path/of/subvolume'.UX.G.'/.snapshots/'.G.U.'SnapshotName'.X.' '.
    'or if no snapshot name is specified, the current time and date will '.
    'be used to generate a default snapshot name of the form '.
    format_quoted($Y.'snapshot-'.$G.'YYYYMMDD-HHMMSS').'.',

  [ OPTION_HELP_CATEGORY ] => 'Commands and Actions', 

  [ OPTION_HELP_DEFAULT ] => 'Creates a new snapshot named according to the required -snapshot option',

  'delete' =>   'Delete the specified snapshot (by its full path name). For safety reasons, this '.
                'command intentionally only allows deleting snapshots; use "btrfs subvol delete" '.
                'to remove the original subvolumes.',

  'list-subvols' => 'List all subvolumes (in the specified filesystem or the root by default) '.
                    'which are actual read/write subvolumes containing a .snapshots subdirectory',

  'list-snapshots' => 'List all snapshots as a tree, with a main branch for each enabled subvolume, '.
                      'sub-branches for the snapshot types or labels defined for the subvolume, and '.
                      'leaf nodes with the snapshot timestamp',

  'diff' => 'Based on the specified snapshot, list the files, directories and any other filesystem '.
            'objects or inodes in the snapshot\'s corresponding live subvolume which have been added, '.
            'deleted, modified or have updated attributes since the snapshot was created. (BtrFS can '.
            'execute this query extraordinarily quickly thanks to its internal data structures).',

  [ OPTION_HELP_CATEGORY ] => 'Backup Count and Rotation',

  'backups' => 'Assuming the base snapshot name is "SnapshotName", -backups maintains '.
               'a queue of at most '.G.'N'.X.' chronologically ordered backups named '.
               'e.g. '.G.'SnapshotName'.Y.'.2014-01-01-12:00:00'.X.' (i.e. using the '.
               'actual timestamp of when that snapshot was created.'.NL.
               NL.
               'Whenever a new snapshot is created, the oldest snapshot in '.
               'the queue is deleted if N snapshots already exist. The new '.
               'snapshot is then created using the X.datestamp naming scheme '.
               'above, and the base name (e.g. '.format_quoted($G.'SnapshotName').') '.
               'is then symlinked to this newly created snapshot. This approach '.
               'makes the entire process atomic since it never renames subvolumes.'.NL,

  'backup' =>   'Equivalent to "-backups 1"',

  [ OPTION_HELP_CATEGORY ] => 'Additional Options',

  'force' =>    'If the '.Y.'/path/of/subvolume/.snapshots'.X.' directory does not exist, '.
                'it will automatically be created.',
);

sub print_progress($) {
  printfd(STDERR, $G.' '.checkmark.' '.$_[0].NL);
}

printfd(STDERR, print_banner($Y.'btrfs-snapshot', $R.'BtrFS snapshot creation, rotation, querying and management utility', $Y).NL);

my ($args, $invalid_args) = parse_and_check_command_line(%command_line_options, @ARGV, @command_line_options_help);

my ($subvolume_arg, $snapshot_name_arg) = @$args;

if (!defined $delete_snapshot) {
  if ((defined $subvolume_arg) && (defined $subvolume)) 
    { die("Cannot specify a subvolume name in both the first non-option argumment and the '-subvol' option"); }

  $subvolume //= $subvolume_arg;

  if ((defined $snapshot_name_arg) && (defined $snapshot_name) &&
        (($snapshot_name_arg // 'default') ne ($snapshot_name // 'default')))
    { die("Cannot specify a snapshot name in both the first non-option argumment and the '-snapshot' option"); }

  $snapshot_name //= ($snapshot_name_arg // 'default');
}

if (defined $delete_snapshot) {
  $snapshot_name = $delete_snapshot;
  $subvolume = $delete_snapshot;
} elsif (!defined $subvolume) {
  # warn("No subvolume name specified.");
  print_command_line_options_help(%command_line_options, @command_line_options_help);
  exit 0;
}

$subvolume = realpath($subvolume);
$fs_root = find_mount_point($subvolume);
if (!defined $fs_root) { die('Cannot find mount point for subvolume '.$subvolume); }

if (defined $delete_snapshot) {
  if (!is_btrfs_subvol_or_root($subvolume)) 
    { die("'$subvolume' is not a BtrFS subvolume nor a btrfs root directory"); };

  if (!is_btrfs_snapshot($subvolume)) 
    { die("'$subvolume' is not a BtrFS snapshot"); }

  print_progress($Y.'Deleting snapshot "'.$C.$subvolume.$K.'"...');
  remove_btrfs_subvol($subvolume) || die("Could not delete snapshot named '$subvolume'");
  print_progress($Y.'Deleted snapshot "'.$C.$subvolume.$K.'"');
  exit 0;
}

if ($fs_root ne '/') { $fs_root =~ s{\K/$}{}oaxg; }

my $timestamp = strftime('%Y.%m.%d-%H.%M.%S', localtime());

# Don't use a redundant leading '/' if snapshotting the root directory:
my $snapshots_dir = $subvolume.(($subvolume eq '/') ? '' : '/').'.snapshots';

my $target_dir = $snapshots_dir.'/'.$snapshot_name;
if ($max_backup_count > 0) { $target_dir .= '@'.$timestamp; }

if (! -d $snapshots_dir) {
  if ($force_create_snapshots_dir) {
    make_path($snapshots_dir) 
      || die('Cannot create directory '.$snapshots_dir);
  } else {
    prints($G.$snapshots_dir.$X.' does not exist: '.
          'skipping snapshot of subvolume '.$Y.$subvolume.$X.NL);
    exit 0;
  }
}

if (! -d $snapshots_dir) { 
  die($snapshots_dir.' cannot be created, or already exists but is not a directory');
}

my $target_dir_filetype = get_file_type($target_dir);

if (defined $target_dir_filetype) {
  if ($target_dir_filetype == FILE_TYPE_DIR) {
    remove_btrfs_subvol($target_dir) || die('Failed to remove existing snapshot subvolume directory '.$target_dir);
    print_progress('Removed old snapshot target directory '.$C.$target_dir);
  } elsif ($target_dir_filetype == FILE_TYPE_SYMLINK) {
    # The target is a symlink: just remove it so we can create a subvolume 
    # directory with the same name (usually this occurs when switching from
    # simple single snapshot mode to a series of multiple backups)
    unlink($target_dir) || die('Failed to remove target directory symlink '.$target_dir);
    print_progress('Removed symlink with same name as target directory '.$C.$target_dir);
  } else {
    die('Target directory '.$target_dir.' already exists, but is neither a directory '.NL.
          'nor a symlink (it appears to be a '.$file_type_to_description{$target_dir_filetype}.')');
  }
}

create_btrfs_snapshot($subvolume, $target_dir)
  || die('Failed to create snapshot of subvolume '.$subvolume.' in target directory '.$target_dir);

print_progress($Y.'Created snapshot'.$K.' of subvolume '.$C.$subvolume.$K.' in new snapshot directory '.$G.$target_dir);

update_subvol_xattrs($target_dir, $fs_root);

print_progress($Y.'Set extended attributes'.$K.' of new snapshot in '.$G.$target_dir.$Y);

set_btrfs_property($target_dir, 'ro', 'true');

print_progress($Y.'Set read only flag'.$K.' on new snapshot in '.$G.$target_dir.$Y);

if ($max_backup_count > 0) {
  my @existing_snapshots = read_directory($snapshots_dir);
  
  my $oldest_gen = 1<<62;
  my $oldest_snapshot_path = undef;
  my $existing_snapshot_count = 0;

  foreach $f (@existing_snapshots) {
    next if ($f =~ /^\./oax); # skip dot files + . and .. dirs
    next unless (starts_with($f, $snapshot_name.'@'));
    my $fullname = $snapshots_dir.'/'.$f;
    my $subvol_info = query_btrfs_subvol($fullname, $fs_root);    
    my $gen = $subvol_info->{gen};
    if (!defined $gen) { die('Cannot get generation of '.$fullname); }
    if ($gen <= $oldest_gen) {
      $oldest_gen = $gen;
      $oldest_snapshot_path = $fullname;
    }
    $existing_snapshot_count++;
  }

  print_progress($Y.'Oldest snapshot'.$K.' is '.$G.$oldest_snapshot_path.
                   $K.' with generation '.$G.$oldest_gen);

  if ($existing_snapshot_count <= $max_backup_count) {
    printfd(STDERR, $R.' '.x_symbol.' '.$Y.'Skipping removal of oldest snapshot'.$K.
          ', since there were only '.$G.$existing_snapshot_count.$K.' out of '.
          $G.$max_backup_count.$K.' snapshots'.$X.NL);
  } else {
    remove_btrfs_subvol($oldest_snapshot_path) || 
      die('Could not remove oldest snapshot "'.$oldest_snapshot_path.'"');
    print_progress($Y.'Removed oldest snapshot '.$G.$oldest_snapshot_path.
                     $K.' from generation '.$G.$oldest_gen);
  }

  my $symlink_path = $snapshots_dir.'/'.$snapshot_name;

  if (-l $symlink_path) { 
    unlink($symlink_path) 
      || die('Cannot remove symlink "'.$symlink_path.'"'); 
  }

  my $relative_target_dir = $snapshot_name.'@'.$timestamp;

  symlink($relative_target_dir, $symlink_path)
    || die('Cannot symlink '.$target_dir.' to '.$symlink_path);

  print_progress($Y.'Linked '.$G.$target_dir.$K.' to '.$G.$symlink_path);
}

exit 0;
