#!/usr/bin/perl -w
# -*- cperl -*-
#
# perlre: Perl regexp utility for shell script and command line usage
#
# Copyright 2008 - 2014 Matt T. Yourst <yourst@yourst.com>
#

use integer; use warnings;

use MTY::System::POSIX;
use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Common::Strings;
use MTY::Filesystem::Files;
use MTY::Filesystem::FileStats;

use MTY::Display::Colorize;
use MTY::Display::ColorizeErrorsAndWarnings;
use MTY::Display::ColorCapabilityCheck;
use MTY::Display::ANSIColorREs;
use MTY::Display::PrintableSymbols;
use MTY::Display::PrintableSymbolTools;
use MTY::Display::Scrollable;
use MTY::Display::TextInABox;
use MTY::Display::Tree;

use MTY::RegExp::Define;
use MTY::RegExp::FilesAndPaths;
use MTY::RegExp::Networks;
use MTY::RegExp::Numeric;
use MTY::RegExp::Tools;
use MTY::RegExp::Analyzer;
use MTY::RegExp::PerlRegExpParser;
use MTY::RegExp::Blocks;
use MTY::RegExp::Strings;
use MTY::RegExp::CxxREs;
use MTY::RegExp::PerlSyntax;

use Data::Printer;

#use File::Find;

$DEBUG = 0;

my @regexps = ( );
my @formats = ( );
my $regexp = undef;
my $format = undef;
$is_eval = 0;
$is_subst = 0;
$is_split = 0;
$is_key_uppercase = 0;
$is_key_lowercase = 0;
$is_full_lines = 0;
$is_anycase = 0;
$is_invert = 0;
$is_multiline = 0;
$is_pattern_regexp = 1;
$is_ignore_whitespace_in_regexp = 0;
$is_string = 0;
$is_filelist = 1;
$is_stdio = 0;
$is_subst_to_stdout = 0;
$is_dry_run = 0;
$is_show_filenames = undef;
$is_show_filenames_at_top = 0;
$is_colorize = undef;
$is_print_fancy_symbols = 1;
$is_verbose = 0;
$is_help = 0;
$is_explain_regexp = 0;
$is_list_regexps = 0;
$list_regexps_as_trees = 1;
$list_formatted_regexps = 1;
$is_optimize_regexp = 0;
my @regexps_to_list;
$backup_before_subst = 1;
$backup_dir = './subst.backups';
$overwrite_with_subst = 1;
$orig_format = '';
$format_specified = 0;
$split_key_prefix = "";
$split_key_suffix = "";
$file_line_marker_re = undef;

$matching_line_count_limit = 1<<31;
$invalid_args = 0;
my @filelist;
my $string = '';

my $error_messages = '';

sub show_error_and_exit {
  my ($message) = @_;
  $message = $R.x_symbol.'  '.$R.$U.'ERROR:'.$X.$Y.' '.$message.$X.NL;
  print(STDERR text_in_a_box($message, -1, $R, 'heavy'));
  $error_messages .= $message;
  $invalid_args = 1;
}

sub show_warning {
  my ($message) = @_;
  $message = $R.warning_sign.'  '.$R.$U.'Warning:'.$X.$Y.' '.$message.$X.NL;
  print(STDERR text_in_a_box($message, -1, $M, 'rounded'));
  $error_messages .= $message;
  $invalid_args = 1;
}

my $remaining_args_are_strings_or_filenames = 0;
my $non_option_args_seen = 0;

my %command_line_options = (
  'eval'            => \$is_eval,
  'subst'           => \$is_subst,
  'optimize'        => \$is_optimize_regexp,
  'explain'         => \$is_explain_regexp,
  'lines'           => \$is_full_lines,
  'split'           => \$is_split,
  'key-uppercase'   => \$is_key_uppercase,
  'key-lowercase'   => \$is_key_lowercase,
  'key-prefix'      => \$split_key_prefix,
  'key-suffix'      => \$split_key_suffix,
  'anycase'         => \$is_anycase,
  'multiline'       => \$is_multiline,
  'whitespace-in-regexp' => \$is_ignore_whitespace_in_regexp,
);

my $next_arg_is_regexp = 0;
my $next_arg_is_format = 0;

foreach $arg (@ARGV) {
  $is_option = ($arg =~ /\A-(?:\w|\-)/);
  $non_option_args_seen += (!$is_option);

  if ($arg eq '--') {
    $is_string = 1;
    $is_filelist = 0;
    $next_arg_is_regexp = 0;
    $next_arg_is_format = 0;
    $remaining_args_are_strings_or_filenames = 1;
  } elsif ($arg eq '::' || $arg eq '@') {
    $is_string = 0;
    $is_filelist = 1;
    $next_arg_is_regexp = 0;
    $next_arg_is_format = 0;
    $remaining_args_are_strings_or_filenames = 1;
  } elsif ($arg eq ':' || $arg eq '//') {
    #
    # additional pair of regexp and (optional) format 
    # arguments follow this, to be applied to the input 
    # files (listed at the end *after* the final '::'),
    # similar in concept to a shell pipeline:
    #
    if ($next_arg_is_format) {
      # this is an argument sequence like ... : regexp : ...
      # where only the regexp is listed without any associated
      # format, so put 'undef' in the @formats list to keep
      # it properly aligned with the @regexps list:
      push @formats,undef;
      $next_arg_is_format = 0;
    } elsif ($next_arg_is_regexp) {
      # this is an argument sequence like ... : : ..., 
      # where there is neither a regexp nor a format
      # (in practice users should never do this, but
      # it isn't explicitly defined as erroneous, so
      # we'll still do the right thing here and just
      # ignore this empty regexp+format pair entirely:
      $next_arg_is_regexp = 0;
    } else {
      # regexp follows the colon:
      $next_arg_is_regexp = 1;
    }
  } elsif ($remaining_args_are_strings_or_filenames) {
    if ($is_filelist) {
      push @filelist,$arg;
    } elsif ($is_string) {
      $string .= ' ' if (length($string) > 0);
      $string .= $arg;
    }
  } elsif (!$is_option) {
    if (!(scalar @regexps)) { $next_arg_is_regexp = 1; }
    elsif (!(scalar @formats)) { $next_arg_is_format = 1; }

    if ($next_arg_is_regexp) {
      push @regexps,$arg;
      $next_arg_is_regexp = 0;
      $next_arg_is_format = 1;

      $regexp = $arg;
      $orig_regexp = $arg;
    } elsif ($next_arg_is_format) {
      #
      # Use a heuristic to intuitively handle the common idiom
      # of listing a filename immediately following the regexp
      # without specifying a pattern. Specifically, if the
      # format lacks any references to captures, and looks
      # like a filename (i.e. matches filesystem_path_re)
      # and actually exists as a real file, we treat it
      # like the first filename instead of a format (which
      # is set to the default format in this case):
      #
      my $contains_capture_refs = ($arg =~ /(?<! \\) \$/oamsx) ? 1 : 0;
      my $looks_like_filename = ($arg =~ $filesystem_path_re) ? 1 : 0;
      if ((!$contains_capture_refs) && $looks_like_filename && (-e $arg)) {
        $is_filelist = 1;
        $next_arg_is_format = 0;
        $remaining_args_are_strings_or_filenames = 1;
        push @filelist,$arg;
      } else {
        push @formats,$arg;
        $format_specified = 1;
        $format = $arg;
        $orig_format = $arg;
        $remaining_args_are_strings_or_filenames = 1;
        $next_arg_is_format = 0;
      }
    }
  } elsif (($arg eq '-e') || ($arg eq '-eval')) {
    $is_eval = 1;
  } elsif (($arg eq '-s') || ($arg eq '-subst')) {
    $is_subst = 1;
  } elsif ($arg =~ /^-list-(?:(raw|tree|detailed)-)?regexps? (?: = ([\w\-\,]+))?/oax) {
    $is_list_regexps = 1;
    my $modifier = $1 // '';
    $list_formatted_regexps = ($modifier eq 'raw') ? 0 : 1;
    $list_regexps_as_trees = ($modifier eq 'tree') ? 1 : 0;
    if ($modifier eq 'detailed') { $list_regexps_as_trees = 0; }
    if (is_there($2)) {
      @regexps_to_list = split /,/, $2;
    }
  } elsif ($arg eq '-optimize') {
    $is_optimize_regexp = 1;
  } elsif ($arg =~ /^-explain/) {
    $is_explain_regexp = 1;
  } elsif ($arg =~ /^-l(ines)?/) {
    $is_full_lines = 1;
  } elsif (($arg eq '-S') || ($arg eq '-/') || ($arg eq '-split')) {
    $is_split = 1;
  } elsif (($arg eq '-kuc') || ($arg eq '-key-uppercase')) {
    $is_key_uppercase = 1;
  } elsif (($arg eq '-klc') || ($arg eq '-key-lowercase')) {
    $is_key_lowercase = 1;
  } elsif ($arg =~ /^-key-prefix=(\w+)$/) {
    $split_key_prefix = $1;
  } elsif ($arg =~ /^-key-suffix=(\w+)$/) {
    $split_key_suffix = $1;
  } elsif (($arg eq '-i') || ($arg eq '-anycase')) {
    $is_anycase = 1;
  } elsif (($arg eq '-m') || ($arg eq '-multiline')) {
    $is_multiline = 1;
  } elsif (($arg eq '-x') || ($arg eq '-whitespace-in-regexp')) {
    $is_ignore_whitespace_in_regexp = 1;
  } elsif ($arg =~ /^-[nF]$/) {
    $is_pattern_regexp = 0;
  } elsif (($arg eq '-v') || ($arg eq '-invert')) {
    $is_invert = 1;
  } elsif ($arg =~ /^-(no)?-?backup\w*$/) {
    $backup_before_subst = (($1 // '') ne 'no') ? 1 : 0;
  } elsif ($arg =~ /^-(no)?-?overwrite$/) {
    $overwrite_with_subst = (($1 // '') ne 'no') ? 1 : 0;
  } elsif ($arg =~ /^-substdir=(.+)$/) {
    $subst_output_dir_prefix = $1;
  } elsif ($arg =~ /^-backupdir(?:=(.+))?$/) {
    $backup_dir = (is_there($1) ? $1 : './.subst.backups');
  } elsif ($arg =~ /^-file-line-marker(?:=(.+))?$/) {
    $is_show_filenames = 1;
    $file_line_marker_re = (is_there($1) ? qr{$1}oa : 
      qr{^ [\#\%] (?|
           (?: line \s+ (?<line> \d+) (?: \s+ (?<file> \S+))?) |
           (?: file \s+ (?<file> \N+)))}oax);
  } elsif ($arg eq '-stdout') {
    $is_subst_to_stdout = 1;
  } elsif ($arg =~ /^-(?:test | dry\-?run |no\-?out)$/oax) {
    $is_dry_run = 1;
  } elsif ($arg =~ /^-(no)?-?filenames?$/) {
    $is_show_filenames = (($1 // '') ne 'no') ? 1 : 0;
  } elsif ($arg =~ /^-(no)?-?top-filename\w*$/) {
    $is_show_filenames_at_top = (($1 // '') ne 'no') ? 1 : 0;
  } elsif ($arg =~ /^-(no)?-?color\w*$/) {
    $is_colorize = (($1 // '') ne 'no') ? 1 : 0;
  } elsif ($arg =~ /^-(no)?-?fancy-sym\w*$/) {
    $is_print_fancy_symbols = (($1 // '') ne 'no') ? 1 : 0;
  } elsif ($arg eq '-d') {
    $DEBUG = 1;
  } elsif ($arg eq '-dre') {
    # use re "debug";
  } elsif ($arg eq '-v') {
    $is_verbose = 1;
  } elsif ($arg =~ /-h(?:elp)?/) {
    $is_help = 1;
  } elsif (($arg =~ /^-(\d+)$/) || ($arg =~ /^-limit=(\d+)$/)) {
    $matching_line_count_limit = $1;
  } elsif ($arg =~ /^-/) {
    show_error_and_exit('Invalid argument '.$K.left_quote.$G.$arg.$K.right_quote.$X);
    last;
  }
}

$is_help |= ((scalar @ARGV) == 0);

if (!($is_help || $is_list_regexps)) {
  if (!defined $regexp) {
    show_error_and_exit("regexp not defined (should be non-option argument #1)");
  }
  
  if ($is_string && (!defined($string))) {
    show_error_and_exit("'--' specified but missing string(s) to search (should be non-option argument #2)");
  }
  
  if ((!$format_specified) && ($is_eval || $is_subst) && (!is_split)) {
    show_error_and_exit("format must be specified (as non-option argument #2) for '-e' (evaluation) or '-s' (substitution)");
  }

  $is_stdio = 0;
  if ((!$is_string) && $is_filelist && (!scalar(@filelist))) {
    # Assume it's a pseudo file list comprising only stdin:
    @filelist = ('/dev/stdin');
    $is_stdio = 1;
  }
}

$invalid_args |= $is_help;

my $is_output_fd_color_capable = (($is_help || $is_list_regexps || $is_explain_regexp || $invalid_args))
  ? is_stderr_color_capable() : is_stdout_color_capable();

$is_colorize //= $is_output_fd_color_capable;

my $requested_action_not_compatible_with_color =
  ($is_subst && $is_filelist && (!$is_stdio)) || $is_eval || $is_split;

if ($requested_action_not_compatible_with_color) { $is_colorize = 0; }

if ($is_colorize) { 
  enable_color(); 
} else { 
  disable_color(); 
  $is_print_fancy_symbols = 0;
}

$show_colorized_compiled_regexps = $is_colorize;

sub show_predef_regexps {
  my @renames = sort(keys %compiled_regexps);

  print(STDOUT NL.text_in_a_box($C.'Predefined Regular Expressions:', 
                                0, $B, undef, 
                                undef, ' ', 76).
        '  '.$Y.$U.'perlre includes '.$C.scalar(@renames).
        $Y.' predefined regexps:'.$X.NL.NL);

  my $regexp_name_list = (scalar @regexps_to_list) 
	? \@regexps_to_list : \@compiled_regexp_names;

  if (!(scalar @regexps_to_list)) {
    short_list_compiled_regexps();
    list_compiled_regexps();
  }
  print(STDOUT NL);
  show_compiled_regexps(\%compiled_regexps, $regexp_name_list, $list_formatted_regexps);
  print(STDOUT NL);
}

if ($is_list_regexps) {
  show_predef_regexps();
  exit 1;
}

sub show_command_line_options {
  my $fd = $_[0] // STDERR;

  if (is_there($error_messages)) {
    print($fd text_in_a_box($error_messages, -1, $R, 'rounded'));
    print($fd NL);
  }
  print($fd $C.$U.'Command line options were:'.$X.NL);
  print($fd NL);
  for ($i = -1; $i < scalar(@ARGV); $i++) {
    my $arg = ($i >= 0) ? $ARGV[$i] : $0;
    print($fd '  '.$B.'['.($i+1).']'.$X.' '.$arg.NL);
  }
  print($fd NL);
}

sub format_help_tab($) {
  my ($text) = @_;
  return print_folder_tab($C.$text).NL;
}

if ($invalid_args) {
  local $helpfd = open_scrollable_stream() // STDERR;

  my $SP = "$G//$X";
  my $S = "$C$U";
  my $EH = "$Y$U";

  my $help;

  print($helpfd print_banner($G.'perlre', 
                             $Y.'Perl regular expression matching, substitution and more', $B));

  $help = q{
!Syntax:
  perlre <-options ...> 'regexp' 'format(optional)' < input-from-stdin
  perlre <-options ...> 'regexp' 'format(optional)' filename(s) to search
  perlre <-options ...> 'regexp' 'format(optional)' -- string(s) to search

!Output format options:
  If format omitted:  Print captured variables as a simple list of "\$1, \$2, \$3, ..."
  -e    Evaluate <format> as a Perl expression using eval()
  -s    Print every line with <format> substituted in place of any matches with <regexp>
  -l    Print entire line instead of only showing a list of capture group contents
  -1    Only print first matching line
  -S or -/  Split into a key, a separator (the regexp) and a value, then format (default: key=value)
     -kuc or -key-uppercase  Convert key to upper case
     -klc or -key-lowercase  Convert key to lower case
     -key-prefix=XXX         Add prefix XXX before each key
     -key-suffix=XXX         Add suffix XXX after each key
  Neither -e/-s/-S:   Print formatted captured variables $1, $2, $3, ... according to <format>

!Regular expression options:
  -v        Invert match behavior: only display non-matching lines (does not work with -s, -S, -m or -- "strings")
  -i        Ignore case (perl /i modifier)
  -m        Multi-line string (perl /ms modifiers): '^' and '\$' match start and end of any line (not of the entire input)
  -x        Ignore whitespace and comments within regexp (perl /x modifier)
  -n or -F  Pattern is a fixed string instead of a regexp

!Input to search within (must appear after all other options immediately before strings or filenames:
  -- "string" "string2"...   Search within the specified string(s) (appended end-to-end)
  :: file1 file2...          Search within the specified files (follows symlinks if needed)
                             ('::' may be omitted if and only if both regexp and format (args #1 and #2) are given
  If neither -- nor filenames are used, search within the input lines read from stdin
  If either -- or filenames are used, all subsequent arguments are assumed to be strings or filenames, respectively

!Substitution options (if using '-s' mode):
  -dry-run       Don't actually write to any files; only print the number of matches that would be replaced
  -no-backup     Don't save original filename to backup file 'filename@pre-SUBST-backup'
  -backupdir=DIR Save original filename (with path of e.g. a/b/c/file.txt) to backup in DIR/a/b/c/file.txt (default is ./.subst.backups)
  -no-overwrite  Don't overwrite original with substituted version; leave as 'filename@SUBST'
  -substdir=DIR  Place substituted versions of files in new directory hierarchy DIR'
  -stdout        Write substituted versions of files to stdout

!Miscellaneous options (use -<option_name> to enable, -no-<option-name> to disable):
  -h             Show this help information
  -colorize      Colorize output by highlighting matching captures ($1, $2, ...) in yellow and rest of format in red
  -fancy-symbols When processing multiple files, use fancy Unicode characters to make the output easier to read
  -no-filenames  When multiple files are specified, do not show filename before each matching line
  -top-filenames When multiple files are specified, show filename at top before all matching lines from each file
  -d             Debug by showing the effective values of perlre's parameters before and after any normalizations
  -dre           Debug Perl's internal regexp state machine representation of regexp and each step of its execution
  -list-regexps  Show the actual contents of predefined regexps
  -list-regexp=X Show the actual contents of the specified predefined regexp named X (e.g. "-list-regexp=example_regexp_re")
  -explain-re    Expand, colorize, beautify and explain the regexp given on the command line

!Captured variables in format:
  The specified format can print any capture groups in the regexp, which are indicated using
  parentheses, i.e. '(...<contents>...)' (but any groups of the form '(?...)', i.e. with an
  initial question mark, are non-capturing). 
  
  The format either specifies capture groups by number, i.e. $1 for the first group, $2 for
  the next group (independent of possible nesting), and so forth, or by name, using $+{'name'}
  to refer to the regexp group labeled using (?'name' ...). See the perlre man page for details.

  perlre also supports several special identifiers in the format:

       (if using ':: file1 fileN...'):       (if using '-- string1 stringN...')
  $@ = filename containing the match (or original string if using '-- string ...')
  $& = filename (without dir) with the match (or original string)
  $% = file number (first file is 0)         string number (first string is 0)
  $# = number of matches so far
  $_ = entire line containing the match (does not work in multi-line (-m) mode) 
  $. = line number within file or string (if not using -m)
  $- = offset (0+) of start of match in line (if -m, from start of entire file or string)
  $+ = offset (0+) of end of match in line (if -m, from start of entire file or string)
  $? = length of match in characters
  $* = matching substring

  When these are used to customize the formatting of filenames, the -no-filenames option may be useful.

};

  $examples .= q{
!Simple example:
  <EX>commandname | perlre "\s+(TARGET)\s+(\w+)\$"</EX>
  (just prints list of specified strings extracted from stdin)

!Formatted example:
  <EX>commandname | perlre "\s+(U)\s+(\w+)\$" 'aaa $1 bbb $2'</EX>
  (prints e.g. aaa XXX bbb YYY' where XXX and YYY are strings extracted from each line in stdin)

!Evaluation example:
  <EX>nm modulename.ko | perlre -e "\s+U\s+(\w+)\$" 'print("$1\n") if (`fgrep -c __ksymtab_$1 /proc/kallsyms` eq "0\n");'</EX>
  (actually executes commands in xargs fashion)

!Substitution example:
  <EX>echo "test of perl today, and another test of c++ tomorrow..." | perlre -s 'test of (\w+)\s+(\w+)' 'examination $2 of $1'</EX>
  (output is: "test of perl today, and another test of c++ tomorrow..."

!Complex multi-line substitution example:
  <EX>perlre -m -s '// Copyright (.+?) Old Owner' '// Copyright 2014 New Owner' < filename.h</EX>
  (updates copyright notices in headers)

!Complex multi-line substitution example with back references to captures (e.g. '\1') across multiple filenames:
  <EX>perlre -m -s '^#ifndef\s+(_*\w+_H_*)\n#define\s+\1$(.+)^#endif\s*(// \1\n+)?$\Z' '#pragma once$2' filename.h ../file2.cpp /path/to/file3.h</EX>
  (removes '#ifdef _XXX_H / #define _XXX_H_ / ... / #endif // _XXX_H' guards from header files)
};

  # Convert the simple help formatting codes and rules into ANSI color codes:
  $help =~ s{\!([^\n]+)\n}{format_help_tab($1)}oamsxge;
  $help =~ s{\s\K(\-[\w\-\=]+)(?=[\s\,])}{$Y$1$X}oamsxg;
  $help =~ s{(\$\S)}{$G$1$X}oamsxg;
  $help =~ s{perlre}{${G}perlre${X}}oamsxg;

  print($helpfd $help);

  print($helpfd NL.text_in_a_box($G.'E X A M P L E S', 0, $B, 'double', undef, (' ' x 20), 40));

  $examples =~ s/\!([^\n]+)\n/$Y$U$1$X\n/gms;
  $examples =~ s/\<EX\>(.+?)\<\/EX\>/$G$1$X/gms;
  print($helpfd $examples);

  show_command_line_options($helpfd);

  exit 1;
}

if ($is_split) {
  $regexp = '^\s*\b(.+?)\s*' . $regexp . '\s*(.*?)\s*$';
}

#
# Pre-compile and optimize the regexp, and catch any syntax errors:
#

# ("a" = ASCII (not Unicode), "o" = "compile and optimize pattern once at start"
$regexp_opts = 'aa';
$regexp_opts .= 'ms' if ($is_multiline);
$regexp_opts .= 'i' if ($is_anycase);
$regexp_opts .= 'x' if ($is_ignore_whitespace_in_regexp);

# Expand any requested pre-defined regexps from our common regexp library:
sub subst_builtin_regexp($) {
  my $s = ${$_[0]};
  if (!defined($s)) {
    show_error_and_exit('Unknown built-in regexp '.$K.left_quote.$C.$1.'_re'.$K.right_quote.$X.NL.NL.
               '(Run '.$K.left_quote.$G.'perlre -list-regexps'.$K.right_quote.$X.' for a list of '.
               'all available built-in regexps)');
    exit 2;
  }
  return $s;
}

if ($is_pattern_regexp) { 
  $regexp =~ s[\$\{?(\w+?_re)\}?]
              [subst_builtin_regexp($1)]oamsge;
} else {
  $regexp = quotemeta($regexp);
  $capture_group_count = 0;
}

$expanded_regexp = $regexp;

$die_error_message = undef;
my $compiled_regexp_as_text = '(?'.$regexp_opts.':'.$expanded_regexp.')';
$regexp = qr{$compiled_regexp_as_text};

if (defined($die_error_message)) {
  my $regexp_compile_error = $die_error_message;
  my ($reason, $left_re_part, $right_re_part) = 
    ($regexp_compile_error =~ /^(.+); marked by <-- HERE in (.*?) <-- HERE (.*?) at /);

  my $msg =
    'regexp contains syntax error'.$K.' (see '.$X.'man perlre'.$K.' for help):'.NL.
    NL.
    $C.'Original regexp:  '.$K.left_quote.$G.$orig_regexp.$K.right_quote.$X.NL.
    $C.'Expanded regexp:  '.$K.left_quote.$G.$expanded_regexp.$K.right_quote.$X.NL;

  if (all_defined($reason, $left_re_part, $right_re_part)) {
    $msg .=
      $C.'Error message:    '.$X.$R.$reason.$X.NL.
      $C.'Attempted on RE:  '.$X.$K.$left_re_part.
        $Y.' '.$x_symbol.' '.$R.$right_re_part.$X.NL;
    $msg .= (' ' x (length("Attempted on RE:   $left_re_part"))).$Y.$up_arrow_tri.' (near here)'.NL;
  } else {
    $msg .= $C.$U.'Error message:'.$X.'   '.$R.$regexp_compile_error.$X."\n\n";
  }
  show_error_and_exit($msg);
  exit 1;
}

if ($is_explain_regexp) {
  print(STDOUT NL);
  show_compiled_regexp('(regexp)', $regexp);
  exit 0;
}

if ($is_optimize_regexp) {
  print(STDOUT NL.$G.$U.'Regular expression as specified (before optimization):'.$X."\n\n");
  show_compiled_regexp('(regexp before)', $regexp);

  $optimized_regexp = Regexp::Optimizer->new->optimize($regexp);

  print(STDOUT NL.$G.$U.'Regular expression after optimization:'.$X."\n\n");
  show_compiled_regexp('(regexp after)', $optimized_regexp);
  exit 1;
}

#
# Prepare the specified output format template:
#

#if (is_regexp_simple_literal($regexp)) {
#  $is_pattern_regexp = 0;
#}

$capture_group_count = ($is_pattern_regexp) ? get_regexp_capture_group_count($regexp) : 0; 

if ($is_split) {
  $is_eval = 1;
  if (defined($format)) {
    $preform = $format;
    $preform =~ s/\$1/\$k/g; $preform =~ s/\$2/\$v/g;
  } else {
    $preform = $split_key_prefix . '${k}' . $split_key_suffix . '=\'${v}\'\n';
  }
  $format = '{ $k=$1; $v=$2; $k =~ s/\s/_/g; $k =~ s/\W//g; ';
  $format .= '$k = uc($k); ' if ($is_key_uppercase);
  $format .= '$k = lc($k); ' if ($is_key_lowercase);
  $format .= 'print("' . $preform . '"); }';
  $format_specified = 1;
} elsif (!defined($format)) {
  #
  # Technically non-capturing groups are:
  # '(?:', (?adluimsx-imsx:', '(?^aluimsx:'
  # but for simplicity we'll ignore this,
  # since a conservative upper bound on
  # the group count is harmless because
  # excess group numbers will simply not
  # be defined and thus won't be printed.
  #

  if ($capture_group_count > 0) {
    $format = '';
    foreach $i (1 .. $capture_group_count) {
      $format .= (($i > 1) ? ' $' : '$') . $i;
    }
    $format .= NL;
  } else {
    $format = ($is_string || $is_multiline) ? '$string\n' : '$_\n';
  }
}

#
# Interpolate special formatting identifiers:
#
%special_formats = (
  '@' => '$sourcename', # filename or original string
  '&' => '$sourcename_nodir', # filename (without directory) or original string
  '%' => '$sourceid',   # number of file or string in order listed on command line
  '#' => '$matches',    # current match number
  '.' => '$.',          # current line number of match
  '-' => '$startpos',   # offset of start of match
  '+' => '$endpos',     # offset of end of match
  '?' => '$matchlen',   # offset of end of match
  '*' => '$matchstr',   # entire matching string
  '_' => '$_',          # entire line containing match
);

my $special_formats_re = 
  qr{(?<! \\) \$(?:
         ([\@\&\%\#\.\-\+\?\*\_]) | 
         (?: \' (\w+) \')
       )}oamsx;

sub replace_special_format {
  my ($format_code, $capture_group_name) = @_;
  #print(STDERR "$RED >>> replace_special_format(fc [$format_code], cgn [$capture_group_name]) <<<$NOCOLOR\n");

  if (is_filled($capture_group_name)) {
    return ('$+{'.$capture_group_name.'}');
  } else {
    if (!exists($special_formats{$format_code})) { die("Format code '$format_code' does not exist!"); }
    return $special_formats{$format_code};
  }
}

if (!$is_eval && !$is_split) {
  if ($format =~ /(?<! \\) \$\@/oamsxg) { $is_show_filenames = 0; $is_show_filenames_at_top = 0; }
  $special_formats_used = ($format =~ s/$special_formats_re/replace_special_format($1, $2)/oamsxge);
  $format_uses_special_vars = ($special_formats_used > 0);
} else {
  $special_formats_used = 0;
}

$format_uses_special_vars = ($special_formats_used > 0);

if ($is_colorize && ($is_full_lines || ($capture_group_count > 0)) && is_stdout_color_capable()) {
  # Obviously we don't want to colorize the actual text we're substituting 
  # into files unless we're also printing that text to the console:
  if ($is_subst) {
    $format = $Y . $format . $X;
  } else {
    $format =~ s/[^\$\\]\K(\$\{?\w+\}?)/${C}$1${Y}/oamsg;
  }
}

if ($is_show_filenames_at_top) { $is_show_filenames = 1; }

if ((!defined $is_show_filenames) && ((($is_filelist && (scalar(@filelist) < 2)) || $is_stdio) && (!defined $file_line_marker_re))) {
  $is_show_filenames = 0;
  $is_show_filenames_at_top = 0;
}

if ($is_show_filenames || $is_colorize) {
  binmode STDOUT, ':utf8';
  binmode STDERR, ':utf8';
}

sub boolean_status_to_string {
  my ($name, $value) = @_;
  $value = ((defined $value) && ($value)) ? 1 : 0;
  my $s = ($value == 1) 
    ? ($G.$U.$name.$X)
    : ($K.'!'.$name.$X);
#    ? ($G.$name.$K.'='.$B.'1'.$X)
#    : ($R.$name.$K.'='.$B.'0'.$X);
  return $s;
}
 
if ($DEBUG) {
  binmode STDOUT, ':utf8';
  binmode STDERR, ':utf8';
  my $H = $B.'// '.$X;
  my $NL = $X.NL;

  print(STDERR $H.' ------------------------ '.$G.$U.'perlre Debug Status'.$X.$K.' ------------------------'.$NL);
  print(STDERR $H.
        boolean_status_to_string("eval", $is_eval).$K.', '.$X.
        boolean_status_to_string("subst", $is_subst).$K.', '.$X.
        boolean_status_to_string("anycase", $is_anycase).$K.', '.$X.
        boolean_status_to_string("invert", $is_invert).$K.', '.$X.
        boolean_status_to_string("multiline", $is_multiline).$NL.$H.
        boolean_status_to_string("string", $is_string).$K.', '.$X.
        boolean_status_to_string("filelist", $is_filelist).$K.', '.$X.
        boolean_status_to_string("stdio", $is_stdio).$K.', '.$X.
        ($is_subst ? (boolean_status_to_string("subst_to_stdout", $is_subst_to_stdout).$NL.$H) : '').
        boolean_status_to_string("test", $is_dry_run).$K.', '.$X.
        boolean_status_to_string("colorize", $is_colorize).$K.', '.$X.
        boolean_status_to_string("show_filenames", $is_show_filenames).$K.', '.$X.
        boolean_status_to_string("show_filenames_at_top", $is_show_filenames_at_top).$NL.$H.
        ($is_split ? (boolean_status_to_string("key_lowercase", $is_key_lowercase).$K.', '.$X) : '').
        ($is_split ? (boolean_status_to_string("key_uppercase", $is_key_uppercase).$NL) : ''));
  print(STDERR $H.boolean_status_to_string("show_colorized_compiled_regexps", $show_colorized_compiled_regexps).$NL);
  print(STDERR 
        $H.$Y.'matching_line_count_limit '.$X.$matching_line_count_limit.$NL.
        $H.$Y.'format_uses_special_vars '.$X.$format_uses_special_vars.$NL);
  print(STDERR $H.$NL);
  #my $formatted_orig_regexp = $orig_regexp;
  #if ($is_colorize) { $formatted_orig_regexp = format_regexp($orig_regexp); }
  #my $formatted_exp_regexp = $expanded_regexp;
  #if ($is_colorize) { $formatted_exp_regexp = format_regexp($expanded_regexp); }

  print(STDERR $H.$Y.'original RE'.$K.' = '.NL); show_compiled_regexp('original', $orig_regexp);
  print(STDERR $H.$Y.'expanded RE'.$K.' = '.NL); show_compiled_regexp('expanded', $expanded_regexp);
  print(STDERR $Y.'compiled RE'.$K.' = '.NL); show_compiled_regexp('compiled', $regexp);
  print(STDERR $Y.'compiled RE from text form'.$K.' = '.format_quoted($compiled_regexp_as_text).NL);
  print(STDERR $H.$Y.'RE options '.$K.' = '.left_quote.$G.$regexp_opts.$K.right_quote.$NL);
  print(STDERR $H.$Y.'Capture groups '.$K.'('.$Y.$capture_group_count.$K.' groups)'.$NL);
  #for (my $i = 0; $i < $capture_group_count; $i++) {
  #my $g = $capture_groups[$i];
  #print(STDERR "  ${Y}".$i."${K} = ${left_quote}${G}".$g."${K}${right_quote}${X}\n");
  #}
  #printf(STDERR "${K}\}${X}\n");
  if ($is_split) {
    print(STDERR $H.$Y.'split-key-prefix'.$K.' = '.left_quote.$G.$split_key_prefix.$K.right_quote.$NL);
    print(STDERR $H.$Y.'split-key-suffix'.$K.' = '.left_quote.$G.$split_key_suffix.$K.right_quote.$NL);
  }
  if ($is_subst) {
    print(STDERR $H.$Y.'subst_output_dir_prefix'.$K.' = '.left_quote.$G.$subst_output_dir_prefix.$K.right_quote.$NL);
  }

  my $printed_format = ($format =~ s/\n/\\n/rmsg =~ s/\t/\\t/rmsg =~ s/\r/\\r/rmsg =~ s/\e/\\e/rmsg);
  $printed_format =~ s{\\(.)}{${B}$1${X}}msg;

  print(STDERR $H.$Y.'format (' . (($format_specified) ? 'specified' : 'default') . ')'.$K.' = '.
        left_quote.$G.$printed_format.$K.right_quote.$NL);
  if ($is_string) {
    print(STDERR $H.$Y.'string'.$K.' = '.left_quote.$G.$string.$K.right_quote.$NL);
  }
  print(STDERR $H.$Y.'program name'.$K.' = '.left_quote.$G.$0.$K.right_quote.$NL);
  if ($is_filelist) {
    print(STDERR $H.$Y.$U.'Filename list ('.(scalar @filelist).' files):'.$NL);
    foreach $filename (@filelist) { print(STDERR $H.'  '.$filename.$NL); }
  }
  print(STDERR $H.$K.'-------------------- End of perlre Debug Status ---------------------'.$NL);
}

if (!$is_eval) {
  if ($is_subst) {
    $format = '"' . $format . '"';
  } else {
    $format = '"' . "$format" . '"';
  }
}

# This is customized to the longest filename later:
my $max_filename_length = 40;

sub process_file {
  my ($filename, $outfile, $fileid) = @_;
  local $/ = $/;
  # These identifiers may be used by the format:
  my $sourcename = $filename;
  my $sourcename_nodir = basename($filename);
  my $sourceid = $fileid;

  my $already_printed_filename = 0;

  if ($is_subst && is_same_file($filename, $0)) {
    show_warning("file '$filename' is perlre itself (skipping this file)");
    return -3;
  }

  if (!open($IN, '<', $filename)) {
    show_warning("Warning: cannot open file '$filename' (skipping this file)");
    return -1;
  }
  
  my @infile_stats = stat($IN);
  my $orig_file_permissions = $infile_stats[STAT_MODE];

  my $is_stdout = ($outfile eq '/dev/stdout');
  if ($is_stdout) {
    $OUT = STDOUT;
  } else {
    if (!sysopen($OUT, $outfile, O_WRONLY|O_CREAT|O_TRUNC, $orig_file_permissions)) {
      show_warning("Warning: cannot open file '$filename' (skipping this file)");
      return -2;
    }
  }

  # print(STDERR "Processing $filename -> $outfile:\n") if ($is_verbose);

  #
  # If we're asked to consider the entire input like a single line,
  # we need to read it all in at once just as if it were specified
  # as a string argument instead:
  #
  my $old_line_sep = $/;
  
  if ($is_multiline) {
    # turn off line separators so we can read in one very long line:
    $/ = undef; 
  }

  my $matches = 0;
  my $linenum = 1;
  my $linenum_last_redefined_at_real_line = 1;

  if ($is_subst) {
  L: while (<$IN>) {
      study($_) if (length($_) >= 1024);
      my $m = ($_ =~ s/$regexp/$format/gee);
      print($OUT $_);
      $matches += $m; last L if ($matches >= $matching_line_count_limit);
    }
    if (!$is_stdout) {
      my $ok = ($matches > 0);
      my $cc = is_stderr_color_capable();
      local $r = ($cc ? R : '');
      local $g = ($cc ? G : '');
      # local $b = ($cc ? B : '');
      local $c = ($cc ? C : '');
      # local $m = ($cc ? M : '');
      local $y = ($cc ? Y : '');
      local $k = ($cc ? fg_color_rgb(48, 112, 128) : '');
      local $x = ($cc ? X : '');
      my $s = ($ok ? $g : $r).' '.($ok ? checkmark : x_symbol).' '.
        ($ok ? $c : $k).padstring($filename, $max_filename_length).
        ' '.($ok ? $g.arrow_tri : $r.arrow_open_tri).' '.($ok ? ($g.padstring($matches, -4).$y.
        ' replacements') : ($r.(' ' x 4).' no matches')).$x.NL;
      print(STDERR $s);
    }
  } else { # not $is_subst (i.e. regular matching without substitution)
  L: while (<$IN>) {
      chomp;
      # if ($DEBUG) { print(STDERR $K.'['.$B.'line '.$Y.$linenum.$K.': '.
      #                    $Y.length($_).$B.' chars = '.$K.left_quote.
      #                    $G.$_.$K.right_quote.']'.$X.NL); }
      study($_) if (length($_) >= 1024);
      my $origline = $_;

      if ((defined $file_line_marker_re) && ($origline =~ /$file_line_marker_re/)) {
        $sourcename = $+{file} // $sourcename;
        $sourcename_nodir = filename_of($sourcename);
        $linenum = $+{line} // ($. - $linenum_last_redefined_at_real_line);
        $linenum_last_redefined_at_real_line = $.;
      }

      if ($is_invert) {
        if (!/$regexp/g) {
          print($OUT "$_\n");
          $matches++;
        }
      } else {
        #print(STDERR $R.'Match line '.format_quoted($G.$_).' against regexp '.
        #format_quoted($C.$regexp).$R.':'.$X.NL);
        while (/$regexp/gc) {
          if ($format_uses_special_vars) {
            foreach my $k (keys %+) { $$k = $+{$k}; }
            my $startpos = $-[0]; my $endpos = $+[0]; my $matchlen = $endpos - $startpos;
            my $matchstr = substr($_, $startpos, $matchlen);
          }
          if ($is_eval) {
            eval $format; 
          } else {
            if ($is_show_filenames && (!$already_printed_filename)) {
              print(STDERR $B.' '.checkmark.' '.$Y.
              padstring($sourcename, $max_filename_length).$K.' @ '.$M.
              padstring($linenum, 5).$B.' '.arrow_head.' '.$X);
              if ($is_show_filenames_at_top) {
                $already_printed_filename = 1;
                print(STDERR NL);
              }
            }
            
            if ($is_colorize && ($capture_group_count > 0) && $is_full_lines) {
              my $s = $origline;
              $s =~ s/$regexp/$Y.(eval $format).$K/ge;
              print($STDERR $K.$s.$X.NL);
            } else {
              my $s = (eval $format) // '';
              print($OUT $s);
            }
          }
          $matches++;
        }
      }
      last L if ($matches >= $matching_line_count_limit);
      $linenum++;
    } # end foreach line
  } # end if regular matching

  close($IN);
  close($OUT) unless ($is_stdout);

  return $matches;
}

#
# note: strings may also be mapped to filehandles using:
#
#   open($h, '<', \$stringvar);
#   while <$h> { ... }
#
# ...but we use a distinct process_string() function for this
# since the semantics are slightly different (and much simpler)
# vs processing actual files:
#

sub process_string {
  my ($string, $stringid) = @_;
  my $matches = 0;
  my $sourcename = $string;
  my $sourcename_nodir = $string;
  my $sourceid = $stringid;

  study($string) if (length($string) >= 1024);

  if ($is_subst) {
    $matches = ($string =~ s/$regexp/$format/gee);
    print($string);
  } else { # not $is_subst (i.e. regular matching without substitution)
    L: while ($string =~ /$regexp/g) {
      if ($format_uses_special_vars) {
        foreach my $k (keys %+) { $$k = $+{$k}; }
        my $startpos = $-[0]; my $endpos = $+[0]; my $matchlen = $endpos - $startpos;
        my $matchstr = substr($string, $startpos, $matchlen);
      }
      my $startpos = $-[0]; my $endpos = $+[0]; my $matchlen = $endpos - $startpos;
      if ($is_eval) { eval $format; } else { print(eval $format); }
      $matches++; last L if ($matches >= $matching_line_count_limit);
    }
  } # end if regular matching

  return $matches;
}

$total_matches = 0;

if ($is_stdio) {
  $total_matches = process_file('/dev/stdin', '/dev/stdout');
  print(STDERR $G.$total_matches.' total matches'.$X.NL) if ($is_verbose);
} elsif ($is_filelist) {
  my $fileid = 0;
  $max_filename_length = maxlength(@filelist);
  foreach $filename (@filelist) {
    my $outfile = '/dev/stdout';
    my $backupfile = $filename.'@pre-SUBST-backup';

    if ($is_subst) {
      if (defined $subst_output_dir_prefix) {
        $outfile = $subst_output_dir_prefix . '/' . $filename;
        $dirname = dirname($outfile);
        make_path($dirname);
      } elsif ($is_subst_to_stdout) {
        $outfile = '/dev/stdout';
        $backup_before_subst = 0;
        $overwrite_with_subst = 0;
      } elsif ($is_dry_run) {
        $outfile = '/dev/null';
        $backup_before_subst = 0;
        $overwrite_with_subst = 0;
      } else {
        $outfile = $filename.'@SUBST';
      }
    }

    my $matches = process_file($filename, $outfile, $fileid);

    if ($matches > 0) {
      $total_matches += $matches;
      if ($is_subst) {
        # printf("%6d replacements in %s\n", $matches, $filename) if ($is_verbose);
        if (!(defined $subst_output_dir_prefix)) {
          if ($backup_before_subst) {
            rename($filename, $backupfile) || 
            print("perlre: Warning: cannot rename $filename to $backupfile\n");
          }
          if ($overwrite_with_subst) {
            rename($outfile, $filename) || 
              print("perlre: Warning: cannot replace $filename with $outfile (left $outfile in place)\n");
          }
        }
      } else {
        ; # printf("%6d matches in %s\n", $matches, $filename) if ($is_verbose);
      }
    } elsif ($matches == 0) {
      # No need to do anything except deleting the identical @SUBST version
      if ($is_subst && !(defined $subst_output_dir_prefix)) { unlink($outfile); }
    } else { # ($matches < 0)
      # some error already reported by process_file
    }
    $fileid++;
  }

  if ($is_verbose) {
    print("$total_matches total ".($is_subst ? "replacements" : "matches").
          " in ".(scalar @filelist)." files\n")
  }
} elsif ($is_string) {
  my $stringid = 0;
  $total_matches = process_string($string, $stringid);
  print(STDERR $G.$total_matches.' total matches'.$X.NL) if ($is_verbose);
  $stringid++;
}

exit(0);

