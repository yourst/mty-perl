#!/usr/bin/perl -w
# -*- cperl -*-
#
# lls: Enhanced 'ls' for file and directory listings 
#
# Supports display of mount points, subvolumes, open files, ACLs, 
# extended attributes and more, all in beautiful color coded style
# to integrate all this information into one easy to read listing!
#
# Copyright 2003 - 2014 Matt T. Yourst <yourst@yourst.com>
#

use integer; use warnings; 

use MTY::System::POSIX;
use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Common::Strings;
use MTY::Common::CommandLine;

use MTY::Filesystem::Files;
use MTY::Filesystem::PathCache;
use MTY::Filesystem::StatsCache;
use MTY::Filesystem::FileStats;
use MTY::Filesystem::EnhancedFileStats;
use MTY::Filesystem::ProcFS;
use MTY::Filesystem::OpenFiles;
use MTY::Filesystem::ExtAttrs;
use MTY::Filesystem::Mounts;

use MTY::Display::Colorize;
use MTY::Display::ColorizeErrorsAndWarnings;
use MTY::Display::ANSIColorREs;
use MTY::Display::PrintableSymbols;
use MTY::Display::PrintableSymbolTools;
use MTY::Display::Table;
use MTY::Display::Tree;
use MTY::Display::TextInABox;

use MTY::RegExp::Define;
use MTY::RegExp::Tools;
use MTY::RegExp::Numeric;
use MTY::RegExp::Strings;
use MTY::RegExp::Blocks;
use MTY::RegExp::FilesAndPaths;
use MTY::RegExp::Networks;

use MTY::System::Misc;

use Time::Piece;

#
# These are set by various command line options:
#
my $sort_field = STAT_TYPE;
my $sort_reverse = 0;
my $long_format = 1;
my $show_all = 1;
my $follow_symlinks_on_command_line = 0;
my $follow_symlinks_to_dirs_on_command_line = 0;
my $stat_symlink_target = 0;
my $print_column_headers = 0;
my $combine_common_uid_gid = 1;
my $max_file_size_decimal_digits = 7;
my $comma_separated_digits = 1;
my $human_readable_sizes = 0;
my $show_directory_itself = 0;
my $only_show_directories = 0;
my $only_show_files = 0;
my $only_show_symlinks = 0;
my $show_dot_and_dot_dot = 0;
my $match_all_patterns = 0;
my $match_any_patterns = 1;
my $show_acls = 1;
my $show_acls_only_for_dirs = 0;
my $show_xattrs = 1;
my $show_extents = 0;
my $print_timestamps_with_am_pm = 0;
my $print_today_for_mtime_in_past_24_hours = 0;
my $shaded_color_coeff = 0.65;

my $debug_layout = 0;

my $DEBUG = 0;

#
# Colors, symbols and formatting:
#
my $vert_sep_bar_color = fg_color_rgb(96, 96, 96);

my $light_bgcolor = bg_color_rgb(20, 10,  24);
my $dark_bgcolor = bg_color_rgb(12, 6, 20);

my $open_light_bgcolor = bg_color_rgb(16, 20, 8);
my $open_dark_bgcolor = bg_color_rgb(10, 16, 4);

my $inaccessible_color_rgb = [ 255, 64, 64 ];
my $inaccessible_light_bgcolor = bg_color_rgb(22, 5, 10);
my $inaccessible_dark_bgcolor = bg_color_rgb(14, 3, 8);

my $perm_field_color = fg_color_rgb(48, 48, 48);

use constant { darkK => fg_gray(96) };
my $darkK = darkK;

my $filename_color = fg_color_rgb(204, 204, 204);
my $directory_color = fg_color_rgb(64, 192, 240);
my $block_dev_color = fg_color_rgb(255, 224, 140);
my $char_dev_color  = fg_color_rgb(255, 140, 224);
my $pipe_color      = fg_color_rgb(128, 116, 255);
my $socket_color    = fg_color_rgb(128, 240, 240);
my $symlink_sym_color   = fg_color_rgb(192, 96, 255);

my $filename_suffix_color = fg_color_rgb(255, 224, 0);
my $filename_dots_color = scale_rgb_fg($filename_suffix_color, 0.75);

my $executable_filename_color = fg_color_rgb(96, 255, 128);
my $script_filename_color = fg_color_rgb(128, 255, 96);
my $backup_filename_color = fg_color_rgb(112, 112, 112);
my $privileged_executable_filename_color = fg_color_rgb(255, 128, 0);
my $dot_filename_color = fg_color_rgb(216, 128, 160);

my @file_type_colors = (
  $K, # (invalid)
  $pipe_color, # (pipe)
  $char_dev_color,  # (char dev)
  $K,   
  $directory_color, # directory  
  $K,
  $block_dev_color, # (block dev)
  $K,
  $filename_color, # (file)
  $K,
  $symlink_sym_color, # (symlink)
  $K,
  $socket_color, # (socket)
  $K,
  $K,
  $K,
);

my @file_type_enhanced_symbols = (
  x_symbol,   # (invalid)
  small_down_barbed_arrow.$C.dashed_vert_bar_3_dashes.$B.small_up_barbed_arrow, # (pipe)
  degrees_c,  # (char dev)
  '?3',   
  large_plus, # directory  
  '?5',  
  double_disc,  # (block dev)
  '?7',
  arrow_open_tri,   # (file)
  '?9',  
  long_bold_right_arrow,  # (symlink)
  '?B',   
  telephone_in_circle,  # (socket)
  '?D',   
  '?E', 
  '?F'
);

my @file_type_textual_symbols = (
  'X', # (invalid)
  'p', # (pipe)
  'c', # (char dev)
  '?',   
  chr(0x216e), # directory
  '?',  
  'b', # (block dev)
  '?',
  ' ', # (file)
  '?',  
  large_arrow_barbed,  # (symlink)
  '?',   
  's', # (socket)
  '?',   
  '?', 
  '?'
);

my @mount_type_colors = (
  fg_color_rgb(255, 165, 63),    # (block dev)
  fg_color_rgb(64, 64, 255),    # (bind mount)
  $B,    # (memory tmpfs)
  $Y,    # (system - provided by kernel)
  $K,    # (anonymous namespaces)
  $G,    # (network)
  $M,    # (fuse)
);

my @mount_type_enhanced_symbols = (
  double_disc,    # (block dev)
  large_arrow_barbed,    # (bind mount)
  double_colon,    # (memory tmpfs)
  warning_sign,    # (system - provided by kernel)
  '??',            # (anonymous namespaces)
  telephone_in_circle.lightning_spark,    # (network)
  'F'.lightning_spark,    # (fuse)
);

my @mount_type_textual_symbols = (
  'M',    # (block dev)
  'Mb',    # (bind mount)
  'Mm',    # (memory tmpfs)
  'Mk',    # (system - provided by kernel)
  'M?',            # (anonymous namespaces)
  'M'.lightning_spark,    # (network)
  'Mf',    # (fuse)
);

# These are indexed by $stat->[STAT_MODE] - 512:
my @subvol_type_symbols = ('V ', 'SS');

my @subvol_type_colors = (
  fg_color_rgb(216, 0, 255), # subvolume
  fg_color_rgb(192, 64, 236), # snapshot
);

my @subvol_type_textual_symbols = (
  roman_numeral_v,
  'SS' 
);

sub get_file_type_color($) {
  my ($type) = @_;

  return 
    ($type < FILE_TYPE_MOUNT_POINT) ? $file_type_colors[$type] :
    ($type < FILE_TYPE_SUBVOLUME) ? $mount_type_colors[$type - FILE_TYPE_MOUNT_POINT] :
    $subvol_type_colors[$type - FILE_TYPE_SUBVOLUME];
}

sub format_file_type_symbols($) {
  my ($stats) = @_;
  
  my ($type, $mode, $fstype, $is_accessible) = @{$stats}[STAT_TYPE, STAT_MODE, STAT_FSTYPE, STAT_IS_ACCESSIBLE];

  my $c = get_file_type_color($type);

  return 
    ' '.(($type < FILE_TYPE_MOUNT_POINT) ? $c.padstring($file_type_textual_symbols[$type], 2) :
    ($type < FILE_TYPE_SUBVOLUME) ? $C.square_root_symbol.$c.$mount_type_textual_symbols[$type - FILE_TYPE_MOUNT_POINT] :
    $c.$subvol_type_textual_symbols[$type - FILE_TYPE_SUBVOLUME]).($is_accessible ? ' ' : Y.'!');
}

my $setxid_color = U.fg_color_rgb(255, 128, 0);

use constant {
  Rc => G.'r', # read
  Wc => M.'w', # write
  Xc => C.'x', # execute or traverse (for dirs)
  XSc => R.U.'s'.UX, # setuid or setgid
  NA => darkK.dot_small
};

my $euid;
my $egid;
my @groups;

my @perm_set_to_colors = (
  NA.NA.NA,
  NA.NA.Xc, 
  NA.Wc.NA,
  NA.Wc.Xc, 
  Rc.NA.NA,
  Rc.NA.Xc, 
  Rc.Wc.NA,
  Rc.Wc.Xc,
);

use constant setxid_color => fg_color_rgb(255, 128, 0); # orange

my @perm_field_id_to_setxid_color = (
  setxid_color.U, # O field (other) lacks setuid/setgid bits
  setxid_color.U, # G field (group)
  setxid_color.U, # U field (user)
  setxid_color.U, # S field (if explicitly printed)
  setxid_color.U, # ACL
  setxid_color.U, # effective permissions pseudo-field (if explicitly printed)
);

my @perm_field_id_to_setxid_format = (
  's', # O field (other) lacks setuid/setgid bits
  'G', # G field (group)
  'S', # U field (user)
  'S', # S field (if explicitly printed)
  undef, # ACL
  'S', # effective permissions pseudo-field (if explicitly printed)
);

use constant {
  PERM_R_ANY_UGO => (PERM_R << 0) | (PERM_R << 3) | (PERM_R << 6),
  PERM_W_ANY_UGO => (PERM_W << 0) | (PERM_W << 3) | (PERM_W << 6),
  PERM_X_ANY_UGO => (PERM_X << 0) | (PERM_X << 3) | (PERM_X << 6)
};

sub format_permission_field($$;$$$$$) {
  my ($rwx, $allperms, $underlined_mask, $filetype, $is_accessible, $ugo_acl_or_other, $capabilities_xattr) = @_;

  $filetype //= FILE_TYPE_FILE;
  $ugo_acl_or_other //= PERM_FIELD_S;
  $is_accessible //= 1;
  
  my $is_s = ($ugo_acl_or_other == PERM_FIELD_S);
  my $is_u = ($ugo_acl_or_other == PERM_FIELD_U);
  my $is_g = ($ugo_acl_or_other == PERM_FIELD_G);
  my $is_o = ($ugo_acl_or_other == PERM_FIELD_O);

  my $is_setxid = 
    ($allperms & 
      ($is_u ? PERM_SETUID : 
       $is_g ? PERM_SETGID :
       PERM_SETUID|PERM_SETGID)) ? 1 : 0;
  my $is_setcap = (defined $capabilities_xattr) ? 1 : 0;

  my $is_mandatory_locking = 
    ($allperms & PERM_SETGID) && (!($allperms & S_IXGRP)) ? 1 : 0;

  my $is_sticky = ($allperms & PERM_STICKY) ? 1 : 0;

  my $none = $perm_field_color.($is_accessible ? dot_small : dot_small);
  my $under_r = ($underlined_mask & PERM_R) ? U : '';
  my $under_w = ($underlined_mask & PERM_W) ? U : '';
  my $under_x = ($underlined_mask & PERM_X) ? U : '';

  my $oldU = ($underlined_mask != 0) ? UX : '';

  my $out = ($rwx & PERM_R) ? ((($under_r) ? G.U : G_1_2).'r'.$oldU) : $none;

  $out .= ($rwx & PERM_W) ? ((($under_w) ? M.U : M_2_3).(($is_sticky && $is_s) ? 'a' : 'w').$oldU) : $none;

  my $setxid_format = $perm_field_id_to_setxid_format[$ugo_acl_or_other];

  $out .= $under_x;
  if ($rwx & PERM_X) {
    $out .= ($is_setxid)
      ? $setxid_color.$setxid_format 
      : ($is_setcap && $under_x) ? $setxid_color.'C' : (($under_x) ? Y.U : Y_2_3).'x';
    $out .= UX;
  } else { # ! PERM_X
    $out .= ($is_s && $is_mandatory_locking) 
      ? R.'K' : ($is_setxid ? K.$setxid_format : $none);
  }
  $out .= $oldU;
  return $out;
}

my $different_uid_gid_color = fg_color_rgb(255, 224, 128);
my $same_uid_gid_color = scale_rgb_fg($different_uid_gid_color, $shaded_color_coeff);
my $unknown_uid_gid_color = fg_color_rgb(255, 64, 128);

my $xattr_symbol = fg_color_rgb(255, 80, 180).chr(0x212f).chr(0x03b1); # stylized "ea" 
my $acl_or_caps_symbol = fg_color_rgb(255, 160, 64).a_slash_c;

my $symlink_type_color = fg_color_rgb(224, 128, 192);
my $symlink_type_shaded_color = scale_rgb_fg($symlink_type_color, 0.667);

sub format_stat_mode_permissions($;$$$$$) {
  my ($stats, $show_user, $show_group, $all_files_in_dir) = @_;

  $show_user //= 0;
  $show_group //= 0;

  my ($perms, $fileuid, $filegid, $type, $acl, $default_acl) = @{$stats}
    [STAT_MODE, STAT_UID, STAT_GID, STAT_TYPE, STAT_ACL, STAT_DEFAULT_ACL];

  my $perms_column = '';

  my $filename = $stats->[STAT_NAME];
  my $user_perms  = bits($perms, 6, 3);
  my $group_perms = bits($perms, 3, 3);
  my $other_perms = bits($perms, 0, 3);

  my $is_accessible = ($stats->[STAT_IS_ACCESSIBLE]) ? 1 : 0;
  my $is_setuid = ($perms & PERM_SETUID) ? 1 : 0;
  my $is_setgid = ($perms & PERM_SETGID) ? 1 : 0;
  my $is_sticky = ($perms & PERM_STICKY) ? 1 : 0;

  my $xattrs = $stats->[STAT_XATTRS];
  my $capabilities_xattr = $stats->[STAT_CAPABILITIES];
  my $is_setcap = (defined $capabilities_xattr) ? 1 : 0;

  my $file_gid_matches_group = is_user_member_of_group($filegid);

  my @perms_contributed_by_fields = (31, 31, 31);

  my $effective_perms = $other_perms;

  masked_store_into_array(@perms_contributed_by_fields, PERM_FIELD_O, $other_perms);

  if ($file_gid_matches_group) { 
    $effective_perms |= $group_perms; 
    masked_store_into_array(@perms_contributed_by_fields, PERM_FIELD_G, $group_perms);
  }

  if ($fileuid == $euid) {
    $effective_perms |= $user_perms;
    masked_store_into_array(@perms_contributed_by_fields, PERM_FIELD_U, $user_perms);
  }

  my $u_field_contrib = compare_vec_to_scalar_and_generate_bitmask
    (@perms_contributed_by_fields, PERM_FIELD_U);
  my $g_field_contrib = compare_vec_to_scalar_and_generate_bitmask
    (@perms_contributed_by_fields, PERL_FIELD_G);
  my $o_field_contrib = compare_vec_to_scalar_and_generate_bitmask
    (@perms_contributed_by_fields, PERL_FIELD_O);

  my $file_username = lookup_user_name_from_uid($fileuid);
  my $file_groupname = lookup_group_name_from_gid($filegid);

  if ($stats->[STAT_TYPE] != FILE_TYPE_SYMLINK) {
    $perms_column .= 
      #format_permission_field($effective_perms, $perms, 0b111, $type, $is_accessible, PERM_FIELD_EFFECTIVE).$darkK.': '.
      format_permission_field($user_perms, $perms, $u_field_contrib, $type, $is_accessible, PERM_FIELD_U, $capabilities_xattr).' '.
      format_permission_field($group_perms, $perms, $g_field_contrib, $type, $is_accessible, PERM_FIELD_G, $capabilities_xattr).' '.
      format_permission_field($other_perms, $perms, $o_field_contrib, $type, $is_accessible, PERM_FIELD_O, $capabilities_xattr).'  ';

    my $access_acl = $stats->[STAT_ACL];
    my $default_acl = $stats->[STAT_DEFAULT_ACL];
    my $capabilities = $stats->[STAT_CAPABILITIES];

    my $xattrs = $stats->[STAT_XATTRS];
    my $user_xattr_count = 0;
    my $system_xattr_count = 0;

    foreach $xattr (keys %$xattrs) {
      if (starts_with($xattr, 'user.')) { $user_xattr_count++; } else { $system_xattr_count++; }
    }

    $perms_column .= ((defined $access_acl || defined $default_acl || defined $capabilities)) ? $acl_or_caps_symbol : ' ';
    $perms_column .= ' '.(($user_xattr_count > 0) ? $xattr_symbol : '  ').'  ';
  } else { # format symlink category in place of unused permissions
    my $dir = directory_of($stats->[STAT_PATH]);
    my $symlink_target_exists = 0;
    my $absolute_symlink_target = undef;

    my $symlink = $stats->[STAT_SYMLINK];

    my $is_unreadable_symlink = (!defined $symlink);
    $symlink //= '???';
    my $is_absolute = ($symlink =~ /\A \//oamsx);
    my $is_relative = !$is_absolute;
    my $is_same_dir = ($symlink =~ /\A [^\/]+ \Z/oamsx);
    my $is_url = ($symlink =~ /^\w+:\/\//oax);
    my $is_edit_lock = (($symlink =~ /^[^@]+@[\w\-\_\.]+/) && ($filename =~ /^\.\#/oax));
    my $symlink_relative_to_dir = ($is_absolute) ? '' : $dir.'/';
    $absolute_symlink_target = ($is_same_dir) ? $dir.'/'.$symlink : path_exists($symlink_relative_to_dir.$symlink);
    $symlink_target_exists = (!$is_unreadable_symlink) && (($is_same_dir) ? (exists $all_files_in_dir->{$symlink}) : (defined $absolute_symlink_target));

    my $is_deeper_relative = $is_relative && (defined $absolute_symlink_target) && starts_with($absolute_symlink_target, $dir.'/');
    my $is_outer_relative = $is_relative && (!$is_deeper_relative);

    my $c = $symlink_type_color;
    my $cs = $symlink_type_shaded_color;

    my $symlink_status =
      ($symlink_target_exists) ?
        ($is_same_dir ?        $c.'same dir'.$cs.' symlink' :
         $is_absolute ?        $c.'absolute'.$cs.' symlink' :
         $is_deeper_relative ? $cs.'symlink '.$c.'within  ' :
         $is_outer_relative ?  $cs.'symlink '.$c.'outside ' :
         'existing symlink') : 
         # target does not exist (or is inaccessible and invisible)
        ($is_unreadable_symlink ? $c. 'cannot read link' :
         $is_url ?                $cs.'symlink to '.$c.'URL  ' :
         $is_edit_lock ?          $c.'editor lock '.$cs.'link' :
         $is_same_dir ?           $c.'pseudo '.$cs.'symlink  ' :
         $c.'dangling'.$cs.' symlink');

    $perms_column .= $symlink_status.$K.'   ';
  }

  my $user_column = ($show_user) ?
    (($is_setuid) ? U.R : ($fileuid == $euid) ? $same_uid_gid_color : 
     (!defined $file_username) ? $unknown_uid_gid_color : $different_uid_gid_color).
     ($file_username // sharp_sign.$fileuid).UX : undef;

  my $group_column = ($show_user && $show_group) ?
    (($is_setgid) ? U.R : ($file_gid_matches_group) ? $same_uid_gid_color : 
     (!defined $file_groupname) ? $unknown_uid_gid_color : $different_uid_gid_color).
     ($file_groupname // sharp_sign.$filegid).UX : undef;

  # leave space for xattrs, capabilities and ACL indicators:
  return ($perms_column, $user_column, $group_column);
}

sub format_link_count($) {
  my ($stats) = @_;

  my $n = $stats->[STAT_NLINK];

  if ($n > 1) {
    return rgbfgM.$n.M_1_2.'L';
  } else {
    return '';
  }
}

BEGIN {
  no integer;

  use constant {
    LOG_2    => log(2),
    LOG_10   => log(10),
    LOG_16   => log(16),
    LOG_64   => log(64),
    LOG_256  => log(256),
    LOG_1024 => log(1024),
    LOG_1000 => log(1024),
    LOG_4096 => log(4096)
  };

  use constant {
    RECIP_LOG_2 => 1.0 / LOG_2,
    RECIP_LOG_10 => 1.0 / LOG_10,
    RECIP_LOG_16 => 1.0 / LOG_16,
    RECIP_LOG_64 => 1.0 / LOG_64,
    RECIP_LOG_256 => 1.0 / LOG_256,
    RECIP_LOG_1000 => 1.0 / LOG_1000,
    RECIP_LOG_1024 => 1.0 / LOG_1024,
    RECIP_LOG_4096 => 1.0 / LOG_4096,
  };

  use integer;
};

no integer;

sub log_base_2($) {
  my $v = $_[0]; if ($v <= 0) { $v = 1; }

  return log($_[0]) * RECIP_LOG_2;
}

sub log10($) {
  return log($_[0]) * RECIP_LOG_10;
}

sub log1024($) {
  return log($_[0]) * RECIP_LOG_1024;
}

use integer;

my $file_size_color = fg_color_rgb(192, 96, 255);
my $file_size_sep_color = scale_rgb_fg($file_size_color, 0.75);
my $file_size_units_color = fg_color_rgb(236, 0, 180);

my $small_file_size_color = fg_color_rgb(64, 160, 224);
my $small_file_size_sep_color = scale_rgb_fg($small_file_size_color, 0.75);

my $small_file_size_comma_sep;
my $file_size_comma_sep;
my $small_file_threshold;

sub format_file_size($) {
  my ($stats) = @_;

  #
  # try to limit the printed length to 7 decimal digits
  # (9 characters including two digit group separators),
  # plus the power-of-1024 letters (K/M/G/T/P/E)b, for
  # a total maximum length of 12 characters:
  #

  $small_file_size_comma_sep //= ($comma_separated_digits) ? $small_file_size_sep_color.','.$small_file_size_color : '';
  $file_size_comma_sep //= ($comma_separated_digits) ? $file_size_sep_color.','.$file_size_color : '';
  $small_file_threshold //= int('9' x $max_file_size_decimal_digits);

  my $size = $stats->[STAT_SIZE];
  my $sep = ($size <= $small_file_threshold) ? $small_file_size_comma_sep : $file_size_comma_sep;
  my $color = ($size <= $small_file_threshold) ? $small_file_size_color : $file_size_color;

  return $color.format_size_with_units(
    $stats->[STAT_SIZE], $max_file_size_decimal_digits, 
    $sep, $file_size_units_color.' ', 'b');
}

use constant { timestamp_base_color => fg_color_rgb(0, 255, 192), };
use constant { timestamp_shaded_color => scale_rgb_fg(timestamp_base_color, 0.30), };

my $current_timestamp = undef;

use constant SECONDS_PER_MINUTE => 60;
use constant SECONDS_PER_HOUR => 60*SECONDS_PER_MINUTE;
use constant SECONDS_PER_DAY => 24*SECONDS_PER_HOUR;
use constant SECONDS_PER_WEEK => 7*SECONDS_PER_DAY;
use constant SECONDS_PER_MONTH => 30*SECONDS_PER_DAY;
use constant SECONDS_PER_YEAR => 365*SECONDS_PER_DAY;

my @oldness_category_params = (
  [ 1,                  'sec', scale_rgb_fg(timestamp_base_color, 1.00), ],
  [ SECONDS_PER_MINUTE, 'min', scale_rgb_fg(timestamp_base_color, 0.90), ],
  [ SECONDS_PER_HOUR,   'hrs', scale_rgb_fg(timestamp_base_color, 0.75), ],
  [ SECONDS_PER_DAY,    'Day', scale_rgb_fg(timestamp_base_color, 0.60), ],
  [ SECONDS_PER_MONTH,  'Mon', scale_rgb_fg(timestamp_base_color, 0.45), ],
  [ SECONDS_PER_YEAR,   'Yrs', scale_rgb_fg(timestamp_base_color, 0.30), ]
);

my $current_local_time = localtime();

sub format_file_timestamp($;$$) {
  my ($stats, $show_nanosec_precision, $newest_file_timestamp_in_listing) = @_;
  $show_nanosec_precision //= 0;
  my $timestamp = $stats->[STAT_MTIME];
  my $nanoseconds = $stats->[STAT_MTIME_NS];

  $current_timestamp //= clock_gettime_nsec();
  $newest_file_timestamp_in_listing //= $nanoseconds;

  my $nsec_in_past = $current_timestamp - $nanoseconds;
  my $sec_in_past = $nsec_in_past / BILLION;
  my $days_in_past = $sec_in_past / SECONDS_PER_DAY; # i.e. 86400 seconds/day

  my $nsec_in_past_of_newest_in_listing =
    $current_timestamp - ($newest_file_timestamp_in_listing / BILLION);
  my $days_in_past_of_newest_in_listing = 
    $nsec_in_past_of_newest_in_listing / SECONDS_PER_DAY; 

  my $all_files_over_a_day_old = ($days_in_past_of_newest_in_listing >= 1);

  my $oldness_category = 
    ($sec_in_past < SECONDS_PER_MINUTE) ? 0 :
    ($sec_in_past < SECONDS_PER_HOUR)   ? 1 :
    ($sec_in_past < SECONDS_PER_DAY)    ? 2 :
    ($sec_in_past < SECONDS_PER_MONTH)  ? 3 :
    ($sec_in_past < SECONDS_PER_YEAR)   ? 4 : 5;
 
  my ($seconds_divisor, $abbrev, $color) = @{$oldness_category_params[$oldness_category]};
  my $darkcolor = timestamp_shaded_color;

  #
  # For most printing purposes, only use the whole seconds resolution of 
  # modification timestamps (mtimes). However, if sorting by timestamp 
  # was requested by the user, in which case we sort based on the full 
  # nanosecond precision timestamps, and we print out the nanosecond part 
  # in this case, since presumably the user is interested in precisely
  # seeing which files are newer or older than other files (a task at
  # which the standard gnu coreutils version of 'ls' fails miserably).
  #
  my $t = localtime($timestamp);
  my ($weekday, $monthname, $year, $month, $day, $hour, $min, $sec, $ampm) =
    ($t->wdayname, $t->monname, $t->year, $t->mon, $t->day_of_month,
     $t->hour, $t->min, $t->sec, '');

  if ($print_timestamps_with_am_pm) {
    $ampm = ($hour >= 12) ? 'pm' : 'am';
    $hour = ($hour % 12) + 1; 
  }

  #   split(/\s+/oax, strftime('%a %b %Y %m %d %l %M %S %P', @timespec));

  my $frac_millisecs = ($nanoseconds % BILLION) / MILLION;

  my $is_today = 
    (($year == $current_local_time->year) && 
     ($month == $current_local_time->mon) &&
     ($day == $current_local_time->day_of_month));

  my $datestr = 
    ($is_today && $print_today_for_mtime_in_past_24_hours) ? $color.'   Today'.$darkcolor.' @' :
    ($year == $current_local_time->year) ? $color.$weekday.' '.$color.$monthname.$darkcolor.' '.$color.sprintf('%2d', $day) :
    $color.$year.$darkcolor.'-'.$color.sprintf('%02d', $month).$darkcolor.'-'.$color.sprintf('%02d', $day);

  my $timestr = 
    $color.sprintf('%02d', $hour).$darkcolor.':'.
    $color.sprintf('%02d', $min).$darkcolor.':'.
    $color.sprintf('%02d', $sec).$darkcolor.$ampm.'.'.
    $color.sprintf('%03d', $frac_millisecs).$darkcolor;

  my $deltastr = 
    $color.padstring('-'.($sec_in_past / $seconds_divisor), -4).' '.$color.$abbrev;

  return $datestr.' '.$timestr.' '.$deltastr;
}

sub init_file_type_to_sorting_rank($) {
  my ($r) = @_;

  # Mounted filesystem root directories always appear first,
  # with higher priority given to "real" filesystems (vs pseudo
  # filesystems populated by the kernel or other subsystems):
  $r->[FILE_TYPE_MOUNT_POINT]     = 1;
  $r->[FILE_TYPE_BLOCK_DEV_MOUNT] = 1;
  $r->[FILE_TYPE_NETWORK_MOUNT]   = 2;
  $r->[FILE_TYPE_VOLATILE_MOUNT]  = 3;
  $r->[FILE_TYPE_SPECIAL_MOUNT]   = 4;
  $r->[FILE_TYPE_FUSE_MOUNT]      = 5;
  $r->[FILE_TYPE_BIND_MOUNT]      = 6;
  $r->[FILE_TYPE_ANONYMOUS_MOUNT] = 7;

  # Then list any subvolumes (or snapshots of subvolumes):
  $r->[FILE_TYPE_SUBVOLUME]       = 10;
  $r->[FILE_TYPE_SNAPSHOT]        = 11;

  # Now list ordinary directories, followed by any special inode types:
  $r->[FILE_TYPE_DIR]             = 20;
  $r->[FILE_TYPE_BLOCK_DEV]       = 21;
  $r->[FILE_TYPE_CHAR_DEV]        = 22;
  $r->[FILE_TYPE_SOCKET]          = 23;
  $r->[FILE_TYPE_SPECIAL]         = 24;
  $r->[FILE_TYPE_PIPE]            = 25;

  # Finally, freely intermingle files and symlinks,
  # sorting both by their filenames only:
  $r->[FILE_TYPE_FILE]            = 30;
  $r->[FILE_TYPE_SYMLINK]         = 30;

  return $r;
};

my @file_type_to_sorting_rank;

INIT {
  init_file_type_to_sorting_rank(\@file_type_to_sorting_rank);
};

my $directory_shaded_color = scale_rgb_fg($directory_color, $shaded_color_coeff);
my $executable_filename_shaded_color = scale_rgb_fg($executable_filename_color, $shaded_color_coeff);
my $script_filename_shaded_color = scale_rgb_fg($executable_filename_color, $shaded_color_coeff);

my $symlink_color = fg_color_rgb(255, 128, 192);
my $symlink_target_color = fg_color_rgb(192, 160, 255);
my $symlink_missing_target_color = fg_color_rgb(255, 192, 128);
my $symlink_shaded_color = scale_rgb_fg($symlink_color, $shaded_color_coeff);

my $symlink_target_sep_color = scale_rgb_fg($symlink_target_color, $shaded_color_coeff);
my $symlink_symbol = ' '.fg_color_rgb(0, 255, 128).dashed_horiz_bar_2_dashes.arrow_barbed.' ';

my $directory_separator_symbol = $directory_shaded_color.large_right_slash;

my $mount_info_fs_color = fg_color_rgb(192, 96, 255);
my $mount_info_dev_color = fg_color_rgb(255, 165, 63);

# This is filled in during the filename collection stage:
my $unique_dir_count;

sub query_interpreter($) {
  my ($filename) = @_;

  my $fd = sys_open($filename, O_RDONLY);
  if (!defined $fd) { return undef; }

  my $header = \0 x 1024;
  my $rc = sys_read($fd, $header, length($header));
  if ((!defined $rc) || ($rc < 0)) { sys_close($fd); return undef; } 

  sys_close($fd);

  my $interp = 
    # ($header =~ /\A \x7F ELF/oax) ? 'exe' :
    ($header =~ /\A \#\! \s*+ (\S++)/oax) ? $1 : undef;

  return $interp;
}

sub format_directory_path($;$$) {
  my ($path, $color, $sep_color) = @_;
  $color //= $directory_color;
  $sep_color //= scale_rgb_fg($color, $shaded_color_coeff);
  my $replacement = $sep_color.large_right_slash.$color;
  return $color.(normalize_trailing_slash($path) =~ s{/}{$replacement}roamsxg);
}

sub format_filename($$$) {
  my ($path, $stats, $dirfd) = @_;
  my ($dirname, $basename, $suffixes) = split_path_version_aware($path);
  my $filename = filename_of($path);

  my ($type, $perms, $size, $symlink) = @{$stats}[STAT_TYPE, STAT_MODE, STAT_SIZE, STAT_SYMLINK];
  my $is_dot_or_dot_dot = ($filename =~ /\A\..?\Z/oax) ? 1 : 0;
  my $type_color = get_file_type_color($type);

  my $xattrs = $stats->[STAT_XATTRS];
  my $capabilities_xattr = $stats->[STAT_CAPABILITIES];

  my $is_setuid = ($perms & PERM_SETUID) ? 1 : 0;
  my $is_setgid = ($perms & PERM_SETGID) ? 1 : 0;
  my $is_sticky = ($perms & PERM_STICKY) ? 1 : 0;
  my $is_privileged = $is_setuid || $is_setgid || (defined $capabilities_xattr);
  my $is_executable = ($perms & PERM_X_ANY_UGO) ? 1 : 0;
  my $is_backup = ($filename =~ /(?: ^ \.? \#) | (?: \~ $)/oax);
  my $is_open = (defined $stats->[STAT_OPENFD]) ? 1 : 0;

  my $color = $filename_color;
  my $prepend = '';
  my $append = '';
  my $suffix_color = undef;
  if ($type == FILE_TYPE_FILE) {
    my $interp = ($is_executable) ? query_interpreter($stats->[STAT_PATH]) : undef;
    $color = ($is_executable 
       ? ($is_privileged ? $privileged_executable_filename_color : 
          (defined $interp) ? $script_filename_color :
          $executable_filename_color)
       : (($filename =~ /^\./) ? $dot_filename_color : $type_color));
    $suffix_color = $filename_suffix_color;
    if (defined $interp) {
      $interp = filename_of($interp);
      my $c = ($interp =~ /perl/) ? M : ($interp =~ /sh/) ? Y : R;
      my $cs = scale_rgb_fg($c, RATIO_2_3);
      $append .= $cs.' (#! '.$c.$interp.$cs.')'; 
    }
  } elsif ($type == FILE_TYPE_SYMLINK) {
    $color = $symlink_color;
    my $printed_symlink;

    if (defined $symlink) {
      my $target_filename = last_path_component_of($symlink);
      my $target_abs_path = resolve_path($symlink, $dirfd, 0);
      my $target_exists = (defined $target_abs_path) ? 1 : 0;
      my $target_dir = ($target_exists) ? strip_last_path_component($target_abs_path) : undef;
      my $same_dir = ($target_exists && ($target_dir eq (path_of_open_fd($dirfd) // '')));
      my $same_filename = ($target_filename eq $filename) ? 1 : 0;

      $printed_symlink = ($target_exists)
        ? (($same_dir) 
            ? $symlink_target_sep_color.dot.large_right_slash 
            : format_directory_path($target_dir, $symlink_target_color, $symlink_target_sep_color)).
          ($same_filename ? $color.elipsis_three_dots : $symlink_target_color.$target_filename)
        : $symlink_missing_target_color.$symlink;
    } else {
      $printed_symlink = fg_color_rgb(255, 96, 0).' '.x_symbol.' cannot read symlink ';
    }

    $append = $symlink_symbol.$printed_symlink;
  } elsif ($type == FILE_TYPE_DIR || $type >= FILE_TYPE_MOUNT_POINT) {
    $dirname = strip_trailing_slash($dirname);
    $color = $U.$type_color;
    $prepend = $directory_shaded_color;
    $append = $UX; #.$directory_separator_symbol;

    if (($type >= FILE_TYPE_MOUNT_POINT) && ($type < FILE_TYPE_SUBVOLUME)) {
      my $mountinfo = query_mount_point($stats->[STAT_PATH]);
      if (defined $mountinfo) { 
        $append .= darkK.' ['.$mount_info_fs_color.$mountinfo->[MOUNTINFO_TYPE].
          darkK.' @ '.$mount_info_dev_color.$mountinfo->[MOUNTINFO_SOURCE].darkK.']';
      }
    }
  }

  if ($is_open) {
    $prepend = U.$prepend;
    $append = $append.UX;
  }

  if ($is_backup) { 
    $color = $backup_filename_color;
    $suffix_color = undef;
  }

  $suffix_color //= $color;

  my $dir_color = ($is_dot_or_dot_dot) ? $type_color :
    (($unique_dir_count > 1) ? $directory_shaded_color : $type_color);

  # Only show the full directory path if the filename is '.', '..' or we're listing multiple directories:

  $filename = 
    ($filename eq '.') ? dot : 
    ($filename eq '..') ? dot.dot : 
    $filename;

  $dirname = 
    ($is_dot_or_dot_dot) ? ($dir_color.$filename.$directory_shaded_color.' = '.format_directory_path($stats->[STAT_PATH], $dir_color)) :
      ($unique_dir_count > 1) ? format_directory_path($dirname, $directory_shaded_color, $directory_shaded_color) : '';

  if ($is_dot_or_dot_dot) {
    $basename = ''; 
    $suffixes = '';
  }

  if (defined $suffix_color) 
    { $suffixes =~ s{\.}{${filename_dots_color}.${suffix_color}}oaxg; }

  my $out = $prepend.$dirname.$color.$basename.$suffix_color.$suffixes.$append;

  return $out;
}

sub format_dev_node($) {
  my ($stats) = @_;

  my ($major, $minor) = split_major_minor_dev($stats->[STAT_BLOCK_CHAR_DEV_SPEC]);
  my $type = $stats->[STAT_TYPE];

  my $color = 
    ($type == FILE_TYPE_BLOCK_DEV) ? R :
    ($type == FILE_TYPE_CHAR_DEV) ? ORANGE : W;

  my $dark_color = 
    ($type == FILE_TYPE_BLOCK_DEV) ? R_1_3 :
    ($type == FILE_TYPE_CHAR_DEV) ? ORANGE_1_3 : W;

  return
    $dark_color. #.double_left_angle_bracket.$color.
    (($type == FILE_TYPE_BLOCK_DEV) ? 'block' : 
     ($type == FILE_TYPE_CHAR_DEV) ? 'char' : '???').
     ' '.$color.$major.$dark_color.dot_small.$color.$minor;
  # .$dark_color.double_right_angle_bracket;
}

my $show_open_files = 0;

sub format_openfds($+) {
  my ($filename, $stats) = @_;
  
  my $open_as_fd_in_contexts = $stats->[STAT_OPENFD];
  if (!defined $open_as_fd_in_contexts) { return ('', ''); }

  my @open_as_types = ( );
  
  foreach my $ctx (@$open_as_fd_in_contexts) {
    my ($ctxtype, $pid) = @$ctx;
    $open_as_types[$ctxtype]++;
  }

  my $longdesc = '';
  my $shortdesc = '';

  my $n = scalar @open_as_types;
  for (my $i = 0; $i < $n; $i++) {
    next if (!$open_as_types[$i]);
    $longdesc .= ', ' if (length $longdesc);
    $longdesc .= $open_type_to_long_description[$i];
    $shortdesc .= uc($open_type_to_single_letter_description[$i]);
  }

  return ('', '') if (!length $shortdesc);

  return (K.' [open as '.R.$longdesc.K.']'.X, 
          R.dot_in_circle.$shortdesc);
}

my $show_inodes = 0;

my $devid_color = fg_color_rgb(140, 132, 180); #fg_color_rgb(120, 64, 114);
my $devid_shaded_color = scale_rgb_fg($devid_color, 0.667);

my $inode_color = fg_color_rgb(180, 96, 170);
my $inode_shaded_color = scale_rgb_fg($inode_color, 0.667);

sub format_inode_and_devid(+) {
  my ($stats) = @_;
  if (!($show_inodes)) { return ''; }

  my $inode = $stats->[STAT_INODE];
  my $devid = $stats->[STAT_DEV];

  return (
    $devid_shaded_color.double_disc.' '.$devid_color.$devid,
    $inode_shaded_color.sharp_sign.$inode_color.$inode
  );
}

my $extents_color = fg_color_rgb(255, 64, 96);
my $extents_shaded_color = scale_rgb_fg($extents_color, $shaded_color_coeff);

sub format_extents(+) {
  my ($stats) = @_;

  my $extents = $stats->[STAT_EXTENTS];
  my $file_size = $stats->[STAT_SIZE];

  my $type = $stats->[STAT_TYPE];

  if (($type == FILE_TYPE_DIR) || ($type >= FILE_TYPE_MOUNT_POINT)) {
    # directories and symlinks don't provide reliable info here, 
    # so use this column to show the number of files in directories
    my $dir = read_directory($stats->[STAT_PATH]);
    return ((defined $dir) ? $extents_color.scalar(@$dir).' '.$extents_shaded_color.'in dir'.X : '');
  } elsif ($type == FILE_TYPE_FILE) {
    my ($total_extents, $total_bytes, $shared_bytes, $inlined_bytes, $tail_bytes, $unwritten_bytes) = 
      @{$extents}{total_extents, total_bytes, shared_bytes, inlined_bytes, tail_bytes, unwritten_bytes};
    
    undefs_to_inplace(0, $total_extents, $total_bytes, $shared_bytes, $inlined_bytes, $tail_bytes, $unwritten_bytes);

    my $unwritten_percent = ratio_to_percent($unwritten_bytes, $file_size);
    my $shared_percent = ratio_to_percent($shared_bytes, $file_size);
    my $inlined_or_tail = ($inlined_bytes > 0) || ($tail_bytes > 0);
    
    my $out = '';
    
    $out .= ($total_extents > 1) ? $extents_color.padstring($total_extents, -4).$extents_shaded_color.division_symbol.' ' : (' ' x 6);
    
    if ($inlined_or_tail) {
      $out .= $extents_color.(($inlined_bytes > 0) ? 'inline' : (' ' x 6)).(($tail_bytes > 0) ? 'tail  ' : (' ' x 6));
    } else {
      $out .= ($unwritten_bytes > 0) ? $extents_color.padstring($unwritten_percent, -3).$extents_shaded_color.' %U' : (' ' x 6);
      $out .= ($shared_percent > 0) ? $extents_color.padstring($shared_percent, -3).$extents_shaded_color.' %C' : (' ' x 6);
    }

    return $out;
  } else { # something other than a file or directory
    return '';
  }
}

my @field_to_search_regexp = ( );

#my $integer_field_pattern_re = qr{([!~=]?)([<>]=?)(\d+)}oax;
#
#sub match_integer_field($$$) {
#  my ($fieldid, $value, $pattern) = @_;
#
#  my ($is_not, $gt_lt_ge_le, $num) = ($pattern =~ /$integer_field_pattern_re/oax);
#  if (!defined $num) { warn('Pattern'); }
#}

sub set_field_search_pattern {
  my ($value, $field, $arg, $argindex, $fieldid, $is_not) = @_;

  # while (my ($k, $v) = each %search_fields_for_patterns_option) { ... }
  # prints("value $value, field $field, arg $arg, argindex $argindex, fieldid ".($fieldid // '?').", is_not ".($is_not // '?').NL);

  my $re = qr{$value}oa;
  # prints("Set field $fieldid to $re\n");
  $field_to_search_regexp[$fieldid] = qr{$value}oa;
}

#
# GNU ls uses the following single letter options:
#
# aAbBcCdD  fFgGhHiI  k lLm nNo p qQrRsStTuUv w xX   Z1
#
# but GNU ls does *not* use these remaining single letter options,
# so we are free to use them for our own enhanced features:
#
# We use the following letters which are not already used by ls:
#         eE        jJ K   M   O P           V W  yYz
#         ^            ^       ^ ^
#
# We reuse these for a different purpose than ls:
#       D   F
#       ^   ^
#

my %command_line_options = (
  'long' => [ \$long_format, OPTION_SINGLE_CHAR_COMBINABLE, 'l' ],
  'show-all' => [ \$show_all, OPTION_SINGLE_CHAR_COMBINABLE, 'a' ],
  'sort' => [ \$sort_field, OPTION_VALUE_REQUIRED, [ ], \%stat_field_name_to_index_map, \%stat_field_index_to_name_map ],
  'sort-by-size' => [ \$sort_field, OPTION_ASSIGN_BOOL | OPTION_SINGLE_CHAR_COMBINABLE, [ 'S' ], STAT_SIZE ],
  'sort-by-time' => [ \$sort_field, OPTION_ASSIGN_BOOL | OPTION_SINGLE_CHAR_COMBINABLE, [ 't' ], STAT_MTIME_NS ],
  'reverse' => [ \$sort_reverse, OPTION_SINGLE_CHAR_COMBINABLE, [qw(r ascending)] ],
  'human-readable' => [ \$human_readable_sizes, OPTION_ASSIGN_BOOL | OPTION_SINGLE_CHAR_COMBINABLE, [ 'h' ] ],
  'digits' => [ \$max_file_size_decimal_digits, OPTION_VALUE_REQUIRED, [qw(size-digits file-size-digits)] ],
  'comma' => [ \$comma_separated_digits, OPTION_ASSIGN_BOOL, [ 'comma-sep-sizes' ] ],
  'dir-itself' => [ \$show_directory_itself, OPTION_SINGLE_CHAR_COMBINABLE, [qw(d directory-itself)] ],
  'follow-cmdline' => [ \$follow_symlinks_on_command_line, OPTION_SINGLE_CHAR_COMBINABLE, [qw(H follow-args)] ],
  'follow' => [ \$stat_symlink_target, OPTION_SINGLE_CHAR_COMBINABLE, [qw(L follow-symlinks follow-links symlink-target)] ],
  'only-dirs' => [ \$only_show_directories, OPTION_SINGLE_CHAR_COMBINABLE, [qw(D only-show-dirs only-directories)] ],
  'only-files' => [ \$only_show_files, OPTION_SINGLE_CHAR_COMBINABLE, [qw(F only-show-files)] ],
  'only-links' => [ \$only_show_symlinks, OPTION_SINGLE_CHAR_COMBINABLE, [qw(K only-symlinks only-show-links only-symlinks only-show-symlinks)] ],
  'inodes' => [ \$show_inodes, OPTION_SINGLE_CHAR_COMBINABLE, [qw(i inode ino)] ],
  'acls' => [ \$show_acls, OPTION_SINGLE_CHAR_COMBINABLE, [qw(P acl)] ], 
  'xattrs' => [ \$show_xattrs, OPTION_SINGLE_CHAR_COMBINABLE, [qw(e xattr eas extattrs)] ],
  'extents' => [ \$show_extents, OPTION_SINGLE_CHAR_COMBINABLE, [qw(j cloned cloned-extents copy-on-write cow btrfs sparse)] ],
  'opened' => [ \$show_open_files, OPTION_SINGLE_CHAR_COMBINABLE, [qw(O open-files openfd openfds open lsof fuser)] ],
  'column-headers' => [ \$print_column_headers, OPTION_TOGGLE_BOOL, [qw(colhdrs column-headers)] ],
  'combine-uid-gid' => [ \$combine_common_uid_gid, OPTION_TOGGLE_BOOL, [ 'comxid' ] ],
  'dir-and-parent' => [ \$show_dot_and_dot_dot, OPTION_TOGGLE_BOOL, [qw(. show-.-and-.. .-.. .-and-.. dot-and-dot-dot)] ],
# 'search' => [ \&set_field_search_pattern, OPTION_VALUE_REQUIRED|OPTION_COMMA_SEP_LISTS|OPTION_APPEND_REPEATS, [qw(grep find)] ],
  'and' => [ \&match_all_patterns, 0, [ '&' ] ],
  'or' => [ \&match_any_patterns, 0, [ '|' ] ],
  'shaded-color-coeff' => [ \$shaded_color_coeff, OPTION_VALUE_REQUIRED, [qw(shading shade dark darkness contrast)] ],
);

my @command_line_options_help = (
  [ OPTION_HELP_LITERAL ] => print_banner('lls', 'Enhanced File Listings'),

  [ OPTION_HELP_SYNTAX ] => undef,

  [ OPTION_HELP_CATEGORY, fg_color_rgb(255, 128, 64) ], fg_color_rgb(255, 128, 64).'Selection and filtering of items to be listed',

  'show-all' => 'Show all files, including dot files (.<filename>), hidden files, etc.',
  'only-files' => 'Show only files (without directories, symlinks or other item types)',
  'only-dirs' => 'Show only directories, subvolumes and mount points',
  'only-links' => 'Show only symbolic links',
  'dir-itself' => 'For each directory on the command line, show the fields about the directory itself (i.e. one line per directory), rather than listing all files within each directory',
  'dir-and-parent' => 'Show the '.format_quoted(".").' and '.format_quoted("..").' hard links for each directory, indicating the absolute path of the containing parent directory and the directory itself',

  [ OPTION_HELP_CATEGORY, SKYBLUE_1_2 ] => SKYBLUE.'Sorting',

  'sort' => 'Sort by the specified field name(s), first by the first field, then for files with the same value in that field, sort by the second field, and so on',
  'sort-by-size' => 'Sort by size (equivalent to '.G.'-sort size'.X.')',
  'sort-by-time' => 'Sort by modification timestamp (equivalent to '.G.'-sort mtime'.X.')',
  'reverse' => 'Reverse sort order, making it ascending rather than descending',

  [ OPTION_HELP_CATEGORY, C_1_2 ] => C.'Extended details to optionally query and display',

  'long' => 'Long listing format (always enabled; only for compatibility with GNU ls)',
  'inodes' => 'Show inode numbers and the mounted device IDs on which they reside',
  'acls' => 'Show the symbol '.format_quoted($acl_or_caps_symbol).' for items with ACLs and/or capability attributes, and show permission bits resulting from each access ACL',
  'xattrs' => 'Show the symbol '.format_quoted($xattr_symbol).' for items with extended attributes (not counting ACLs and capabilities)',
  'extents' => 'Show which files are stored across multiple extents, or have holes or copy-on-write extents shared with other files',
  'opened' => 'Indicate files opened by any processes, and how they are used (i.e. via a fd, mmap, root, cwd, etc)',

  [ OPTION_HELP_CATEGORY, Y_2_3 ] => Y.'Formatting and output concerning entire list',

  'column-headers' => 'Show column headers with descriptions of each field in the listing',
  'combine-uid-gid' => 'If all items in a directory are owned by the same user and/or group, print this fact twice (before and after the listing), rather than wasting space by putting it on every line',
  'comma' => 'Insert commas (every three decimal digits) into file sizes and other large integers',
  'digits' => 'Maximum number of decimal digits to show in large file sizes before scaling by next power of 1024',
  'human-readable' => 'Human readable file sizes, abbreviated with Kb/Mb/Gb/Tb/etc units',
  'shaded-color-coeff' => 'Brightness of darker shaded RGB colors relative to corresponding normal colors',

  [ OPTION_HELP_CATEGORY, M_2_3 ] => M.'Symbolic links',

  'follow-cmdline' => 'Follow symlinks specified on the command line (explicitly or via wildcards) and show the field values for the target of each such symlink',
  'follow' => 'Follow all symlinks (whether found in a directory or specified on the command line) and show the field values for their ultimate resolved target paths',

  [ OPTION_HELP_CATEGORY, R_2_3 ] => R.'Filtering matching values within specific fields',

  (map { 'in-'.$_ => 'Show items where the '.M.$_.X.' field\'s value matches the specified value (numerical or string, depending on the field)' } sort keys %stat_field_name_to_index_map),
  (map { 'not-'.$_ => 'Show items where the '.M.$_.X.' field\'s value matches the specified value (numerical or string, depending on the field)' } sort keys %stat_field_name_to_index_map),
  'and' => 'Boolean intersection (AND) of the options (e.g. '.M.'-in-'.elipsis_three_dots.X.' ++before and after this option',
  'or' => 'Boolean union (OR) of the options (e.g. '.M.'-in-'.elipsis_three_dots.X.' ++before and after this option',
  # 'not' => 'Boolean inverse (NOT) of associated option (e.g. '.M.'-in-'.elipsis_three_dots.X.' ++before and after this option',
  # 'xor' => 'Boolean intersection (AND) of the options (e.g. '.M.'-in-'.elipsis_three_dots.X.' ++before and after this option',
);

while (my ($field, $index) = each %stat_field_name_to_index_map) {
  $command_line_options{'in-'.$field} = [ \&set_field_search_pattern, OPTION_VALUE_REQUIRED, [ $field.'?' ], [ $index, 0 ] ];
  $command_line_options{'not-'.$field} = [ \&set_field_search_pattern, OPTION_VALUE_REQUIRED, [ 'not-'.$field.'?' ], [ $index, 1 ] ];
}

use constant {
  heavy_intersection_4_way => chr(0x254b),
  heavy_intersection_vert_right_horiz => chr(0x2523),
  intersection_heavy_vert_single_horiz => chr(0x2520),
  intersection_double_vert_double_horiz => chr(0x256c),
  intersection_double_vert_single_horiz => chr(0x255f),
  fancy_italic_d => chr(0x2145),
  wide_d => chr(0x216e),
};

my $dir_vert_sep_chars =
  heavy_intersection_vert_right_horiz.dice_5_dots.' ';

# Other possibly visually appealing alternatives:
# chr(0x2145).chr(0x216e).' '; #chr(0x2714) :#chr(0x2162).' ' :
# three_vert_bars.' '; #chr(0x2714) :#chr(0x2162).' '
# chr(0x27f4).' '; #chr(0x2714) :#chr(0x2162).' '
# chr(0x2425).' '; #chr(0x2714) :#chr(0x2162).' '
# chr(0x26aa).' '; #chr(0x2714) :#chr(0x2162).' '
# box_with_shadow.' '; #chr(0x2714) :#chr(0x2162).' '
# arrow_barbed.' '; #chr(0x2714) :#chr(0x2162).' ' : chr(0x27f4) # double_colon
# circle_with_shadow.' '; #chr(0x2714) :#chr(0x2162).' ' : chr(0x27f4) # double_colon

my $symlink_vert_sep_chars = 
  #$symlink_color.dashed_vert_bar_3_dashes.lightning_spark.' ';
  intersection_double_vert_single_horiz.arrow_barbed.' ';

my $executable_vert_sep_chars = 
  intersection_double_vert_double_horiz.x_signed_light.' '; # double_horiz_bars.' ' : # .x_multiplier 
  
my $default_vert_sep_chars =
  long_narrow_double_vert_bars.'  ';

#
# For some fields, the POSIX standard 'ls' implementation uses 
# descending sort order (high to low) by default, and only
# reverses the order (back to ascending order) if a 
# corresponding option is specified. For all other fields,
# their corresponding order reversal option changes from
# ascending to descending instead.
#       
my @descending_default_field_sort_order = single_value_sparse_array 1, (
  STAT_SIZE,
  STAT_BLOCK_COUNT,
  STAT_NLINK,
  STAT_ATIME,
  STAT_MTIME,
  STAT_CTIME,
  STAT_ATIME_NS,
  STAT_MTIME_NS,
  STAT_CTIME_NS
);

my $allstats = { };
my $negate_sort_comparison = 0;
  
sub file_type_sort_comparator {
  my $at = $allstats->{$a}->[STAT_TYPE];
  my $bt = $allstats->{$b}->[STAT_TYPE];

  my $result = ($at != $bt) ? ($file_type_to_sorting_rank[$at] <=> $file_type_to_sorting_rank[$bt]) : 0;
  if ($result == 0) { $result = ($allstats->{$a}->[STAT_NAME] cmp $allstats->{$b}->[STAT_NAME]); }

  return (($negate_sort_comparison) ? -$result : $result);
}

sub string_sort_comparator {
  my $as = $allstats->{$a};
  my $bs = $allstats->{$b};

  my $result = ($as->[$sort_field] cmp $bs->[$sort_field]);

  return (($negate_sort_comparison) ? -$result : $result);
}

sub numeric_sort_comparator {
  my $as = $allstats->{$a};
  my $bs = $allstats->{$b};

  my $result = 
    ($as->[$sort_field] <=> $bs->[$sort_field]);

  return (($negate_sort_comparison) ? -$result : $result);
}

my $homedir = get_home_directory();
my $cwd = getcwd();

my @config_file_alternatives = (
  '/etc/lls.conf',
  $homedir.'/.lls', 
);

sub main(@) {
  my $groupsref;
  ($euid, $egid, $groupsref) = get_current_uid_gid_groups();
  @groups = @{$groupsref};

  my @config_file_args = read_options_from_config_file(@config_file_alternatives);
  my @args = (@config_file_args, @_);

  #
  # Check LS_OPTIONS environment variable and add any supported options
  # to the start of the effective command line, although actual command
  # line options may override any options set in LS_OPTIONS:
  #
  
  my ($pathargs, $invalid_option_indexes) = 
    parse_and_check_command_line(%command_line_options, @args, @command_line_options_help);

  # If no arguments were specified, use the current directory
  if (!@$pathargs) { $pathargs = [ '.' ]; }

  #
  # First expand all wildcards (if the shell hasn't already done this)
  #

  #
  # Group the list of requested path arguments according to their directory
  # names, using a hash that maps unique directory names to the list of
  # matching filenames in each such directory:
  # 

  my %dir_to_filename_list = ( );
  my %dir_to_dir_path_fd = ( );
  
  # *+MTY TODO: use readdirplus (IO::Dirent) perl mod to get file types
  # note that $filename may actually be a directory if it is the final
  # component in the specified path:
  # use IO::Dirent;

  foreach my $path (@$pathargs) {
    my ($orig_dirname, $filename) = split_dir_and_filename($path);

    my $dirname = resolve_path($orig_dirname);

    if (!defined $dirname) {
      simple_warning('Directory '.format_quoted($orig_dirname). ' does not exist');
      next;
    }

    my $dirfd = $dir_to_dir_path_fd{$dirname};

    if (!exists $dir_to_dir_path_fd{$dirname}) {
      $dirfd = sys_open_path($dirname);

      if (!defined $dirfd) {
        simple_warning('Cannot access directory '.format_quoted($dirname));
        next;
      }

      $dir_to_dir_path_fd{$dirname} = $dirfd;
    }

    #
    # The returned stats will be automatically cached
    # so we won't need to re-read them redundantly
    # in the common case where the shell does glob
    # expansion of wildcards before we even see the
    # original command line prior to expansion, and
    # instead only get a lengthy list of filenames:
    #
    my $stats = get_file_stats($filename, $dirfd, $follow_symlinks_on_command_line);

    if (!defined $stats) {
      simple_warning('Cannot access '.format_quoted($path));
      next;
    }

    if ($follow_symlinks_to_dirs_on_command_line && 
      ($stats->[STAT_TYPE] == FILE_TYPE_SYMLINK)) {
      my $target_stats = get_file_stats(sys_readlink($path));
      if ((defined $target_stats) && ($target_stats->[STAT_TYPE] == FILE_TYPE_DIR)) {
        $stats = $target_stats;
        $path = $stats->[STAT_PATH];
      }
    }

    if (is_directory_from_stats($stats)) {
      $orig_dirname = $path;
      $filename = undef;
      my $dirname = resolve_path($orig_dirname);

      if (!defined $dirname) {
        simple_warning('Directory '.format_quoted($orig_dirname). ' does not exist');
        next;
      }

      $dirfd = $dir_to_dir_path_fd{$dirname};

      if (!exists $dir_to_dir_path_fd{$dirname}) {
        $dirfd = sys_open_path($dirname);

        if (!defined $dirfd) {
          simple_warning('Cannot access directory '.format_quoted($dirname));
          next;
        }

        $dir_to_dir_path_fd{$dirname} = $dirfd;
      }

      $dir_to_filename_list{$dirname} //= read_directory($path);
    } else {
      push @{$dir_to_filename_list{$dirname}}, $filename;
    }
  }

  $unique_dir_count = sizeof(%dir_to_filename_list);

  my $open_files = ($show_open_files) ? find_all_open_files_fast_skip_details() : undef;

  my $stats_to_query = 
    STATS_QUERY_DEFAULT|STATS_QUERY_ACCESSIBLE;

  $stats_to_query |= STATS_QUERY_OPENFD if ($show_open_files);
  $stats_to_query |= STATS_QUERY_XATTRS if ($show_xattrs);
  $stats_to_query |= STATS_QUERY_ACLS if ($show_acls);
  $stats_to_query |= STATS_QUERY_EXTENTS if ($show_extents);

  $stats_to_query |= STATS_FOLLOW_SYMLINKS if ($stat_symlink_target);

  foreach my $dirname (sort keys %dir_to_filename_list) {
    my $filenames = $dir_to_filename_list{$dirname};
    my $dirfd = $dir_to_dir_path_fd{$dirname};
    my $prefix = ($unique_dir_count > 1) ? normalize_trailing_slash($dirname) : '';
    stat_files_in_directory($dirname, $filenames, $stats_to_query, 
                            $dirfd, undef, $open_files,
                            $allstats, $prefix);
  }

  my $sort_comparator = 
    ($sort_field == STAT_TYPE) ? \&file_type_sort_comparator :
    (($sort_field == STAT_NAME) || ($sort_field == STAT_PATH) || ($sort_field == STAT_SYMLINK)) ? \&string_sort_comparator :
    \&numeric_sort_comparator;

  $negate_sort_comparison = ($descending_default_field_sort_order[$sort_field] // 0) ^ $sort_reverse;

  my @ordered_filenames = sort $sort_comparator keys %{$allstats};

  #
  # Phase 2: Scan the list of filenames and their stats to determine:
  # whether all files repeat the same value in certain stat fields,
  # in which case the redundant fields are by default omitted from
  # the listing to save space and reduce visual clutter. 
  #
  # This affects the following fields by default (unless corresponding
  # command line options are specified to override this default):
  #
  #   owner, group, perms, links, date.year, time, time_since_changed, actual_type
  #

  my $common_uid = undef;
  my $common_gid = undef;

  my $all_file_uids_match_common_uid = 1;
  my $all_file_gids_match_common_gid = 1;

  my $real_filename_count = 0;

  foreach my $path (@ordered_filenames) {
    my $filename = filename_of($path);
    $real_filename_count += ((($filename ne '.') && ($filename ne '..')) ? 1 : 0);
  }

  if (!$real_filename_count) { $show_dot_and_dot_dot = 1; }

  if (($real_filename_count <= 1) || (!$combine_common_uid_gid)) {
    # If we only have one file to list (excluding . and ..), just print its uid/gid like ls:
    $all_file_uids_match_common_uid = 0;
    $all_file_gids_match_common_gid = 0;
  }


  my $every_file_has_only_one_hard_link = 1;
  my $newest_file_timestamp_in_listing = 0;
  my $has_open_files = 0;

  #
  # Omit the owner and/or group name if and only if every file
  # in the directory is owned by the current user (and there is
  # more than a single file).Also find  # the lengths of the longest user and group names, and if
  # every file has a single hard link to itself.
  #

  my @allowed_file_types;
  if ($only_show_files || $only_show_directories || $only_show_symlinks) {
    @allowed_file_types = (0) x FILE_TYPE_COUNT;
    if ($only_show_files) { $allowed_file_types[FILE_TYPE_FILE] = 1; }
    if ($only_show_directories) { $allowed_file_types[FILE_TYPE_DIR] = 1; }
    if ($only_show_symlinks) { $allowed_file_types[FILE_TYPE_SYMLINK] = 1; }
  } else {
    @allowed_file_types = (1) x FILE_TYPE_COUNT;
  }

  foreach my $filename (@ordered_filenames) {
    next if (!defined $filename);

    my $stats = $allstats->{$filename};

    my ($type, $perms, $fileuid, $filegid, $size, $links, $timestamp, $devid, $inode) = 
      @{$stats}[STAT_TYPE, STAT_MODE, STAT_UID, STAT_GID, STAT_SIZE, STAT_NLINK, STAT_MTIME_NS, STAT_DEV, STAT_INODE];        

    # The '.' and/or '..' hard links may actually refer to mount points 
    # or subvolumes rather than just being simple directories, so don't
    # skip them if they are in fact these special directory types.
    my $skip = 
      (((($filename eq '.' || $filename eq '..') && ($type == FILE_TYPE_DIR)) && (!$show_directory_itself) && (!$show_dot_and_dot_dot)) ||
      ($show_directory_itself && ($filename ne '.')) ||
      (!$allowed_file_types[$type])) ? 1 : 0;

    if ($skip) { $filename = undef; next; }

    if (!defined $common_uid) { $common_uid = $fileuid; }
    if (!defined $common_gid) { $common_gid = $filegid; }
    $all_file_uids_match_common_uid &= ($fileuid == $common_uid);
    $all_file_gids_match_common_gid &= ($filegid == $common_gid);
    set_max($newest_file_timestamp_in_listing, $timestamp) if (!$skip);
    if (defined $stats->[STAT_OPENFD]) { $has_open_files = 1 };

    #
    # Don't consider directories here since they always have at least 2 links
    # (for . and ..) on most filesystems, except for e.g. btrfs (which handles
    # the concepts of hard links and inodes radically differently), AFS, and
    # some of the synthetic filesystems like tmpfs, /proc, /sys, etc.
    #
    if (($type != FILE_TYPE_DIR) && ($type < FILE_TYPE_MOUNT_POINT)) { $every_file_has_only_one_hard_link &= ($links == 1); }
  }

  my $common_messages = '';
  my $common_message_lines = 0;

  if (!$real_filename_count) {
    $common_messages = ORANGE.' '.x_symbol.'  '.Y.'No files found in specified directories '.NL;
    $common_message_lines++;
  }

  if ($all_file_uids_match_common_uid || $all_file_gids_match_common_gid) {
    $common_messages .= $C.' '.star.'  '.$B.'All '.$C.sizeof(@ordered_filenames).$B.' items are owned by ';
    if ($all_file_uids_match_common_uid) {
      $common_messages .= 'user '.$G.
        (lookup_user_name_from_uid($common_uid) // $R.'<unknown>').$B.
          ' (uid '.$M.$common_uid.$B.')';
    }
    if ($all_file_uids_match_common_uid && $all_file_gids_match_common_gid) { $common_messages .= ' and '; }
    if ($all_file_gids_match_common_gid) {
      $common_messages .= 'group '.$G.
        (lookup_group_name_from_gid($common_gid) // $R.'<unknown>').$B.
          ' (gid '.$M.$common_gid.$B.')';
    }
    $common_messages .= NL;
    $common_message_lines++;
  }

  if ($only_show_files || $only_show_directories || $only_show_symlinks) {
    my @only_showing = (
      (($only_show_files) ? 'files' : ( )),
      (($only_show_directories) ? 'directories' : ( )),
      (($only_show_symlinks) ? 'symlinks' : ( ))
    );

    $common_messages .= ORANGE.' '.warning_sign.'  '.Y.'Only showing '.
      ORANGE.join(Y.', '.ORANGE, @only_showing).X.NL;
    $common_message_lines++;
  }

  my $is_dot_or_dot_dot_re = qr{(?: \A | /) \. \.? $}oax;

  #
  # Create the column labels header line:
  #
  my $hc = Y_2_3;

  my @column_headers = (
    bg_color_rgb(16, 40, 28).$hc.' '.'T'.'  usr grp oth e/a'
  );

  if (!$every_file_has_only_one_hard_link) { push @column_headers, '#L'; }

  if (!$all_file_uids_match_common_uid) { push @column_headers, 'User'; }

  if (!$all_file_gids_match_common_gid) { push @column_headers, 'Group'; }

  push @column_headers, ('Size', 'Timestamp (mod)',
                         fg_color_rgb(96, 64, 128).long_narrow_vert_bar.' '.
                         $hc.'Filename, symlink target, etc.'.' '.X);

  my $terminal_lines = get_terminal_height_in_lines();
  my $output_line_counter = 0;

  prints($common_messages);
  $output_line_counter += $common_message_lines;
  # if ($print_column_headers) { prints($column_headers); $output_line_counter++; }

  #
  # Phase 3: format and print the final listing of filenames 
  # and their formatted stat fields, along with the values of
  # any redundant fields common to all items (found during Phase 2).
  #

  my @rows = ( );
  
  foreach $filename (@ordered_filenames) {
    next if (!defined $filename);

    my $stats = $allstats->{$filename};
    if (!defined $stats) { prints('  '.$filename.': failed to query stats'.NL); next; }
    
    my $type = $stats->[STAT_TYPE];
    my $perms = $stats->[STAT_MODE];
    my $is_dir = ($type == FILE_TYPE_DIR || $type >= FILE_TYPE_MOUNT_POINT);
    my $is_executable = ($perms & PERM_X_ANY_UGO) ? 1 : 0;
    my $is_accessible = ($stats->[STAT_IS_ACCESSIBLE]) ? 1 : 0;
    my $is_open = (defined $stats->[STAT_OPENFD] && (sizeof($stats->[STAT_OPENFD]) > 0));
    my $dir = strip_last_path_component($stats->[STAT_PATH]);
    my $dirfd = $dir_to_dir_path_fd{$dir};

    my $vert_sep_chars = 
      ($is_accessible ?
       (($is_dir) ? $dir_vert_sep_chars :
       ($type == FILE_TYPE_SYMLINK) ? $symlink_vert_sep_chars : 
       ($is_executable) ? $executable_vert_sep_chars : 
       $default_vert_sep_chars) : dashed_vert_bar_2_dashes);

    my $vert_sep_color = 
      ($is_dir) ? $directory_shaded_color :
      ($type == FILE_TYPE_SYMLINK) ? $symlink_shaded_color :
      ($is_executable) ? $executable_filename_shaded_color :
      $vert_sep_bar_color;

    my ($open_files_long, $open_files_short) = format_openfds($filename, $stats);

    my $bgcolor = ($output_line_counter & 1) 
      ? ((!$is_accessible) ? $inaccessible_light_bgcolor : $is_open ? $open_light_bgcolor : $light_bgcolor)
      : ((!$is_accessible) ? $inaccessible_dark_bgcolor : $is_open ? $open_dark_bgcolor : $dark_bgcolor);

    my $columns = [ map {
      set_rgb_bg_in_string(($is_accessible) ? $_ : 
        blend_and_scale_rgb_fg_in_string($_, [255, 0, 0], 0.7, 0.25), $bgcolor)
    } remove_undefs(
      format_file_type_symbols($stats),

      format_stat_mode_permissions($stats, !$all_file_uids_match_common_uid, 
                                   !$all_file_gids_match_common_gid,
                                   $allstats),

      (!$every_file_has_only_one_hard_link) ? format_link_count($stats) : undef,

      ($show_open_files) ? (($has_open_files) ? $open_files_short : '') : undef,
      
      ((($type == FILE_TYPE_BLOCK_DEV) || ($type == FILE_TYPE_CHAR_DEV))
        ? format_dev_node($stats)
        : format_file_size($stats)).' ',

      ($show_extents) ? format_extents($stats) : undef,
      
      format_file_timestamp($stats, 1, $newest_file_timestamp_in_listing),

      ($show_inodes) ? (format_inode_and_devid($stats)) : (undef, undef),
      
      X.$vert_sep_color.$vert_sep_chars.X,

      format_filename($filename, $stats, $dirfd).$open_files_long.X,
    ) ];

    push @rows, $columns;
    
    $output_line_counter++;
  }

  my $aL = ALIGN_LEFT;
  my $aR = ALIGN_RIGHT;
  
  my $alignments = [ remove_undefs(
    $aL, # file type symbol
    $aL, # permissions
    ($all_file_uids_match_common_uid ? undef : $aL), # user (optional)
    ($all_file_gids_match_common_gid ? undef : $aL), # group (optional)
    ($every_file_has_only_one_hard_link ? undef : $aR), # link count (optional)
    ($show_open_files ? $aL : undef), # open file info (optional)
    $aR, # size (or major/minor for block or char device nodes)
    ($show_extents ? $aR : undef), # extents, shared/cloned, sparse, etc. (optional)
    $aL, # timestamp
    ($show_inodes ? ($aR, $aR) : (undef, undef)), # inode and device (optional)
    $aL, # secondary file type symbol
    $aL, # filename, symlink target, etc.
  ) ];

  my $colseps = [ remove_undefs(
    '', # file type symbol
    '', # permissions
    ($all_file_uids_match_common_uid ? undef : '  '), # user (optional)
    ($all_file_gids_match_common_gid ? undef : '  '), # group (optional)
    ($every_file_has_only_one_hard_link ? undef : ' '), # link count (optional)
    ($show_open_files ? ' ' : undef), # open file info (optional)
    ' ', # size (or major/minor for block or char device nodes)
    ($show_extents ? ' ' : undef), # extents, shared/cloned, sparse, etc. (optional)
    ' ', # timestamp
    ($show_inodes ? (' ', ' ') : (undef, undef)), # inode and device (optional)
    '', # secondary file type symbol
    '', # filename, symlink target, etc.
  ) ];

  if ($debug_layout) {
    my $c1 = fg_color_rgb(255, 128, 0);
    my $c2 = fg_color_rgb(128, 32, 0);
    $colseps = [ (map { $c2.long_heavy_vert_bar.$c1.$_.$c2.alt_bold_right_angle_bracket.X } 
                    ( 0..scalar(@$alignments)*2 )) ]; # (for debugging the layout)

    #use DDP; p @rows;
  }

  my @lines = print_table(STDOUT, @rows, colseps => $colseps, align => $alignments, return_lines => 1);
  printfd(STDOUT, join('', @lines));
  $output_line_counter += scalar @lines;

  if ($output_line_counter >= $terminal_lines) {
    # if ($print_column_headers) { prints($column_headers); }
    prints($common_messages);
    $output_line_counter += $common_message_lines;
  }
}

main(@ARGV);
exit 0;

