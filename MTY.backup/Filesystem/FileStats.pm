#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Filesystem::FileStats
#
# Common functions on files and directories
#
# Copyright 1997 - 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Filesystem::FileStats;

use integer; use warnings; use Exporter qw(import);

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(%file_type_to_description %stat_field_index_to_name_map
     %stat_field_name_to_index_map @file_stat_field_names
     @file_stat_field_types FILE_TYPE_ANONYMOUS_MOUNT FILE_TYPE_BIND_MOUNT
     FILE_TYPE_BLOCK_DEV FILE_TYPE_BLOCK_DEV_MOUNT FILE_TYPE_CHAR_DEV
     FILE_TYPE_COUNT FILE_TYPE_DIR FILE_TYPE_FILE FILE_TYPE_FUSE_MOUNT
     FILE_TYPE_MASK_ANY FILE_TYPE_MASK_BLOCK_DEV FILE_TYPE_MASK_CHAR_DEV
     FILE_TYPE_MASK_DIR FILE_TYPE_MASK_FILE FILE_TYPE_MASK_NORMAL
     FILE_TYPE_MASK_PIPE FILE_TYPE_MASK_READABLE FILE_TYPE_MASK_SOCKET
     FILE_TYPE_MASK_SPECIAL FILE_TYPE_MASK_SYMLINK FILE_TYPE_MOUNT_POINT
     FILE_TYPE_NETWORK_MOUNT FILE_TYPE_PIPE FILE_TYPE_SNAPSHOT
     FILE_TYPE_SOCKET FILE_TYPE_SPECIAL FILE_TYPE_SPECIAL_MOUNT
     FILE_TYPE_SUBVOLUME FILE_TYPE_SYMLINK FILE_TYPE_VOLATILE_MOUNT
     PERM_FIELD_ACL PERM_FIELD_EFFECTIVE PERM_FIELD_G PERM_FIELD_O
     PERM_FIELD_S PERM_FIELD_U PERM_GROUP_R PERM_GROUP_W PERM_GROUP_X
     PERM_OTHER_R PERM_OTHER_W PERM_OTHER_X PERM_R PERM_SETGID PERM_SETUID
     PERM_STICKY PERM_USER_R PERM_USER_W PERM_USER_X PERM_W PERM_X
     STATS_QUERY_BASE STAT_ACL STAT_ATIME STAT_ATIME_NS
     STAT_BLOCK_CHAR_DEV_SPEC STAT_BLOCK_COUNT STAT_BLOCK_SIZE
     STAT_CAPABILITIES STAT_CTIME STAT_CTIME_NS STAT_DEFAULT_ACL STAT_DEV
     STAT_EXTENTS STAT_FIELD_COUNT STAT_FSFLAGS STAT_FSTYPE STAT_GID
     STAT_INODE STAT_IS_ACCESSIBLE STAT_LOCKS STAT_MODE STAT_MTIME
     STAT_MTIME_NS STAT_NAME STAT_NLINK STAT_OPENFD STAT_PATH STAT_SIZE
     STAT_SUBSET STAT_SYMLINK STAT_TYPE STAT_UID STAT_XATTRS S_IFMT_SHIFT
     dev_node_matches_major_minor_type file_stats_to_hash join_major_minor_dev
     mode_to_file_type split_major_minor_dev);

use MTY::System::POSIX;
use MTY::Common::Common;
use MTY::Common::Misc;
use MTY::Common::Hashes;
use MTY::Common::Strings;
use MTY::RegExp::FilesAndPaths;
#pragma end_of_includes

#
# Encodings for the STAT_MODE access permission files
# (these are more useful and obvious replacements for the S_xxxxx constants):
#
use constant {
  PERM_FIELD_EFFECTIVE => 5, # permissions derived from ACL (if present) (not a real field in STAT_MODE)
  PERM_FIELD_ACL => 4, # permissions derived from ACL (if present) (not a real field in STAT_MODE)
  PERM_FIELD_S => 3, # setuid, setgid and sticky bit
  PERM_FIELD_U => 2, # user
  PERM_FIELD_G => 1, # group
  PERM_FIELD_O => 0, # other
  # or if undefined: printing final effective permissions
};

use constant {
  PERM_R => 4, # read
  PERM_W => 2, # write
  PERM_X => 1, # execute (files) or traverse (directories)
};

use constant enumbits qw(
  PERM_OTHER_X PERM_OTHER_W PERM_OTHER_R
  PERM_GROUP_X PERM_GROUP_W PERM_GROUP_R
  PERM_USER_X PERM_USER_W PERM_USER_R);

use constant {
  PERM_SETUID => (1 << 11), # set effective user ID on execute (files); unused (directories)
  PERM_SETGID => (1 << 10), # set effective group ID on execute (files); new subdirs inherit parent directory's group (directories)
  PERM_STICKY => (1 << 9),  # "sticky" bit ('t'): only the owner of a file can remove it from a directory with the t-bit set
};

#
# Important Notes on the STAT_*TIME and STAT_*TIME_NS fields:
#
# - The ATIME, MTIME, CTIME fields always contain an integer number of seconds
#   since the epoch defined by POSIX (Jan 1, 1970 @ 12:00:00 UTC)
#
# - The corresponding ATIME_NS, MTIME_NS, CTIME_NS fields are floating point
#   numbers with integral parts equal the corresponding STAT_*TIME field (i.e. 
#   int(%stats[STAT_MTIME_NS]) == %stats[STAT_MTIME]) and the fractional parts
#   are the respective number of nanoseconds after the whole number of seconds.
#
#   This effectively implies both *TIME and *TIME_NS contain the same data, yet
#   *TIME_NS merely increases the floating point precision down to 1 billionth
#   of a second, at least in theory - in practice, precision may be limited by
#   the clock sources used by the kernel (ideally this is the CPU timestamp
#   counter, which fortunately runs fast enough (often at a fixed rate of 1 GHz)
#   to provide this precision). 
#
#   The limits of IEEE 754 double precision floating point values can also 
#   adversely affect precision, since the 53 bit mantissa must be shared between
#   the absolute number of seconds since the epoch (as of 2014, this part is in
#   the ballpark of ~1,400,000,000, which itself requires 31 bits) and whatever
#   is left over (specifically 22 bits) is used to represent the fractional
#   seconds. 
#
#   The bottom line is that these 22 bits can only represent 1/256th the precision
#   that nanosecond resolution would require (i.e. ~30 bits would be required for a
#   billion nanoseconds, i.e. one whole second), which means the real precision of
#   this approach is closer to ~0.25 microseconds instead of a single nanosecond.
#
#   (In reality no one probably cares about this distinction, since timestamp 
#   dependent tasks such as recompiling code using a makefile are themselves
#   likely to take far longer than mere microseconds to complete anyway).
#
#   (Additional notes):
#
#   Note that this is NOT the same as the native fstat/fstatat nanoseconds
#   fields, which are integer offsets in nanoseconds from the seconds fields,
#   whereas the *TIME_NS fields we provide are the real time in seconds (with
#   nanosecond precision) since the epoch. 
# 
#   However, these (more useful) semantics of the *TIME_NS fields are only
#   provided if the get_file_timestamps() function is used on a filename
#   (or directory name), file or directory handle, or an existing structure
#   returned by stat(), fstat() or fstatat().
#
use constant {
  #
  # Fields defined by Linux/POSIX:
  #
  STAT_DEV => 0,
  STAT_INODE => 1,
  STAT_MODE => 2,
  STAT_NLINK => 3,
  STAT_UID => 4,
  STAT_GID => 5,
  STAT_BLOCK_CHAR_DEV_SPEC => 6,
  STAT_SIZE => 7,
  STAT_ATIME => 8,
  STAT_MTIME => 9,
  STAT_CTIME => 10,
  STAT_BLOCK_SIZE => 11,
  STAT_BLOCK_COUNT => 12,
  #
  # Fields already defined by Linux/POSIX whose semantics we modify or enhance:
  #
  STAT_ATIME_NS => 13,
  STAT_MTIME_NS => 14,
  STAT_CTIME_NS => 15,
  #
  # Synthetic fields which are only filled in by enhanced_file_stats():
  #
  STAT_NAME => 16,
  STAT_PATH => 17,
  STAT_TYPE => 18,
  STAT_SYMLINK => 19,
  STAT_FSTYPE => 20,
  STAT_FSFLAGS => 21,
  STAT_XATTRS => 22,
  STAT_ACL => 23,
  STAT_DEFAULT_ACL => 24,
  STAT_CAPABILITIES => 25,
  STAT_LOCKS => 26,
  STAT_OPENFD => 27,
  STAT_EXTENTS => 28,
  STAT_IS_ACCESSIBLE => 29,
  STAT_SUBSET => 30,
  STAT_FIELD_COUNT => 30,
};  

our @file_stat_field_names = 
  qw(dev inode mode nlink uid gid dev_major_minor
     size atime mtime ctime block_size block_count
     atime_ns ctime_ns mtime_ns name path type
     symlink fstype fsflags xattrs acl default_acl 
     capabilities locks openfds extents accessible);

our %stat_field_index_to_name_map = array_values_to_hash(@file_stat_field_names);

our %stat_field_name_to_index_map = (
  'dev' => STAT_DEV, 'd' => STAT_DEV,
  'inode' => STAT_INODE, 'i' => STAT_INODE,
  'mode' => STAT_MODE, 'm' => STAT_MODE, 'perms' => STAT_MODE, 'p' => STAT_MODE,
  'nlink' => STAT_NLINK, 'n' => STAT_NLINK, 'links' => STAT_NLINK,
  'uid' => STAT_UID, 'u' => STAT_UID,
  'gid' => STAT_GID, 'g' => STAT_GID,
  'devspec' => STAT_BLOCK_CHAR_DEV_SPEC, 'dev-major-minor' => STAT_BLOCK_CHAR_DEV_SPEC, 'ds' => STAT_BLOCK_CHAR_DEV_SPEC,
  'size' => STAT_SIZE, 's' => STAT_SIZE,
  'atime' => STAT_ATIME_NS, 'at' => STAT_ATIME_NS,
  'mtime' => STAT_MTIME_NS, 'mt' => STAT_MTIME_NS, 't' => STAT_MTIME_NS,
  'ctime' => STAT_CTIME_NS, 'ct' => STAT_CTIME_NS,
  'blocksize' => STAT_BLOCK_SIZE, 'bs' => STAT_BLOCK_SIZE,
  'blocks' => STAT_BLOCK_COUNT, 'b' => STAT_BLOCK_COUNT,
  'name' => STAT_NAME, 'filename' => STAT_NAME, 'f' => STAT_NAME,
  'type' => STAT_TYPE, 't' => STAT_TYPE, 
  'symlink' => STAT_SYMLINK, 'l' => STAT_SYMLINK, 'sl' => STAT_SYMLINK,
  'fstype' => STAT_FSTYPE, 'fs' => STAT_FSTYPE,
  'fsflags' => STAT_FSFLAGS, 'fsf' => STAT_FSFLAGS, 'flags' => STAT_FSFLAGS,
  'xattr' => STAT_XATTRS, 'xattrs' => STAT_XATTRS, 'extattrs' => STAT_XATTRS, 'ea' => STAT_XATTRS, 
  'acl' => STAT_ACL, 'acls' => STAT_ACL, 
  'defacl' => STAT_DEFAULT_ACL, 'defaultacl' => STAT_DEFAULT_ACL, 
  'caps' => STAT_CAPABILITIES, 'capabilities' => STAT_CAPABILITIES, 
  'locks' => STAT_LOCKS, 'lk' => STAT_LOCKS, 
  'openfd' => STAT_OPENFD, 
  'extents' => STAT_EXTENTS, 'cloned' => STAT_EXTENTS, 
  'accessible' => STAT_IS_ACCESSIBLE, 'ok' => STAT_IS_ACCESSIBLE, 
);

our @file_stat_field_types = (
  SCALAR, SCALAR, SCALAR, SCALAR, SCALAR, SCALAR, SCALAR, SCALAR, 
  SCALAR, SCALAR, SCALAR, SCALAR, SCALAR, SCALAR, SCALAR, SCALAR, 
  STRING, STRING, SCALAR, STRING, # name, path, type, symlink
  STRING, SCALAR, HASH_REF, ARRAY_REF, # fstype, fsflags, xattrs, acl,
  ARRAY_REF, ARRAY_REF, ARRAY_REF, ARRAY_REF, # default_acl, capabilities, locks, openfds,
  HASH_REF, SCALAR, # extents, accessible
);

use constant {
  STATS_QUERY_BASE    => (1 << 0), # basic sys_stat() info + (type, name, path)
};

#
# NOTE: This is only valid on Linux 2.6x+ which uses 32-bit 
# major and minor device numbers. These are packed into a
# 64-bit combined device number in an odd way intended to
# preserve binary compatibility with code that still uses
# legacy 8-bit major and minor numbers. The combined 64-bit
# format is shown below:
#
#    JJJJJnnn nnnJJJnn
#    bit63        bit0
#
# where:  J = 4 bit chunk of major number
#         n = 4 bit chunk of minor number
#         space is between the high and low 32-bit halves
#

sub split_major_minor_dev($) {
  my ($dev) = @_;

  my $major = (($dev >> 8) & 0xfff) | (($dev >> 32) & 0xfffff000);
  my $minor = ($dev & 0xff) | (($dev >> 12) & 0xffffff00);
  return ($major, $minor);
}

sub join_major_minor_dev($$) {
  my ($major, $minor) = @_;

  return 
    ($minor & 0xff) | 
    (($major & 0xfff) << 8) | 
    (($minor & 0xffffff00) << 12) |
    (($major & 0xfffff000) << 32);
}

sub dev_node_matches_major_minor_type($$$$) {
  my ($dev_node_path, $major, $minor, $type) = @_;

  my ($dev_node_major, $dev_node_minor, $dev_node_type) =
    get_dev_node_major_minor_type($dev_node_path);

  if (!defined $dev_node_type) { return 0; }

  return (($dev_node_type == $type) &&
           ($dev_node_major == $major) &&
           ($dev_node_minor == $minor)) ? 1 : 0;
}

sub file_stats_to_hash(+) {
  return array_pair_to_hash(\@file_stat_field_names, $_[0]);
}

use constant S_IFMT_SHIFT => 12;

use constant {
  # standard kernel defined types returned by actual stat() syscall:
  FILE_TYPE_SPECIAL => 0 >> S_IFMT_SHIFT,
  FILE_TYPE_PIPE => S_IFIFO >> S_IFMT_SHIFT,
  FILE_TYPE_CHAR_DEV => S_IFCHR >> S_IFMT_SHIFT,
  FILE_TYPE_DIR => S_IFDIR >> S_IFMT_SHIFT,
  FILE_TYPE_BLOCK_DEV => S_IFBLK >> S_IFMT_SHIFT,
  FILE_TYPE_FILE => S_IFREG >> S_IFMT_SHIFT,
  FILE_TYPE_SYMLINK => S_IFLNK >> S_IFMT_SHIFT,
  FILE_TYPE_SOCKET => S_IFSOCK >> S_IFMT_SHIFT,
  # mount points (all are used in place of FILE_TYPE_DIR):
  FILE_TYPE_MOUNT_POINT     =>    0 + (1<<8), # generic mount point
  FILE_TYPE_BLOCK_DEV_MOUNT =>    0 + (1<<8), # physical block device
  FILE_TYPE_BIND_MOUNT      =>    1 + (1<<8), # bind mount (graft of another directory onto here)
  FILE_TYPE_VOLATILE_MOUNT  =>    2 + (1<<8), # volatile in-memory filesystem (tmpfs, ramfs or other volatile namespace)
  FILE_TYPE_SPECIAL_MOUNT   =>    3 + (1<<8), # special kernel maintained mount (procfs, sysfs, devpts, securityfs, configfs, etc)
  FILE_TYPE_ANONYMOUS_MOUNT =>    4 + (1<<8), # used solely by the kernel as a namespace for anonymous objects
  FILE_TYPE_NETWORK_MOUNT   =>    5 + (1<<8), # network filesystems (nfs, smb/cifs, afs, etc)
  FILE_TYPE_FUSE_MOUNT      =>    6 + (1<<8), # FUSE filesystem provided by userspace daemon
  # subvolume boundaries within a single physical filesystem:
  FILE_TYPE_SUBVOLUME       =>    0 + (2<<8), # independent subvolume
  FILE_TYPE_SNAPSHOT        =>    1 + (2<<8), # snapshot of another subvolume (may be read-only or writable)
};

use constant {
  FILE_TYPE_COUNT           =>    FILE_TYPE_SNAPSHOT + 1,
};

use constant {
  FILE_TYPE_MASK_FILE      => (1 << FILE_TYPE_FILE),
  FILE_TYPE_MASK_DIR       => (1 << FILE_TYPE_DIR),
  FILE_TYPE_MASK_SYMLINK   => (1 << FILE_TYPE_SYMLINK),
  FILE_TYPE_MASK_PIPE      => (1 << FILE_TYPE_PIPE),
  FILE_TYPE_MASK_CHAR_DEV  => (1 << FILE_TYPE_CHAR_DEV),
  FILE_TYPE_MASK_BLOCK_DEV => (1 << FILE_TYPE_BLOCK_DEV),
  FILE_TYPE_MASK_SOCKET    => (1 << FILE_TYPE_SOCKET),
};

use constant {
  FILE_TYPE_MASK_SPECIAL => 
    (FILE_TYPE_MASK_PIPE | FILE_TYPE_MASK_CHAR_DEV |
     FILE_TYPE_MASK_BLOCK_DEV | FILE_TYPE_MASK_SOCKET),

  FILE_TYPE_MASK_NORMAL =>
    (FILE_TYPE_MASK_FILE | FILE_TYPE_MASK_DIR |
     FILE_TYPE_MASK_SYMLINK),

  FILE_TYPE_MASK_READABLE =>
    (FILE_TYPE_MASK_FILE | FILE_TYPE_MASK_PIPE |
     FILE_TYPE_MASK_BLOCK_DEV | FILE_TYPE_MASK_CHAR_DEV),

  FILE_TYPE_MASK_ANY       => 0xFFFF,
};

our %file_type_to_description = (
  FILE_TYPE_SPECIAL,          'special',
  FILE_TYPE_PIPE,             'pipe',
  FILE_TYPE_CHAR_DEV,         'chardev',
  FILE_TYPE_DIR,              'dir',
  FILE_TYPE_BLOCK_DEV,        'blockdev',
  FILE_TYPE_FILE,             'file',
  FILE_TYPE_SYMLINK,          'symlink',
  FILE_TYPE_SOCKET,           'socket',
  FILE_TYPE_BLOCK_DEV_MOUNT,  'mount.blockdev',
  FILE_TYPE_BIND_MOUNT,       'mount.bind',
  FILE_TYPE_VOLATILE_MOUNT,   'mount.volatile',
  FILE_TYPE_SPECIAL_MOUNT,    'mount.special',
  FILE_TYPE_ANONYMOUS_MOUNT,  'mount.anonymous',
  FILE_TYPE_NETWORK_MOUNT,    'mount.network',
  FILE_TYPE_FUSE_MOUNT,       'mount.fuse',
  FILE_TYPE_SUBVOLUME,        'subvolume',
  FILE_TYPE_SNAPSHOT,         'subvolume.snapshot',
);

sub mode_to_file_type {
  return $_[0] >> S_IFMT_SHIFT;
}

1;
