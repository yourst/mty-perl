#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Display::Table
#
# Formatting of tables with automatically sized rows and columns
#
# Copyright 1997 - 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Display::Table;

use integer; use warnings; use Exporter qw(import);

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(TRIM_TO_REMAINING_SPACE_ON_LINE UNLIMITED_WIDTH
     WRAP_TO_REMAINING_SPACE_ON_LINE adjust_max_col_width
     expand_fields_and_columns_in_line format_delimited_table format_table
     prep_to_format_table print_table test_format_table wrap_table_cells);

use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::RegExp::Define;
use MTY::RegExp::Strings;
use MTY::Display::ANSIColorREs;
use MTY::Display::Colorize;
use MTY::Common::Strings;
use MTY::System::POSIX qw(INT_MAX);
#pragma end_of_includes

my $field_column_markup_re = 
  qr{\% \{ (field|column) (?> \= ([^\}]+))? \}}oax;

my $field_column_markup_nocap_re = 
  qr{\% \{ (?> field | column) [^\}]++ \}}oax;

noexport:; sub expand_fields_and_columns_in_line($;$) {
  my ($line, $field_columns) = @_;

  my $field_id_counter = 0;
  my @field_columns = ( );
  my $prev_field_rel_pos = 0;
  my $prev_markup_abs_end_pos = 0;

  while (my ($op, $id) = ($line =~ /$field_column_markup_re/oax)) {
    if ($op eq 'field') {
      $id //= $field_id_counter;
      $field_id_counter++;
      my $start = $-[0];
      my $end = $+[0];
      
      my $markup_length = $end - $start;
      my $prev_field_rel_pos = $-[0];

      $prev_markup_abs_end_pos = $+[0];

      if ($op eq 'field') { $field_id_counter++; }
    }
  }
}

#
# For each table cell that contains a text string longer than the
# specified maximum width W of its column, split the cell vertically
# into multiple cells, each containing at most W characters, properly
# wrapped at word boundaries. If multple cells in a given row must be
# split, the number of extra rows inserted will be the largest number
# of extra rows needed to split any column in that row; shorter cells
# will have blank cells added to the remaining rows in their columns.
#
# If the maximum width specified for a column is less than zero (W < 0), 
# the column will be truncated to a single line of (-W) printable
# characters instead of wrapping it across multiple lines.
#

use constant {
  UNLIMITED_WIDTH                 => 0,
  WRAP_TO_REMAINING_SPACE_ON_LINE => +(1 << 30),
  TRIM_TO_REMAINING_SPACE_ON_LINE => -(1 << 30),
};

noexport:; sub adjust_max_col_width($$$) {
  my ($w, $n, $remaining_width) = @_;
  $w //= 0;
  $remaining_width //= INT_MAX;
  
  $w = (($w == 0) ? INT_MAX :
    (($w == WRAP_TO_REMAINING_SPACE_ON_LINE) ||
     ($w == TRIM_TO_REMAINING_SPACE_ON_LINE)) ? $remaining_width :
     $w);

  my $trim_instead_of_wrap = 0;
  if ($w < 0) { $trim_instead_of_wrap = 1; $w = -$w; }
  $w = min($w, $n);
  return ($w, $n, $trim_instead_of_wrap);
}

noexport:; sub wrap_table_cells(++++++$$$$;$$) {
  my ($table, $max_col_widths, $lengths, $longest_in_column, $accum_width_at_cols, 
      $colsep_lengths, $row_prefix_length, $row_suffix_length, $first_line_prefix,
      $subsequent_line_prefix, $visible_width, $ignore_newlines) = @_;
  $first_line_prefix //= '';
  $subsequent_line_prefix //= '  ';
  $visible_width //= get_terminal_width_in_columns();
  $ignore_newlines //= 0;

  if (!defined $max_col_widths) { return ($table, undef, $lengths); }

  my @out = ( );
  my @expanded_row_to_orig_row = ( );
  my @new_lengths = ( );

  my $column_count = scalar @$longest_in_column;

  while (my ($r, $row) = each @$table) {
    my @new_rows_in_col = ( );

    my $orig_lengths = (defined $lengths) ? $lengths->[$r] : undef;

    if (!is_array_ref $row) {
      # Just output this row as a user defined string:
      push @out, $row;
      push @expanded_row_to_orig_row, $r;
      push @new_lengths, $orig_lengths;
      next;
    }
    
    my $max_split_row_count = 1;
    my $cols_in_row = scalar @$row;
    my $remaining = max(($visible_width - 1) - $row_prefix_length, 0);

    while (my ($c, $col) = each @$row) {
      my ($w, $n, $trim_instead_of_wrap) = adjust_max_col_width($max_col_widths->[$c], printed_length($col // ''), $remaining);
      
      my $new_rows = undef;

      if ($n > $w) {
        $new_rows = ($trim_instead_of_wrap) 
          ? [ map { truncate_printed_string($_, $w) } split(/\n/oamsx, $col) ]
          : [ wrap_long_lines($col, $w, ' ', $first_line_prefix, $subsequent_line_prefix) ];
      } else {
        $new_rows = [ $col ];
      }
      set_max($max_split_row_count, scalar(@$new_rows));
      $new_rows_in_col[$c] = $new_rows;
      
      $remaining -= $w;
      $remaining -= $colsep_lengths->[$c] if ($c < ($column_count - 1));
      $remaining = max($remaining, 0);
    }

    if ($max_split_row_count > 1) {
      for my $rs (0..($max_split_row_count-1)) {
        push @out, [ map { ($_->[$rs]) // '' } @new_rows_in_col ];
        push @expanded_row_to_orig_row, $r;
        push @new_lengths, undef; # force prep_to_format_table() to recalculate these rows
        # The code above is faster than the following functionally equivalent code:
        #
        #   my $final_row = [ ];
        #   for my $c (0..($cols_in_row-1))
        #     { $final_row->[$c] = ($new_rows_in_col[$c]->[$r]) // ''; }
        #   push @out, $final_row;
        #
      }
    } else {
      # No column required more than one row: just include ref to old row
      push @out, $row;
      push @expanded_row_to_orig_row, $r;
      push @new_lengths, $orig_lengths;
    }
  }

  return (\@out, \@expanded_row_to_orig_row, \@new_lengths);
}

#
# Print the specified array of arrays ($rows[...] = [column1, column2, ...])
# with properly aligned and padded columns so the longest string in each
# column will entirely fit within its respective printed column.
#
# The $prev_lengths argument (if defined) can be used to pass in the
# existing length table after it was adjusted by wrap_table_cells().
# In this case, if $prev_lengths already contains a defined entry
# for a row, that entry is used as is instead of recalculating it,
# which saves considerable effort if most rows don't need wrapping.
#
sub prep_to_format_table(++++$$$$) {
  my ($rows, $prev_lengths, $max_col_widths, $colseps, $row_prefix_length, $row_suffix_length, $visible_width, $clip_above_percentile) = @_;
  my $DEBUG = 0;

  $max_col_widths //= [ ];

  if (is_hash_ref($rows)) 
    { $rows = hash_to_array_of_pairs($rows); }

  my $row_count = scalar(@$rows);

  my $column_count = 0;
  foreach my $row (@$rows) { set_max($column_count, scalar @$row); }

  my @colsep_lengths = map { printed_length($_) } @$colseps;
  pad_array(@colsep_lengths, $column_count);
  pad_array($colseps, $column_count);
  my @longest_in_column = ((0) x $column_count);

  my @column_length_histograms = ( );

  my @lengths = ( );
  prealloc(@lengths, $row_count + 3);

  while (my ($r, $row) = each @$rows) {
    my @col_lengths_in_this_row = ( );

    # Bypass re-calculation of this row if wrap_table_cells() did not
    # modify any of the columns and did not add any new rows:
    my $existing_row_stats = (defined $prev_lengths) ? $prev_lengths->[$r] : undef;

    if (defined $existing_row_stats) {
      $lengths[$r] = $existing_row_stats;
      if (is_array_ref $row) {
        while (my ($c, $colwidth) = each @$existing_row_stats) 
          { set_max($longest_in_column[$c], $colwidth); }
      }
      next;
    }

    if (!is_array_ref $row) {
      # Just output this row as a user defined string:
      $lengths[$r] = [ printed_length($row) ];
      next;
    }

    my $remaining = max($visible_width - $row_prefix_length, 0);

    while (my ($c, $col) = each @$row) {
      my ($w, $n, $trim_instead_of_wrap) = adjust_max_col_width($max_col_widths->[$c], printed_length($col // ''), $remaining);

      push @col_lengths_in_this_row, $n;
      set_max($longest_in_column[$c], $n);

      if (defined $clip_above_percentile) {
        $column_length_histograms[$c] //= [ ];
        my $histo = $column_length_histograms[$c];
        $histo->[$n] = ($histo->[$n] // 0) + 1;
      }

      $remaining -= $w;
      $remaining -= $colsep_lengths[$c] if ($c < ($column_count - 1));
      $remaining = max($remaining, 0);
    }

    $lengths[$r] = \@col_lengths_in_this_row;
  }

  if (defined $clip_above_percentile) {
    while (my ($c, $histo) = each @column_length_histograms) {
      no integer;
      my $count_at_percentile = int($row_count * ($clip_above_percentile / 100.0));
      use integer;
      $count_at_percentile = clipto($count_at_percentile, 0, $row_count);

      my $total_so_far = 0;
      my $clip_at_length = $longest_in_column[$c];
      
      while (my ($length, $count) = each @$histo) {
        $total_so_far += ($count // 0);
        if ($total_so_far >= $count_at_percentile) {
          $clip_at_length = $length;
        }
      }

      if ($DEBUG) {
        printfd(STDERR, 'Column ', $c, ' length histogram:', NL);
        my $cumulative = 0;
        for my $i (0..$#{$histo}) {
          my $v = $histo->[$i] // 0;
          $cumulative += $v;
          printfd(STDERR, '  '.padstring($i, -5).' => '.padstring($v, -5).' (cumulative '.padstring($cumulative, -5).')'.NL);
        }
        if ($clip_at_length != $longest_in_column[$c]) {
          printfd(STDERR, 'Column '.$c.': longest entry had '.$longest_in_column[$c].
                  ' chars, but clipped to '.$clip_at_length.' chars ('.
                  $clip_above_percentile.' percentile = cumulative count of '.
                  $count_at_percentile.' out of '.$row_count.')'.NL);
        }
      }

      $longest_in_column[$c] = $clip_at_length;
    }
  }

  my $accum = $row_prefix_length;
  my @accum_width_at_cols = ( );

  for my $i (0..($column_count-1)) {
    $accum_width_at_cols[$i] = $accum;
    $accum += $longest_in_column[$i];
    $accum += printed_length($colseps->[$i]) if ($i < ($column_count - 1));
  }

  push @accum_width_at_cols, $accum + $row_suffix_length;

#  push @lengths, \@longest_in_column, \@accum_width_at_cols, \@colsep_lengths;

  if ($DEBUG) {
    printfd(STDERR, "Printed length map:".NL);
    foreach my $row (@lengths) {
      printfd(STDERR, '  ');
      foreach my $col (@$row) {
        printf(STDERR '%-4d ', $col // 0);
      }
      printfd(STDERR, NL);
    }
  }

  return (\@lengths, \@longest_in_column, \@accum_width_at_cols, $colseps, \@colsep_lengths);
}

my @format_table_valid_options = 
  qw(colseps row_prefix row_suffix align clip_to_length
    wrap_above_max_col_widths first_line_prefix
    subsequent_line_prefix clip_above_percentile padding
    visible_width return_matrix return_lines fd);

my %format_table_valid_options = array_to_hash_keys(@format_table_valid_options);

sub format_table(+;%) {
  my ($rows, %options) = @_;

  my ($colseps, $row_prefix, $row_suffix, $alignments,
      $clip_to_length, $wrap_above_max_col_widths,
      $first_line_prefix, $subsequent_line_prefix,
      $clip_above_percentile, $per_column_padding,
      $visible_width, $return_matrix, $return_lines, $fd) =
    @options{@format_table_valid_options};

  if (is_hash_or_blessed_hash($rows)) 
    { $rows = hash_to_array_of_pairs($rows); }

  # foreach my $option (keys %options) 
  #   { warn("format_table: ignoring invalid option '$option'") if (!exists $format_table_valid_options{$option}); }

  # For testing purposes only:
  # foreach my $row (@$rows) {
  #   $row = [ map { strip_ansi_console_escape_codes($_ =~ s{$utf8_re}{?}roamsxg) } @$row ];
  # }

  $colseps //= ($return_matrix ? '' : ' ');
  $row_prefix //= '';
  $row_suffix //= NL;
  $visible_width //= get_terminal_width_in_columns();

  my ($even_row_prefix, $odd_row_prefix) = 
    (is_array_ref($row_prefix) ? @$row_prefix : ($row_prefix, $row_prefix));
  my $row_prefix_length = max(printed_length($even_row_prefix), printed_length($odd_row_prefix));

  my ($even_row_suffix, $odd_row_suffix) = 
    (is_array_ref($row_suffix) ? @$row_suffix : ($row_suffix, $row_suffix));
  my $row_suffix_length = max(printed_length($even_row_suffix), printed_length($odd_row_suffix));
  
  $alignments //= ALIGN_LEFT;

  if (!is_array_ref($colseps)) { $colseps = [ $colseps ]; }

  if (!is_array_ref($alignments)) { $alignments = [ $alignments ]; }

  my $expanded_row_to_orig_row = undef;

  my $lengths = undef;
  my $longest_in_column = undef;
  my $accum_width_at_cols = undef;
  my $colsep_lengths = undef;

  if (defined $wrap_above_max_col_widths) { 
    my $need_recalc = 0;
    foreach my $max_col_width (@$wrap_above_max_col_widths) {
      my $w = $max_col_width // 0;
      $need_recalc |= (($w == WRAP_TO_REMAINING_SPACE_ON_LINE) ||
                       ($w == TRIM_TO_REMAINING_SPACE_ON_LINE));
    }

    ($lengths, $longest_in_column, $accum_width_at_cols, $colseps, $colsep_lengths) = prep_to_format_table(
      $rows, $lengths, $wrap_above_max_col_widths, $colseps, $row_prefix_length, $row_suffix_length, 
      $visible_width, $clip_above_percentile);

    ($rows, $expanded_row_to_orig_row, $lengths) = wrap_table_cells(
      $rows, $wrap_above_max_col_widths, $lengths, $longest_in_column, $accum_width_at_cols, $colsep_lengths,
      $row_prefix_length, $row_suffix_length, $first_line_prefix, $subsequent_line_prefix, $visible_width);
  }

  ($lengths, $longest_in_column, $accum_width_at_cols, $colseps, $colsep_lengths) = prep_to_format_table(
    $rows, $lengths, $wrap_above_max_col_widths, $colseps, $row_prefix_length, $row_suffix_length, 
    $visible_width, $clip_above_percentile);

  my $column_count = scalar @$longest_in_column;

  $per_column_padding //= ' ';
  if (!is_array_ref($per_column_padding)) { $per_column_padding = [ $per_column_padding ]; }
  my @padding_for_column;
  my @padding_color_for_column;

  foreach my $p (@$per_column_padding) {
    my ($color, $text) = separate_leading_ansi_console_escape_codes($p);
    push @padding_color_for_column, $color;
    push @padding_for_column, $text;
  }

  pad_array(@padding_for_column, $column_count);
  pad_array(@padding_color_for_column, $column_count);

  pad_array($alignments, $column_count);
  
  my @out = ( );

  while (my ($r, $row) = each @$rows) {
    my $rowout = [ ];
    my $origrow = (defined $expanded_row_to_orig_row) ? $expanded_row_to_orig_row->[$r] : $r;

    if (!is_array_ref $row) {
      # Just output this row as a user defined string:
      $out[$r] = $row;
      next;
    }

    my $max_col_in_row = (scalar @$row)-1;
    my $col_lengths_in_row = $lengths->[$r];

    my $row_length_in_chars = 0;
    if (!$return_matrix) {
      push @$rowout, (($origrow & 1) ? $odd_row_prefix : $even_row_prefix);
      $row_length_in_chars += $row_prefix_length;
    }

    while (my ($c, $col) = each @$row) {
      my $text = $col // '';
      my $len = $col_lengths_in_row->[$c] // 0;
      my $colout = '';
      if ($c < $max_col_in_row) {
        my $padlen = max($longest_in_column->[$c] - $len, 0);
        my $padding = $padding_color_for_column[$c].($padding_for_column[$c] x $padlen);
        my $alignment = $alignments->[$c];
        $colout .= 
          ($alignment == ALIGN_LEFT) ? ($text . $padding) :
          ($alignment == ALIGN_RIGHT) ? ($padding . $text) :
          die("Invalid alignment $alignment");
        $row_length_in_chars += $padlen;
      } else {
        #
        # Don't pad the last column, to avoid effectively double spacing every line
        # (due to the insertion of so many column width padding spaces that a single
        # column takes more characters than one line of the current terminal). This
        # typically occurs when a few rows have really long last columns (such as
        # variable length strings like filenames, etc., which traditionally appear 
        # in the last column).
        #
        $colout .= $text;
      }

      $row_length_in_chars += $len;

      if ((!$return_matrix) && ($c < $max_col_in_row)) {
        $colout .= $colseps->[$c];
        $row_length_in_chars += $colsep_lengths->[$c];
      }

      push @$rowout, $colout;
    }

    if (!$return_matrix) {
      push @$rowout, (($origrow & 1) ? $odd_row_suffix : $even_row_suffix);
      $row_length_in_chars += $row_suffix_length;
    }

    # if ((defined $clip_to_length) && ($row_length_in_chars > $clip_to_length))
    #  { $rowout = truncate_printed_string($rowout, $clip_to_length); }

    $out[$r] = $rowout;
  }

  if ($return_matrix) { 
    return @out;
  } elsif ($return_lines) {
    return map { (is_array_ref($_)) ? join('', @$_) : $_ } @out;
  } else {
    my $outstr = join('', map { (is_array_ref($_) ? join('', @$_) : $_) } @out);
    if (defined $fd) { 
      printfd($fd, $outstr); return $outstr; 
    } else {
      return $outstr;
    }
  }
}

sub format_delimited_table(+$;%) {
  my ($rows, $delim, %options) = @_;
  return format_table([ map { [ split($delim, $_) ] } @$rows ], %options);
}

sub print_table($+;%) {
  my ($fd, $rows, %options) = @_;
  format_table($rows, (%options, fd => $fd));
}

sub test_format_table() {
  my @std_options = (colseps => ' | ', row_prefix => '<< ', row_suffix => ' >>'.NL, align => [ ALIGN_RIGHT, ALIGN_RIGHT, ALIGN_LEFT ]);

  my $tables_and_options = [
    [
      [
        NL.X.C.U.'First Category:'.X.NL.NL,
        ['first is a really long column which just goes on and on and on...',      'premier',             '1st'],
        ['2nd row, col 1',            'row deux. 2nd col',   'numero trois. column finale'],
        NL.X.C.U.'Second Category:'.X.NL.NL,
        ['third',                     'lucky three',       (join('', map { 'trois triple tres #'.$_.' is the lucky number, ' } 1..15))],
        ['fourth',                    'finale',              'four is more'],
      ],
      [ @std_options, wrap_above_max_col_widths => [ 50, 50, WRAP_TO_REMAINING_SPACE_ON_LINE ] ],
    ],
  ];

  my $other_tables = [
    [
      [
        [qw(first premier 1st)],
        ['second',       'sorry sekond',  '2nd'],
        ['third',        'trois place',   '3'],
        ['fourth',       'finale',        'four is more'],
      ],
      [ @std_options ]
    ],
    [
      [
        ['first'.TAB.       'premier'.TAB.      '1st'],
        ['second'.TAB.      'sorry sekond'.TAB. '2nd'],
        ['third'.TAB.       'trois place'.TAB.  '3'],
        ['fourth'.TAB.      'finale'.TAB.       'four is more'],
      ],
      [ @std_options, colseps => TAB ]
    ],
  ];

  foreach my $table_and_options (@$tables_and_options) {
    my ($table, $options) = @{$table_and_options};
    prints(NL.NL."================ Table: =================".NL.NL);
    #use DDP;
    #prints('@input = '.p($table).NL);
    #prints(join('', map { '  ["'.join('", "', @$_).'"],'.NL } @$table).NL);
    #prints(']'.NL.NL);

    my @out_as_matrix = format_table($table, @$options, return_matrix => 1);

#    prints('@output = ['.NL);
#    prints(join('', map { (is_array_ref($_) ? '  ["'.join('", "', @$_).'"],'.NL : $_) } @out_as_matrix).NL);
#    prints(']'.NL.NL);

    my $out = format_table($table, @$options);
    prints('$output = '.NL.$out.NL);

    last;
  }

  return;
}

1;
