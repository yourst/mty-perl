#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Display::DataStructures
#
# Simple text formatting of all the major Perl data types
#
# Copyright 1997 - 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Display::DataStructures;

use integer; use warnings; use Exporter qw(import);

use MTY::Common::Common;
use MTY::Common::Strings;
use MTY::Common::Hashes;
use MTY::Common::PrintDebug;
use MTY::Common::Symbols;
use MTY::RegExp::Strings;
use MTY::RegExp::Blocks;
use MTY::RegExp::PerlSyntax;
use MTY::Display::ANSIColorREs;
use MTY::Display::Colorize;
use MTY::Display::ColorizeErrorsAndWarnings;
use MTY::Display::PrintableSymbols;
use MTY::Display::PrintableSymbolTools;
use MTY::Display::Tree;
use MTY::Display::Table;
use MTY::Display::TextInABox;
use MTY::Filesystem::Files;
use MTY::Filesystem::ProcFS;
use MTY::System::POSIX qw(INT_MAX);

use re qw(is_regexp regexp_pattern regnames);
use Hash::Util qw(bucket_info bucket_stats bucket_array hashref_locked hidden_ref_keys legal_ref_keys hash_value hash_seed hash_traversal_mask);
use Sub::Identify qw(:all);
#pragma end_of_includes

preserve:; our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(format_data_as_tree format_data print_data pp);

use constant {
  light_bg_color => bg_color_rgb(32, 32, 32),
  visited_light_bg_color => bg_color_rgb(32, 32, 32), # bg_color_rgb(48, 0, 0),
  referenced_light_bg_color => bg_color_rgb(32, 64, 32),

  # fg_color_rgb(255, 192, 140)
  visited_counter_color => ORANGE,
  visited_addr_color => fg_color_rgb(255, 160, 0),

  referenced_counter_color => fg_color_rgb(180, 255, 0), # fg_color_rgb(255, 192, 150),
  referenced_addr_color => fg_color_rgb(180, 255, 0), # fg_color_rgb(216, 180, 140),

  normal_tree_branch_color => fg_color_rgb(96, 32, 128), # fg_color_rgb(148, 85, 255),
  ref_tree_branch_color => fg_color_rgb(236, 64, 112),

  at_sign_color => fg_color_rgb(128, 128, 128),
  referenced_at_sign_color => fg_color_rgb(192, 192, 192),

  undef_addr_color => fg_color_rgb(216, 180, 140),

  vert_separator => X.fg_color_rgb(64, 96, 192).' '.long_narrow_vert_bar.' '.X,

  undef_color => fg_color_rgb(248, 96, 80), # fg_color_rgb(224, 80, 32),

  top_level_variable_name_color => fg_color_rgb(80, 255, 144), # fg_color_rgb(170, 192, 255),

  scalar_color => fg_color_rgb(255, 64, 160), #fg_color_rgb(170, 154, 255),
  string_color => fg_color_rgb(80, 192, 255),
  scalar_string_dual_color => fg_color_rgb(206, 158, 255), #fg_color_rgb(167, 128, 207),
  dual_color => fg_color_rgb(206, 158, 255), #fg_color_rgb(0, 255, 160), # fg_color_rgb(88, 240, 184), # blend between green and cyan
  glob_color => fg_color_rgb(255, 128, 64),

# fg_color_rgb(255, 160, 0) ORANGE
  ref_color => fg_color_rgb(255, 116, 170), # PURPLE_RED # fg_color_rgb(255, 144, 144)  # PINK
#  array_color => fg_color_rgb(255, 255, 64), # YELLOW
  array_color => fg_color_rgb(255, 255, 64), # YELLOW

#  hash_color > fg_color_rgb(255, 116, 170), # PURPLE_RED
#  hash_color > fg_color_rgb(255, 144, 144), # PINK or PURPLE
    #hash_color > fg_color_rgb(224, 204, 255), # LIGHTBLUE / PURPLE
#  hash_color => fg_color_rgb(66, 222, 119), #fg_color_rgb(64, 255, 128),
#  hash_color => fg_color_rgb(92, 216, 255), #fg_color_rgb(64, 255, 128),
#  hash_color => fg_color_rgb(92, 216, 255), #fg_color_rgb(64, 255, 128),
#  hash_color => fg_color_rgb(255, 128, 0), #fg_color_rgb(64, 255, 128),
#  hash_color => fg_color_rgb(60, 228, 200), #fg_color_rgb(64, 255, 128),
  hash_color => fg_color_rgb(80, 192, 172), #fg_color_rgb(64, 255, 128),

   hash_arrow_color => fg_color_rgb(48, 216, 140),
};

use constant {
  dark_bg_color => scale_rgb_bg(light_bg_color, RATIO_2_3),
  visited_dark_bg_color => scale_rgb_bg(visited_light_bg_color, RATIO_2_3),
  referenced_dark_bg_color => scale_rgb_bg(referenced_light_bg_color, RATIO_2_3),

  normal_counter_color => scale_rgb_fg(fg_color_rgb(160, 255, 0), 0.4), #fg_color_rgb(128, 192, 160),
  normal_addr_color => scale_rgb_fg(visited_addr_color, 0.5), # fg_color_rgb(120, 160, 192), # fg_color_rgb(140, 180, 216),

  # visited_at_sign_color => scale_rgb_fg(at_sign_color, RATIO_1_2),
  # visited_addr_color => scale_rgb_fg(normal_addr_color, RATIO_1_2),

  visited_tree_branch_color => scale_rgb_fg(normal_tree_branch_color, RATIO_3_4),

  referenced_counter_medium_color => scale_rgb_fg(referenced_counter_color, RATIO_2_3),
  referenced_counter_dark_color => scale_rgb_fg(referenced_counter_color, RATIO_1_2),

  top_level_variable_name_dark_color => scale_rgb_fg(top_level_variable_name_color, RATIO_2_3),

  scalar_dark_color => scale_rgb_fg(scalar_color, RATIO_2_3),
  string_dark_color => scale_rgb_fg(string_color, RATIO_2_3),
  scalar_string_dual_dark_color => scale_rgb_fg(scalar_string_dual_color, RATIO_2_3),
  dual_dark_color => scale_rgb_fg(dual_color, RATIO_2_3),
  glob_dark_color => scale_rgb_fg(glob_color, RATIO_2_3),
  ref_dark_color => scale_rgb_fg(ref_color, RATIO_2_3),
  array_dark_color => scale_rgb_fg(array_color, RATIO_1_2),
  hash_dark_color => scale_rgb_fg(hash_color, RATIO_1_2),
};

use constant {
  # hash_arrow => hash_arrow_color.' '.dashed_horiz_bar_2_dashes.large_arrow_barbed.' ',
  hash_arrow => scale_rgb_fg(hash_arrow_color, RATIO_2_3).' '.dashed_horiz_bar_2_dashes.hash_arrow_color.arrow_barbed.nbsp, #' ',

  three_left_warning_brackets => 
    fg_color_rgb(128, 64, 0).bold_left_angle_bracket.
    fg_color_rgb(192, 96, 0).alt_bold_left_angle_bracket.
    fg_color_rgb(255, 128,0).extra_bold_left_angle_bracket,
  
  three_right_warning_brackets => 
    fg_color_rgb(255, 128,0).extra_bold_right_angle_bracket.
    fg_color_rgb(192, 96, 0).alt_bold_right_angle_bracket.
    fg_color_rgb(128, 64, 0).bold_right_angle_bracket
};

use constant {
  tree_branch_style => 'rounded',
};

use constant {
  normal_color_and_symbol_prefix_tree_cmd => [ 
    TREE_CMD_PREFIX, 
    light_bg_color.normal_counter_color.' '.' '.' ',
    dark_bg_color.normal_counter_color.' '.' '.' ',
  ],

  visited_color_and_symbol_prefix_tree_cmd => [
    TREE_CMD_PREFIX, 
    visited_light_bg_color.visited_counter_color.' '.left_arrow_open_tri.' ',
    visited_dark_bg_color.visited_counter_color.' '.left_arrow_open_tri.' ',
  ],

  referenced_color_and_symbol_prefix_tree_cmd => [
    TREE_CMD_PREFIX, 
    referenced_light_bg_color.referenced_counter_color.' '.arrow_tri.' ',
    referenced_dark_bg_color.referenced_counter_color.' '.arrow_tri.' ',
  ],

  root_color_and_symbol_prefix_tree_cmd => [
    TREE_CMD_PREFIX, 
    bg_color_rgb(16, 40, 92).LIGHTBLUE.' '.large_square_root_symbol.LIGHTBLUE_3_4,
  ],

  visited_branch_color_tree_cmd => [
    TREE_CMD_SUB_BRANCH_COLOR, visited_tree_branch_color ],

  normal_branch_style_tree_cmd =>
    [ TREE_CMD_SUB_BRANCH_STYLE, tree_branch_style ],

  object_branch_style_tree_cmd => 
    [ TREE_CMD_SUB_BRANCH_STYLE, 'thick' ],

  visited_branch_style_tree_cmd =>
    [ TREE_CMD_SUB_BRANCH_STYLE, tree_branch_style ],

  visited_branch_dashed_tree_cmd =>
    [ TREE_CMD_BRANCH_DASHED, 1 ],

  ref_branch_style_tree_cmd => 
    [ TREE_CMD_SUB_BRANCH_STYLE, tree_branch_style ],

  vert_separator_prefix_tree_cmd =>
    [ TREE_CMD_PREFIX, vert_separator ],
};

use constant {
  scalar_type_tree_symbol => G.large_pound_sign,
  string_type_tree_symbol => C.large_dollar_sign,
  dual_type_tree_symbol => dual_color.yin_yang,
  ref_type_tree_symbol => ref_dark_color.'\\'.ref_color.large_arrow_barbed, #.X.'\\',
  array_type_tree_symbol => array_color.large_at_sign,
  hash_type_tree_symbol => hash_color.large_percent_sign,
  code_type_tree_symbol => W_3_4.large_ampersand_sign,
  regexp_type_tree_symbol => PINK.rx_symbol,
};

my @type_to_symbol = (
  undef_color.box_with_right_slash,  # UNDEF
  scalar_type_tree_symbol,  # SCALAR
  string_type_tree_symbol,  # STRING
  dual_type_tree_symbol.' ',  # DUAL
  ref_type_tree_symbol,  # REF_REF
  ref_type_tree_symbol,  # SCALAR_REF
  ref_type_tree_symbol,  # STRING_REF
  ref_type_tree_symbol,  # DUAL_REF
  array_type_tree_symbol,  # ARRAY_REF
  hash_type_tree_symbol,  # HASH_REF
  code_type_tree_symbol,  # CODE_REF
  regexp_type_tree_symbol.' ',  # REGEXP_REF
  M.asterisk.' ',  # BLESSED_REF
  K.large_asterisk,  # GLOB_REF
  ORANGE.roman_numeral_l,  # LVALUE_REF
  B.deg_f,  # FORMAT_REF
  M.'IO',  # IO_REF
  G.roman_numeral_v,  # VSTRING_REF
);

my @type_to_symbol_tree_cmd = map { [ TREE_CMD_SYMBOL, $_ ] } @type_to_symbol;

my @type_to_visited_symbol_tree_cmd = map {
  [ TREE_CMD_SYMBOL, scale_rgb_fg_in_string($_->[1], RATIO_2_3) ];
} (@type_to_symbol_tree_cmd);

#
# These are the colors of the *sub-branches* of the specified type of node,
# so if the node has no sub-nodes, this color will never be used (as is the
# case with scalars, except for references).
#
my @type_to_branch_color_tree_cmd = map { [ TREE_CMD_SUB_BRANCH_COLOR, $_ ] } (
  ((undef) x 4), # UNDEF SCALAR STRING DUAL
  ref_color, # REF_REF
  ((ref_color) x 3), # SCALAR_REF STRING_REF DUAL_REF
  array_dark_color,  # ARRAY_REF
  hash_dark_color,  # HASH_REF
  K_2_3,  # CODE_REF
  PINK_2_3.rx_symbol,  # REGEXP_REF
  W_2_3,  # BLESSED_REF
  K_2_3,  # GLOB_REF
  ORANGE_2_3,  # LVALUE_REF
  B_2_3,  # FORMAT_REF
  M_2_3,  # IO_REF
  G_2_3,  # VSTRING_REF
);

my @type_to_branch_style_tree_cmd = 
  map { (defined $_) ? [ TREE_CMD_SUB_BRANCH_STYLE, $_ ] : $_ } sparse_array(
    DUAL, 'double',
    HASH_REF, 'double',
    ARRAY_REF, 'rounded',
    CODE_REF, 'thick'
  );

my @type_to_visited_branch_color_tree_cmd = map { [ 
    TREE_CMD_BRANCH_COLOR, 
    scale_rgb_fg($_->[1] // normal_tree_branch_color, RATIO_1_2) 
  ] } (@type_to_branch_color_tree_cmd);

# These bitmasks go in the flags field of the context array:
noexport:; use constant enumbits (
  DDS_OPTION_SINGLE_LINE,
  DDS_OPTION_SHOW_ADDRESSES,
  DDS_OPTION_STRIP_ANSI_CONSOLE_STRINGS,
  DDS_OPTION_STRIP_UNICODE_STRINGS,
  DDS_OPTION_READ_SOURCE_TO_MAKE_TITLE_FOR_CALLER,
  DDS_OPTION_ALWAYS_PRINT_CALLER,
  DDS_OPTION_HASH_DETAILS,
  DDS_OPTION_EXTENSIVE_HASH_DETAILS,
);

noexport:; use constant {
  FORMAT_REF_PREFIX => '\\',
};

my %depth_warning_text_for_depth = ( );

sub get_exceeded_max_depth_warning($) {
  my ($max_depth) = @_;
        
  my $text = $depth_warning_text_for_depth->{$max_depth};
  return $text if (defined $text);

  $text = 
    three_left_warning_brackets.
    Y.' '.warning_sign.' '.U.
    'WARNING:'.UX.' '.
    R.'Excessive depth of '.ORANGE.$max_depth.' '.
    three_right_warning_brackets;

  $depth_warning_text_for_depth->{$max_depth} = $text;
  return $text;
}

# In case we're missing the Sub::Identify package:
sub dummy_sub_fullname {
  my ($sub) = @_;
  sprintf('&0x%x', refaddr($sub));
}

#
# These are the elements in the @context array ref that's passed to each
# recursive invocation of format_xxx() handlers as well as format_anything().
#
# Each field listed below contains global data or references that remain
# constant throughout the recursion and thus would be wasteful to repeatedly
# push onto the stack.
#
# The visited, next_index, index_to_tree_node, index_ref_counts, etc. fields
# are references to the tracking arrays and hashes used to detect cycles and
# previously seen data references. Technically these structures *are* updated
# during recursion, although the references to them remain constant, except
# for the next_index field that's a normal integer which must be unique for
# all nodes in the data graph.
#
# The remaining fields correspond to the options external top-level callers
# can request to control the appearance of the output.
#
# Actual function call parameters are used for all other purposes where the
# values should be propagated down a branch, but parallel branches should use
# the original values passed by the caller earlier on the recursion stack.
#

noexport:; use constant enum 
  qw(visited next_index index_to_tree_node index_ref_counts highest_ref_count highest_level 
     flags max_depth one_line_array_max_length one_line_hash_max_length
     max_string_length max_subtree_items);

my $quotes_required_re = qr{[\s\,\x00-\x1F\x7F-\xFF]}oamsx;

#my $ansi_console_codes_placeholder = R.double_left_angle_bracket.Y.euler_e.R.double_right_angle_bracket.C;
my $ansi_console_codes_placeholder = ORANGE.U.euler_e.UX.C;

sub format_clipped_string($;$$$$$$) {
  my ($s, $max_length, $subst_control_chars, $show_quotes, $color, $sym_color, $quote_color) = @_;

  $max_length //= INT_MAX;
  $subst_control_chars //= 1;

  $show_quotes //= ($s =~ $quotes_required_re);
  $color //= C;
  $sym_color //= R;
  $quote_color //= scale_rgb_fg($color, 0.5);

  my $from_end = ($max_length < 0);
  $max_length = -$max_length if ($max_length < 0);

  my $orig_length = length($s);
  if ($orig_length > $max_length) {
    $s = substr($s, ($from_end) ?
               max(($orig_length - $max_length), 0) : 0,
               min($max_length, $orig_length));
  }

  my $esc_code_repl = euler_e;
  $s =~ s{$ansi_console_escape_codes_re}{$esc_code_repl}oamsxg;

  if ($subst_control_chars)
    { $s = special_chars_to_printable_symbols($s, $color, $sym_color); }

  $s =~ s{$esc_code_repl}{$ansi_console_codes_placeholder}oamsxg;

  my $lq = ($show_quotes) ? $quote_color.left_quote : '';
  my $rq = ($show_quotes) ? $quote_color.right_quote : '';

  return $lq.$color.$s.$quote_color.
    (($orig_length > $max_length) ? elipsis_three_dots : '').$rq.X;
}

sub format_scalar_as_text(+$;$$$) {
  my ($obj, $type, $max_string_length, $show_quotes, $condense_duals) = @_;
  $type //= UNDEF;
  $max_string_length //= INT_MAX;
  $condense_duals //= 0;

  my $readonly = is_read_only($_[0]);
  my $tainted = is_tainted($_[0]);

  my $scalar; my $string;
  ($scalar, $string) = split_dual($obj) if ($type == DUAL);

  my $text = 
    (($type == UNDEF) ? (undef_color.x_signed.' undef ') :
    ($type == SCALAR) ? (scalar_color.$obj) :
      ($type == STRING) ? format_clipped_string("$obj", $max_string_length, 1, $show_quotes, string_color, PURPLE, string_dark_color) :
    ($type == DUAL) ? (($condense_duals)
       ? (("$scalar" eq "$string") ? (scalar_string_dual_color.$scalar) :
         (scalar_color.$scalar.scalar_string_dual_color.large_right_slash.
         format_clipped_string($string, $max_string_length, 1, $show_quotes, string_color, PURPLE, string_dark_color))
       ) : (scalar_color.$scalar.scalar_string_dual_color.' '.large_right_slash.' '.
         format_clipped_string($string, $max_string_length, 1, $show_quotes, string_color, PURPLE, string_dark_color))
      ) :
      (R.'UNKNOWN('.reftype($obj).', typeid '.$type.')'));

  if ($readonly) { 
    $text = blend_and_scale_rgb_fg_in_string($text, [0, 0, 255], 1, RATIO_1_3).
      R_3_4.' '.o_with_skewed_slash.' '.B.'read only'.B_2_3; # three_vert_bars
  } elsif ($tainted) {
    $text = blend_and_scale_rgb_fg_in_string($text, [255, 128, 0], 1, RATIO_1_3).
      R_2_3.' ('.ORANGE.warning_sign.' '.U.'tainted'.UX.R_2_3.')';
  }

  return $text;
}

sub format_scalar(+++$$) {
  my ($obj, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  push @$label, format_scalar_as_text($_[0], $type // undef, $context->[max_string_length], 1);
  return $node;
}

my @scalar_ref_type_names = (
  'undef', 'scalar', 'string', 'dual',
  'ref', 'scalar', 'string', 'dual',
);

sub format_scalar_ref(+++$$) {
  my ($ref, $node, $context, $level, $type) = @_;
  alias my $obj = ${$ref};
  my $label = $node->[0];

  push @$label, ref_dark_color.'ref to '.ref_color.'\\'.U.$scalar_ref_type_names[$type].UX;
  push @$node, format_anything(((is_glob $obj) ? \$obj : $obj), $node, $context, $level+1);
  return $node;
}

sub format_array(+++$$) {
  my ($array, $node, $context, $level, $type) = @_;

  my $label = $node->[0];
  my $n = scalar(@$array);
  $type = ($n > 0) ? typeof($array->[0]) : UNDEF;

  push @$label, array_color.U.'array'.UX.array_dark_color.wide_left_square_bracket.
    array_dark_color.'#'.array_color.$n.array_dark_color.wide_right_square_bracket.'=';

  my $show_on_one_line = ($context->[flags] & DDS_OPTION_SINGLE_LINE) || 
    (($n < ($context->[one_line_array_max_length] // 0)) && (all { !ref } @$array));
  my $show_as_qw = $show_on_one_line && ($n > 0) && (all { (defined $_) && ($_ =~ /\A $perl_identifier_re \Z/oamsx) } @$array);
  my $show_quotes = $show_on_one_line && ($n > 0) && (any { (!defined $_) || ($_ =~ /$quotes_required_re/oamsx) || (length > 40) || (!length) } @$array);

  if ($show_as_qw) {
    push @$label, C_3_4.' qw'.C_2_3.round_bold_left_paren.C.
      join(' ', @$array).C_2_3.round_bold_right_paren.X;
  } elsif ($show_on_one_line) {
    push @$label, array_dark_color.wide_left_square_bracket.X.
      join(K.', '.X, (map { format_scalar_as_text($_, typeof($_), $context->[max_string_length], $show_quotes, 1) } @$array)).
      array_dark_color.wide_right_square_bracket.X;
  } else {
    for my $i (0..$#{$array}) {
      my $formatted_key = array_dark_color.'['.array_color.$i.array_dark_color.']'.'  =  ';
      alias my $elem = $array->[$i];
      push @$node, format_anything(((is_glob $elem) ? \$elem : $elem), $node, $context, $level+1, $formatted_key);
    }
  }

  return $node;
}

sub format_hash(+++$$) {
  my ($hash, $node, $context, $level, $type) = @_;
  my $label = $node->[0];
  my $flags = $context->[flags];

  my $n = scalar keys %$hash;

  push @$label, hash_color.U.'hash'.UX.hash_dark_color.
    wide_left_brace.'#'.hash_color.$n.hash_dark_color.
    wide_right_brace.' = ';

  my $show_on_one_line = 
    ($n < ($context->[one_line_hash_max_length] // 0)) && 
    (all { !ref } (values %$hash)) &&
    (!($flags & DDS_OPTION_HASH_DETAILS));

  if ($show_on_one_line) {
    push @$label, hash_dark_color.wide_left_brace.X.
      join(K.', '.X, (pairmap {
        hash_color.$a.fg_color_rgb(255, 0, 0).hash_arrow_color.' '.large_arrow_barbed.' '.X.
          format_scalar_as_text($b, typeof($b), $context->[max_string_length], 1)
      } %$hash)).hash_dark_color.wide_right_brace.X;
  } else {
    my @keys = sort keys %$hash;
    my $longest_key_length = maxlength(@keys);
  
    my @hidden_keys;

    if ($flags & DDS_OPTION_HASH_DETAILS) {
      my $is_locked = hashref_locked($hash);
      my $traversal_order_mask = hash_traversal_mask($hash);
      @hidden_keys = hidden_ref_keys($hash);
      my ($key_count, $bucket_count, $used_bucket_count, @length_histo) = bucket_info($hash);

      my $dark = scale_rgb_fg(hash_color, RATIO_2_3);

      if (defined $key_count) {
        my $info = 
          $dark.'('.hash_color.($is_locked ? U.'locked'.UX.$dark.' hash with ' : '').
            hash_color.$key_count.$dark.' keys'.
            ((@hidden_keys) ? ' ('.hash_color.(scalar @hidden_keys).$dark.' hidden keys)' : '').' using '.
            hash_color.$used_bucket_count.$dark.' of '.
            hash_color.$bucket_count.$dark.' buckets)';
        
        push @$label, $info;
      }
    }
    
    foreach my $key (sort keys %$hash) {
      my $formatted_key = hash_dark_color.'{'.hash_color.$key.hash_dark_color.'}'.K_1_3.
        (bullet_small x ($longest_key_length - (length $key))).hash_arrow.X;
      alias my $elem = $hash->{$key};
      push @$node, format_anything(((is_glob $elem) ? \$elem : $elem), $node, $context, $level+1, $formatted_key);
    }

    foreach my $key (sort @hidden_keys) {
      my $formatted_key = hash_dark_color.'{'.hash_dark_color.$key.hash_dark_color.'}'.K_1_3.
        (bullet_small x ($longest_key_length - (length $key))).' '.hash_color.'(hidden locked key)'.X;
    }
  }

  return $node;
}

sub format_code(+++$$) {
  my ($code, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  my $addr = hexstring(refaddr($code));
  my $name = sub_fullname($code) // ('<unknown @ '.$addr.'>');
  my $show_addr = ($name eq '__ANON__') || ($name eq '<unknown>');
  my $proto = prototype($code);

  push @$label, ORANGE_3_4.'sub '.ORANGE.U.$name.UX;
  push @$label, ORANGE_1_2.'('.ORANGE.$proto.ORANGE_1_2.')' if (defined $proto);
  push @$label, ORANGE_2_3.' @ '.ORANGE.$addr if ($show_addr);
  push @$label, ORANGE_1_2.' '.bold_left_brace.' '.K.elipsis_three_dots.ORANGE_1_2.' '.bold_right_brace.X;

  return $node;
}

my $regexp_comment_re = qr{(?<! \\) \# \N*+ \n}oamsx;

noexport:; sub colorize_regexp_text(+) {
  my ($re) = @_;

  my ($pattern, $modifiers) = ((is_regexp $re) ? regexp_pattern($re) : ("$re", ''));

  $pattern = $pattern
    =~ s{(\[[^\]]+\])}{$R$1$X}roamsxg
    =~ s{\\ (.)}{$K\\$M$1}roamsxg
    =~ s{(?= $regexp_comment_re)}{$K}roamsxg
    =~ s{((?<! \\) \( \? . | (?<! \\) \))}{$B$1$X}roamsxg
    =~ s{((?<! \\) \( (?! \?))}{$C$1$X}roamsxg
    =~ s{\\ (?! \w)}{$K\\$X}roamsxg
    =~ s{\|}{$R\|$X}roamsxg
    =~ s{\]}{$R]}roamsxg
    =~ s{((?<! \() [\+\*\?] | $braces_re)}{$Y$1$X}roamsxg;

  return ORANGE.'qr'.ORANGE_3_4.large_right_slash.X.$pattern.X.
    ORANGE_3_4.large_right_slash.ORANGE.$modifiers;
}

sub format_regexp(+++$$) {
  my ($regexp, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  push @$label, ORANGE.U.'regexp'.UX.ORANGE_1_2.' = '; 
  # ORANGE.'qr'.ORANGE_3_4.large_right_slash.K.' '.elipsis_three_dots.' '.ORANGE_3_4.large_right_slash.X;

  my $text = colorize_regexp_text($regexp);
  push @$label, $text;

  return $node;
}

sub format_blessed(+++$$) {
  my ($obj, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  my $class = classof($obj);
  push @$label, C_3_4.'class '.C.U.$class.UX.C_3_4.' = ';

  return $node;
}

sub format_glob(+++$$) {
  my ($glob, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  my @slots = get_glob_slots($_[0]);

  my %slots = ( );
  while (my ($typeid, $slot) = each @slots) 
    { $slots{$typeid} = \$slot if (defined $slot); }

  push @$label, glob_color.U.'glob'.UX.glob_dark_color.' with slots ', glob_color.join(' ', map { $typeid_to_string[$_] =~ s{_REF}{}roaxg } (sort keys %slots));

  while (my ($typeid, $slot) = each @slots) {
    my $key = $typeid_to_string[$typeid] // "UNKNOWN";
    my $formatted_key = glob_dark_color.'{'.glob_color.$key.glob_dark_color.'}'.K_1_3.
      (bullet_small x (16 - (length $key))).hash_arrow.X;
    # push @$node, format_anything(((is_glob $slot) ? \$slot : $slot), $node, $context, $level+1, $formatted_key);
  }

  return $node;
}

sub format_lvalue(+++$$) {
  my ($lvalue, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  push @$label, ORANGE.U.'lvalue'.UX;

  return $node;
}

sub format_format(+++$$) {
  my ($format, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  push @$label, B.U.'format'.UX;

  return $node;
}

sub format_io_ref(+++$$) {
  my ($io, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  my $fd = fileno($io);
  my $filename = (defined $fd) ? path_of_open_fd($fd) : undef;

  my $text = M.U.'I/O'.UX;
  $text .= M_2_3.': fd '.M.$fd if (defined $fd);
  $text .= M_2_3.' '.M.large_arrow_barbed.M_2_3.' path '.M.$filename if (defined $filename);
  push @$label, $text;

  return $node;
}

sub format_vstring(+++$$) {
  my ($vstring, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  push @$label, G.U.'vstring'.UX.G_1_2.' = '.G.$vstring;

  return $node;
}

my @type_to_format_func = (
  \&format_scalar,  # UNDEF
  \&format_scalar,  # SCALAR
  \&format_scalar,  # STRING
  \&format_scalar,  # DUAL
  \&format_scalar_ref,  # REF_REF
  \&format_scalar_ref,  # SCALAR_REF
  \&format_scalar_ref,  # STRING_REF
  \&format_scalar_ref,  # DUAL_REF
  \&format_array,  # ARRAY_REF
  \&format_hash,  # HASH_REF
  \&format_code,  # CODE_REF
  \&format_regexp,  # REGEXP_REF
  \&format_blessed,  # BLESSED_REF
  \&format_glob,  # GLOB_REF
  \&format_lvalue_ref,  # LVALUE_REF
  \&format_format_ref,  # FORMAT_REF
  \&format_io_ref,  # IO_REF
  \&format_vstring_ref,  # VSTRING_REF
);

use constant enum (
  TYPE_CATEGORY_SCALAR,    # undef, number, string, dual
  TYPE_CATEGORY_SCALAR_REF,# ref to scalar
  TYPE_CATEGORY_REF_REF,   # ref to ref
  TYPE_CATEGORY_CONTAINER, # ref to array or hash
  TYPE_CATEGORY_CODE,      # ref to code block or sub
  TYPE_CATEGORY_SPECIAL,   # ref to regexp, object, glob, lvalue, format, io, vstring
);

my @type_to_category = (
  (TYPE_CATEGORY_SCALAR) x 4,
  TYPE_CATEGORY_REF_REF,
  (TYPE_CATEGORY_SCALAR_REF) x 3,
  TYPE_CATEGORY_CONTAINER,
  TYPE_CATEGORY_CONTAINER,
  TYPE_CATEGORY_CODE,
  (TYPE_CATEGORY_SPECIAL) x 7,
);

#
# format_anything() is the first function called to start the recursive 
# traversal of a data structure graph, and is also called by the type-
# specific handler functions (format_xxx()) to continue recursively
# processing each item within container types (arrays, hashes, classes
# and references to scalars or refs). All other data types are terminal
# nodes bounding the edges of the graph.
#
# This function essentially creates a new tree node, fills out the
# first portion of its label with generic type agnostic information
# (like the per-line index and address prefix columns, etc.), then
# invokes one of the format_xxx() handler functions (listed in the
# @type_to_format_func dispatching array) to finish preparing the
# tree node. 
#
# Both this function and all the handlers take a single reference
# argument pointing to a context array (see comments above for
# the various constant names of each array item).
#
# For container data types, the handler function may either add
# sub-nodes to the tree node on its own (simple cases only), or 
# for each item within the container, it calls format_anything()
# to descend the graph and dispatch the correct handler.
#
# Handler functions may pass a string in the $formatted_key
# argument, which format_anything() will add to the tree node
# before calling any handlers. This is used to annotate each
# item in an array or hash with its index or key, independent
# of the actual data type of that item.
#
sub format_anything { # (+++$;$$;$)
  my ($copy_of_obj, $parent_node, $context, $level, $formatted_key) = @_;
  alias my $obj = $_[0];

  my ($visited, $next_index, $index_to_tree_node, $index_ref_counts, $highest_ref_count, $highest_level, $flags, $max_depth) = @$context;

  my $type = unblessed_typeof($_[0]) // UNDEF;
  my $category = $type_to_category[$type];
  my $is_ref = is_ref($_[0]);

  my $class = classof($obj);

  if ($level > $highest_level) { $context->[highest_level] = $highest_level; }

  #
  # Construct the initial generic parts of the tree node,
  # and then call the type specific handler to finish it;
  # these handlers may recurse into format_anything() for
  # nested data structures like arrays, hashes and refs.
  #
  my $addr = (defined $_[0]) ? (($is_ref) ? Scalar::Util::refaddr($_[0]) : 
                                  Scalar::Util::refaddr(\$_[0])) : 0;

  my $repeat = ($is_ref && (exists $visited->{$addr})) ? 1 : 0;

  # If we already visited this object, use the counter we already assigned it;
  # otherwise assign it the current counter and then increment the counter:
  my $index = ($repeat) ? $visited->{$addr} : $context->[next_index]++;

  my $addr_color = ($repeat) ? visited_addr_color : normal_addr_color;

  my $label = [
    ($repeat ? visited_color_and_symbol_prefix_tree_cmd : normal_color_and_symbol_prefix_tree_cmd),
    [ 
      TREE_CMD_PREFIX,
      padstring($index, -5).' '.($show_addresses ? $addr_color : X),
    ],
    ($show_addresses ? [
      TREE_CMD_PREFIX,
      (($addr) ? sprintf('% 12x', $addr) : (R_3_4.(' ' x 6).x_signed.' null')).' '.X,
    ] : ( )),
    # vert_separator_prefix_tree_cmd,
    (($repeat) ? ( ) : 
       ($type_to_branch_color_tree_cmd[$type] // '')),
    (($repeat) ? visited_branch_style_tree_cmd : 
       (defined $class) ? object_branch_style_tree_cmd :
       ($type_to_branch_style_tree_cmd[$type] // 
        ($is_ref ? ref_branch_style_tree_cmd : normal_branch_style_tree_cmd))),
    (($repeat) ? visited_branch_dashed_tree_cmd : ( )),
    (($repeat) ? $type_to_visited_symbol_tree_cmd[(defined $class) ? BLESSED_REF : $type] :
       $type_to_symbol_tree_cmd[(defined $class) ? BLESSED_REF : $type]),
  ];

  if ($level == 0) {
    # Global settings that will be propagated down all sub-branches:
    push @$label, [ TREE_CMD_HORIZ_BRANCH_LENGTH, 2 ];

    my $per_line_prefix_length = 3 + # for referenced / backlink indicator
      5 + # for unique index counter number
      (($flags & DDS_OPTION_SHOW_ADDRESSES) ? 12 : 0) + # for address (if enabled)
      1 + 16; # for the spacer column before the branches + 4+ levels deep
    push @$label, [ 
      TREE_CMD_MAX_FIELD_WIDTH, 
      get_terminal_width_in_columns() - $per_line_prefix_length, 0 ];
  }

  if (defined $formatted_key) {
    push @$label, 
      ((is_array_ref $formatted_key) ? @$formatted_key : 
         ($repeat ? scale_rgb_fg_in_string($formatted_key, RATIO_2_3) : $formatted_key)),
  }

  if (defined $class) {
    push @$label, ORANGE_3_4.double_left_angle_bracket.
      ORANGE.'class '.Y.U.$class.UX.
        ORANGE_3_4.double_right_angle_bracket.' ';
  }

  my $node = [ $label ];

  if ($repeat) {
    my $refcount = ++$index_ref_counts->[$index];
    set_max($context->[highest_ref_count], $refcount);
    push @$label,
      ORANGE_2_3.' '.double_left_angle_bracket.ORANGE.counterclockwise_curved_arrow.
        ' '.ORANGE_2_3.'same as '.referenced_counter_medium_color.sharp_sign.
        referenced_counter_color.$index.ORANGE_2_3.double_right_angle_bracket.' ',
        visited_branch_color_tree_cmd;

    return $node;
  }

  if ($addr) {
    $visited->{$addr} = $index; 
    $index_to_tree_node->[$index] = $node;
  }

  if ($level >= $max_depth) {
    push @$label, get_exceeded_max_depth_warning($max_depth);
  } else {
    my $func = $type_to_format_func[$type];
    $node = $func->($obj, $node, $context, $level, $type);
  }

  return $node;
}

my @ref_type_index_to_description = (
  'Undefined value', 'Numeric scalar value', 'String', 'Dual scalar/string',
  'Reference to reference', 'Reference to numeric scalar value', 'Reference to string', 'Reference to dual scalar/string',
  'Array', 'Hash', 'Code block or subroutine', 'Regular expression',
  'Object of class', 'Typeglob', 'L-value', 'Format',
  'I/O object', 'Version string', 'Unknown type'
);

my @type_short_name = (
  'undef', 'scalar', 'string', 'dual',
  'dual', 'scalar', 'string', 'dual',
  'array', 'hash', 'code', 'regexp',
  'object', 'glob', 'lvalue', 'format',
  'io', 'version', 'unknown'
);

my $source_code_lines_cache;

noexport:; sub fill_source_code_lines_cache(+$) {
  my ($cache, $filename) = @_;

  my $lines = read_file_as_lines($filename);

  if (!defined $lines) {
    warning(U.'DataStructures:'.UX.' Could not read source file ', 
            format_quoted($filename), R.' to determine the original '.
            'symbolic variable name of an object to print');
  }

  return $lines;
}

my $call_to_format_data_structure_func_re = 
  qr{\b ( (?> (?> format|print)_data (?>_as_tree)?) |   # capture group $1 
       pp | dds | enhanced_format_printable_data ) \b
     (?> (?> \s*+ \( ) | \s++)   # handle function call both with and without parens
     (                           # $2 = everything in the first argument (i.e. the target to print)
       (?>
         [^\,\;\(\)\{\}\[\]\'\"] | 
         $nested_parens_braces_brackets_quoted_re
       )++
     )
     [\,\)\;]    # ...and remaining arguments we don't need for this regexp (i.e. $title and %options) 
  }oax;

my $prev_caller_filename = undef;
my $prev_caller_line = undef;
my $prev_caller_pos_in_line = 0;

my $lines_to_eval_from_perl_command_line = undef;

noexport:; sub get_lines_to_eval_from_perl_command_line() {
  return $lines_to_eval_from_perl_command_line if 
    (defined $lines_to_eval_from_perl_command_line);

  my $args //= (read_proc_cmdline() // [ ]);

  my $next_arg_is_eval_code = 0;
  $lines_to_eval_from_perl_command_line = [ grep {
    if ($next_arg_is_eval_code) { $next_arg_is_eval_code = 0; 1; }
    elsif ($_ eq '-e') { $next_arg_is_eval_code = 1; 0; }
    else { 0; }
  } @$args ];

  return $lines_to_eval_from_perl_command_line;
}

noexport:; sub get_eval_code($) {
  my ($eval_id) = @_;

  for (my $i = 0; ; $i++) { 
    my @caller = caller($i);
    return undef if (!@caller); 
    my $eval_code = $caller[6];
    return [ $eval_code ] if (defined $eval_code);
  }

  return undef;
}

noexport:; sub format_title_based_on_caller_source_code(+++$$$$$$) {
  my ($obj, $context, $options, $placeholder_id,
      $caller_package, $caller_filename, $caller_line, 
      $caller_function, $caller_eval_code) = @_;

  $source_code_lines_cache //= MTY::Common::Cache->new(
    \&fill_source_code_lines_cache, 'source_code_lines_cache');

  my $source_code_lines = 
    (!defined $caller_filename) ? undef :
    (defined $caller_eval_code) ? [ $caller_eval_code ] :
    ($caller_filename =~ /\(eval/oamsx) ? get_eval_code($caller_filename) :
    ($caller_filename eq '-e') ? get_lines_to_eval_from_perl_command_line() :
    $source_code_lines_cache->get($caller_filename);

  if (!defined $source_code_lines) {
    return X.R.'[could not read source file]'.X;
  }

  if (defined $caller_eval_code) {
    $caller_filename = '<eval>';
    $caller_line = 1;
  }

  #
  # Line numbers provided by caller() start with line 1,
  # but the actual array of lines is obviously zero based,
  # so decrement the effective line number to compensate:
  #
  $caller_line--;

  if (($caller_line < 0) || ($caller_line >= sizeof($source_code_lines))) {
    return X.R.'[line '.ORANGE.$caller_line.R.
      ' is beyond last line ('.ORANGE.sizeof($source_code_lines).R.
        ') of '.Y.$caller_filename.R.']'.X;
  }

  my $line = $source_code_lines->[$caller_line];

  #
  # Properly handle multiple consecutive invocations of pp 
  # on one source line by starting the regexp search at the
  # position where the last invocation's match ended:
  #
  if ((defined $prev_caller_filename) && 
      (defined $prev_caller_line) &&
      (($prev_caller_filename ne $caller_filename) ||
      ($prev_caller_line != $caller_line))) {
    $prev_caller_pos_in_line = 0;
  }

  pos($line) = $prev_caller_pos_in_line;

  $prev_caller_filename = $caller_filename;
  $prev_caller_line = $caller_line;
  
  if ($line =~ /$call_to_format_data_structure_func_re/oaxgc) {
    my ($called_function, $target_to_print) = ($1, $2);
    my $match_pos = $-[0];
    my $end_pos = pos($line);
    $prev_caller_pos_in_line = ($end_pos >= (length $line)) ? 0 : $end_pos;
    return ($target_to_print, $match_pos);
  } else {
    $prev_caller_filename = undef;
    $prev_caller_line = undef;
    $prev_caller_pos_in_line = 0;
    pos($line) = 0;

    return # $base_prefix.$base_title.
      X.R.'[could not extract original target name from source line: '.
      LIGHTBLUE.format_quoted(LIGHTBLUE.$line).R.']'.X;
  }
}

sub format_data_as_tree(+;$%) {
  my ($obj, $title, %options) = @_;

  # Capture our external caller while we're still the direct callee:
  my $caller = $options{caller} // [ caller(0) ];

  my $type = typeof($obj);
  my $description = $ref_type_index_to_description[$type] // 'Unknown type';

  #
  # If this will be the top level invocation of format_anything(),
  # create the structures shared throughout the recursion process,
  # and put references to them into the context structure below:
  #
  my $visited = { };
  my $index_to_tree_node = [ ];
  my $index_ref_counts = [ ];

  $options{max_depth} = 1 if ($options{no_recursion} // 0);
  $options{single_line} = 0 if ($options{multi_line} // 1);

  my $flags = 
    (($options{single_line} // 0) 
       ? DDS_OPTION_SINGLE_LINE : 0) |
    (($options{show_addresses} // 0) 
       ? DDS_OPTION_SHOW_ADDRESSES : 0) |
    (($options{strip_ansi_console_codes} // 1) 
       ? DDS_OPTION_STRIP_ANSI_CONSOLE_STRINGS : 0) |
    (($options{strip_unicode} // 0) 
       ? DDS_OPTION_STRIP_UNICODE_STRINGS : 0) |
    (($options{read_line_from_source_to_create_title} // 1) 
       ? DDS_OPTION_READ_SOURCE_TO_MAKE_TITLE_FOR_CALLER : 0) |
    (($options{always_print_caller} // 1) 
       ? DDS_OPTION_ALWAYS_PRINT_CALLER : 0) |
    (($options{hash_details} // 1) 
       ? DDS_OPTION_HASH_DETAILS : 0) |
    (($options{extensive_hash_details} // 1) 
       ? DDS_OPTION_EXTENSIVE_HASH_DETAILS : 0);

  #
  # Note that $context->[next_index] (i.e. the "0" initial value at index #1
  # of the context array below) will always refer to the index counter
  # declared below by the top level call of the recursive descent tree,
  # so it can be incremented globally (w.r.t. the present op-level traversal
  # operation) and yields a unique monotonically incremented value every time.
  #
  # The highest_level field (the "0" at index #5 of the context) is likewise
  # globally set to the highest level the recursion has reached so far.
  #
  my $context = [
    $visited, 0, $index_to_tree_node, $index_ref_counts, 0, 0,
    $flags,
    $options{max_depth} // INT_MAX, 
    $options{one_line_array_max_length} // 12,
    $options{one_line_hash_max_length} // 6,
    $options{max_string_length} // 80,
    $options{max_subtree_items} // undef,
  ];
  
  my ($caller_package, $caller_filename, $caller_line, $caller_function,
    $caller_has_args, $caller_wants_array, $caller_eval_code) = @$caller;

  my $title_color = top_level_variable_name_color.U;
  my $dark_color = W_2_3;
  my $trailing_text = 
    X.$dark_color.' '.double_left_paren.'from '.G.($caller_function =~ s{\A (?> \w+ ::)*+}{}roamsxg).
      $dark_color.' in '.Y.filename_of($caller_filename).
      $dark_color.' line '.M.$caller_line;
  my $trailing_text_end = $dark_color.double_right_paren.X;
  my $post_title = X.top_level_variable_name_color.' '.arrow_head.' '.X;

  if (defined $title) {
    $title = $title_color.$title.$post_title;
    if (!($flags & DDS_OPTION_ALWAYS_PRINT_CALLER)) { $trailing_text = undef; }
  } else {
    $title = $title_color;
    if ($flags & DDS_OPTION_READ_SOURCE_TO_MAKE_TITLE_FOR_CALLER) {
      my $placeholder_id = $options->{placeholder_id};
      my ($target_name, $source_code_column) = format_title_based_on_caller_source_code(
        $obj, $context, $options, $placeholder_id, $caller_package, 
        $caller_filename, $caller_line, $caller_function, $caller_eval_code);
      $title .= $target_name;
      $trailing_text .= $dark_color.' col '.M.$source_code_column if (defined $source_code_column);
    } else {
      $title .= $trailing_text;
      $trailing_text = undef;
    }

    $title .= $post_title;
  }

  my $tree = format_anything(((is_glob $obj) ? \$obj : $obj), undef, $context, 0, $title);

  #
  # Iterate through all the tree nodes based on their unique counter values,
  # and add a visual indicator and reference count to any nodes that are 
  # referenced from one or more other parts of the data structure. We need
  # to do this *after* we've constructed the entire tree so we're aware of
  # every possible reference.
  #

  my $highest_ref_count = $context->[highest_ref_count];
  my $ref_count_field_width = length("$highest_ref_count");

  $tree->[0]->[0] = root_color_and_symbol_prefix_tree_cmd;

  while (my ($i, $node) = each @$index_to_tree_node) {
    my $count = $index_ref_counts->[$i];
    next if (!$count);

    my $label = $node->[0];
    my ($ref_to_counter, $addr_or_ref_count) = ${$label}[1,2];

    $label->[0] = referenced_color_and_symbol_prefix_tree_cmd if ($i > 0);

    $label->[1] = [ 
      TREE_CMD_PREFIX, 
      padstring($count, $ref_count_field_width).referenced_counter_medium_color.superscript_x,
      padstring($i, -5).' '.($show_addresses ? referenced_addr_color : X)
    ];

    push @$label,
      '  '.referenced_counter_medium_color.double_left_angle_bracket.
        'referenced '.referenced_counter_color.$count.
          referenced_counter_medium_color.small_roman_numeral_x.
          double_right_angle_bracket.X;
  }

  #
  # Adjust the top level root node's label to show various statistics:
  #
  my $root_label = $tree->[0];
  push @$root_label, $trailing_text.$trailing_text_end if (defined $trailing_text);

  #
  # Return the formatted tree structure suitable for pasing to format_tree():
  #
  # In list context, this also returns the total number of tree nodes and the
  # highest level reached by the recursion (which obviously stops whenever
  # it encounters a previously visited node):
  #
  return (wantarray ? ($tree, $context->[next_index], $context->[highest_level]) : $tree);
}

sub format_data(+;$%) {
  my ($obj, $title, %options) = @_;

  # Capture our external caller while we're still the direct callee:
  $options{caller} //= [ caller(0) ];

  my $tree = format_data_as_tree($obj, $title, %options);
  return format_tree($tree);
}

sub print_data(+;$$%) {
  my ($obj, $title, $fd, %options) = @_;

  # Capture our external caller while we're still the direct callee:
  $options{caller} //= [ caller(0) ];

  $fd //= STDOUT;
  my $tree = format_data_as_tree($obj, $title, %options);
  my $text = format_tree($tree);
  printfd($fd, $text);
}

#
# Short name for the equivalent of the print_data() function,
# plus some additional context sensitive intelligence so that
# it will automatically print the formatted tree to STDERR if
# the return value is never used by the caller; otherwise it
# is assumed that the caller will print the returned text.
#
my $tree_output_separator_line = undef;

sub format_gradient_separator_bar(;$$$$$) {
  my ($width, $r, $g, $b, $char) = @_;
  $width //= (get_terminal_width_in_columns() - 2);
  $r //= 80; $g //= 80; $b //= 80; 
  $char //= bottom_edge_horiz_bar;

  my $out = '';
  my $color = fg_color_rgb($r, $g, $b);
  $out .= $color;
  my $granularity = max(int($width / 16), 1);
  my $countdown = $granularity;

  for my $i (0..($width-1)) {
    $countdown--;
    if (!$countdown) {
      no integer;
      my $coeff = ($width - $i) / $width;
      $color = fg_color_rgb(int($r * $coeff), int($g * $coeff), int($b * $coeff));
      $out .= $color;
      use integer;
      $countdown = $granularity;
    }
      
    $out .= $char;
  }

  return $out;
}

sub pp(+;$$%) {
  my ($obj, $title, $fd, %options) = @_;
  my $return_value_used = (defined wantarray);
  
  # Capture our external caller while we're still the direct callee:
  $options{caller} //= [ caller(0) ];

  my $terminal_width = get_terminal_width_in_columns();
  $tree_output_separator_line //=
    fg_color_rgb(28, 70, 160).(bottom_edge_horiz_bar x ($terminal_width / 2)) .
    format_gradient_separator_bar(
      ($terminal_width / 2), 28, 70, 160, bottom_edge_horiz_bar).NL;

  my $tree = format_data_as_tree($obj, $title, %options);
  my $text = $tree_output_separator_line.format_tree($tree);

  if ((!$return_value_used) || (defined $fd)) {
    $fd //= STDERR;
    printfd($fd, $text);
  }

  return $text if ($return_value_used);
}

#
# Use the enhanced colorized printing code in this package instead
# of the default callback function used by printdebug(), printfd()
# and prints() functions when passed arrays, hashes, refs, etc. 
# 
sub enhanced_format_printable_data(+;$$) {
  my ($obj, $print_id, $arg_id, $multi_line) = @_;

  $print_id //= 0;
  $arg_id //= 0;
  $multi_line //= 0;

  $print_id = $print_id + 1; # use #1, #2, #3, etc. labels rather than 0 based

  my $type = typeof($_[0]);

  my $symbol = 
    enclosed_digit($print_id);
#    ORANGE_2_3.double_left_angle_bracket.ORANGE.' '.
#    command_key_symbol.sharp_sign.$print_id.' '.
#    ORANGE_2_3.double_right_angle_bracket;

  my $placeholder = 
    (($print_id == 1) ? LIGHTBLUE.' (see' : '').ORANGE.' '.$symbol.' '.
    (($print_id == 1) ? ' '.LIGHTBLUE.'below) ' : '');

#    $type_to_symbol[$type].U.$type_short_name[$type].UX.
#      (($print_id == 1) ? LIGHTBLUE.' (see ' : ' ').$symbol.
#      (($print_id == 1) ? LIGHTBLUE.' below)' : '');

  my $title = UX.LIGHTBLUE.'(placeholder'.ORANGE.' '.$symbol.' '.LIGHTBLUE.'from above)';

  $placeholder .= X;

  my $after = 
    (($print_id == 1) ? print_folder_tab(
      LIGHTBLUE.'Contents of placeholders above:', LIGHTBLUE_1_2) : '').
    format_data($obj, $title, 
                caller => [ caller(0) ],
                placeholder_id => $print_id, 
                argument_id => $arg_id).NL;

  return ($placeholder, $after);
}

INIT {
  #
  # Install the enhanced colorized printing code in this package
  # in place of the default callback function used by printdebug(),
  # printfd() and prints() for arrays, hashes, refs, etc. 
  # 
  # The printfd and prints functions will only invoke this code 
  # for references to these data types, whereas simple strings and
  # numbers will be printed as is, to keep the caller's intended
  # appearance of the output.
  #

  $MTY::Common::PrintDebug::format_printable_data_callback =
    \&enhanced_format_printable_data;
}

1;
