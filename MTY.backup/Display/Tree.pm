#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Display::Tree
#
# Copyright 2003 - 2015 Matt T. Yourst <yourst@yourst.com>
#
# Print or format hierarchical tree using colors and box drawing characters,
# similar to the style used by MTY::Display::TextInABox. The tree data 
# structure is specified as a recursive set of arrays of references, where
# each array contains:
#
# - [0] = label text to print for this node, as either:
#         - a scalar text string
#         - a reference to an array of text strings intermixed with optional
#           control commands, which are concatenated without separators between
#            them to print the name
#         
#         If an array is used to provide multiple chunks comprising the label,
#         any of the label array elements may contain control commands, either
#         in the preferred form of a reference to another array of the form
#         [ command, arg1, arg2, ... ] (where command is one of the TREE_CMD_xxx
#         constants), or in the equivalent text form "%{command=arg1,...}.
#
#         The [ TREE_CMD_COLUMN, N ] (or "%{column=N}") directive causes the
#         tree printer to continue printing the next chunk after the directive
#         at column N, relative to the leftmost tree branch.
#
#         Specifically, %{column=N} will skip to the same column N regardless
#         of how deeply the tree may be indented at that point, so the output
#         remains properly lined up whether the tree is only one level deep
#         or a hundred levels deep. (In practice, if a given node is already
#         so far indented that its label starts after the column number N
#         specified by %{column=N}, the column directive will be ignored.
#
#         A label array element may also be a special [ TREE_CMD_SYMBOL, X, Y ]
#         or '%{symbol=X,Y}' directive, which overrides that node's default 
#         character symbol (typically a solid right facing triangle for a node 
#         with subnodes, or an empty triangle for a leaf node). The X and Y 
#         parameters may each specify either one (or several) literal characters, 
#         a hex numbered Unicode character code (using e.g. 0xABCD), or a symbol
#         name chosen from amongst the library provided by the PrintableSymbols
#         package. The Y parameter (which specifies the leaf node symbol) is
#         optional; by default both branch and leaf nodes use the same symbol.
#         The %{symbol=X,Y} directive can only be in the same label array 
#         element as one or more color or formatting markups (e.g. %R/%U/%!U);
#         no literal text is allowed (it must be put in a subsequent element).
#
#         If any label array entries end with newlines, subsequent lines of the
#         label will be properly indented to line up with the first line. For
#         multi-line labels, the array format is mandatory, and each line must
#         be in its own array element, terminated by a newline.
#
# - [1, 2, ...] = subnodes (optional) = references to sub-node arrays, in the
#         same format as described herein (with the first element as the label
#         or array of label chunks and/or directives, and the remaining elements
#         containing recursive references to sub-branches.
#

package MTY::Display::Tree;

use integer; use warnings; use Exporter qw(import);

use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Common::Strings;
use MTY::Display::Colorize;
use MTY::Display::ColorCapabilityCheck;
use MTY::Display::ANSIColorREs;
use MTY::Display::PrintableSymbols;
use MTY::Display::PrintableSymbolTools;
use MTY::Display::TextInABox;
use MTY::Display::Table;
use MTY::RegExp::Define;
use MTY::RegExp::Tools;
use MTY::RegExp::Blocks;
use MTY::RegExp::Numeric;
use MTY::RegExp::Strings;
use MTY::RegExp::PerlSyntax;
#pragma end_of_includes

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($tree_branch_color $tree_branch_to_leaf_style $tree_branch_to_node_style
     $tree_horiz_branch_length $tree_horiz_dashed $tree_leading_space
     $tree_leaf_indicator $tree_leaf_indicator_color $tree_node_indicator
     $tree_node_indicator_color $tree_pre_branch_color $tree_pre_branch_spacer
     $tree_root_indicator $tree_root_indicator_color
     $tree_subnode_count_if_no_subnodes $tree_subnode_count_prefix
     $tree_subnode_count_suffix $tree_vert_dashed %tree_command_name_to_id
     %tree_styles BRANCH HORIZ_DASHED HORIZ_LINE LAST_BRANCH NO_BRANCH
     NO_BRANCH_DASHED TREE_CMD_BRANCH_COLOR TREE_CMD_BRANCH_DASHED
     TREE_CMD_BRANCH_STYLE TREE_CMD_COLUMN TREE_CMD_DIV TREE_CMD_FIELD
     TREE_CMD_HORIZ_BRANCH_LENGTH TREE_CMD_IF_EVEN TREE_CMD_IF_ODD
     TREE_CMD_INCLUDE TREE_CMD_LABEL TREE_CMD_MAX_FIELD_WIDTH TREE_CMD_PREFIX
     TREE_CMD_SUBNODE_COUNT TREE_CMD_SUB_BRANCH_COLOR TREE_CMD_BRANCH_SKIP
     TREE_CMD_SUB_BRANCH_DASHED TREE_CMD_SUB_BRANCH_STYLE TREE_CMD_SYMBOL
     format_tree label_of_tree_node print_tree subtree_label subtree_to_text
     tree_to_lines);

#
# Tree node commands (in first element of label array):
#
use constant enum qw(
  TREE_CMD_LABEL
  TREE_CMD_COLUMN
  TREE_CMD_FIELD
  TREE_CMD_MAX_FIELD_WIDTH
  TREE_CMD_SUBNODE_COUNT
  TREE_CMD_PREFIX
  TREE_CMD_IF_EVEN
  TREE_CMD_IF_ODD
  TREE_CMD_SYMBOL
  TREE_CMD_BRANCH_COLOR
  TREE_CMD_BRANCH_STYLE
  TREE_CMD_BRANCH_DASHED
  TREE_CMD_BRANCH_SKIP
  TREE_CMD_SUB_BRANCH_COLOR
  TREE_CMD_SUB_BRANCH_STYLE
  TREE_CMD_SUB_BRANCH_DASHED
  TREE_CMD_HORIZ_BRANCH_LENGTH
  TREE_CMD_DIV
  TREE_CMD_INCLUDE
);

#
# Defaults:
#
our ($tree_branch_to_node_style, $tree_branch_to_leaf_style, $tree_branch_color,
     $tree_node_indicator_color, $tree_leaf_indicator_color, $tree_root_indicator_color,
     $tree_node_indicator, $tree_leaf_indicator, $tree_root_indicator, $tree_horiz_dashed,
     $tree_vert_dashed, $tree_leading_space, $tree_pre_branch_spacer, $tree_pre_branch_color,
     $tree_horiz_branch_length, $tree_subnode_count_prefix, $tree_subnode_count_suffix,
     $tree_subnode_count_if_no_subnodes);

my $use_rgb_color;

BEGIN {
  #
  # These need to be pre-computed at compile time so TreeBuilder 
  # and similar packages can declare constants that use their
  # default values (even though those constants will remain the
  # same even if the user later changes these defaults):
  #
  $use_rgb_color = (is_console_color_capable() >= ENHANCED_RGB_COLOR_CAPABLE) ? 1 : 0;
  my $darkK = ($use_rgb_color) ? fg_color_rgb(96, 96, 96) : K;

  $tree_branch_to_node_style = 'single';
  $tree_branch_to_leaf_style = 'single';
  $tree_branch_color         = ($use_rgb_color) ? fg_color_rgb(96, 64, 192) : B;
  my $tree_indicator_color   = ($use_rgb_color) ? fg_color_rgb(128, 86, 255) : C;
  $tree_node_indicator_color = $tree_indicator_color;
  $tree_leaf_indicator_color = $tree_indicator_color;
  $tree_root_indicator_color = $tree_indicator_color;
  $tree_node_indicator       = arrow_tri;
  $tree_leaf_indicator       = arrow_open_tri;
  $tree_root_indicator       = square_root_symbol;
  $tree_horiz_dashed         = 0;
  $tree_vert_dashed          = 0;
  $tree_leading_space        = ' ';
  $tree_pre_branch_spacer    = ' ';
  $tree_pre_branch_color     = X;
  $tree_horiz_branch_length  = 1;
  $tree_subnode_count_prefix = $darkK.' (#'.R;
  $tree_subnode_count_suffix = $darkK.')'.X;
  $tree_subnode_count_if_no_subnodes = '';
};

#
# Given a reference to a node (i.e. an array), these convenience functions 
# simply return an lvalue for the node's label (element 0 of the array)
# or its subnodes (the remaining elements starting from index 1, returned
# as a slice).
#
sub label_of_tree_node(+) :lvalue {
  my ($node) = @_;
  $node->[0];
}

#
# Tree Styles
#

noexport:; use constant enum (
  BRANCH,            # e.g.  |-
  LAST_BRANCH,       # e.g.  L_
  NO_BRANCH,         # e.g.  |
  NO_BRANCH_DASHED,  # e.g.  :
  HORIZ_LINE,        # e.g.  -
  HORIZ_DASHED       # e.g.  --
);

# Don't print any branch lines for the top level root node:

my @no_tree_style = (' ' x 6);

# Style Attributes:       |-           L_           |            :            -            --
my @single_tree_style  = (chr(0x251c), chr(0x2514), chr(0x2502), chr(0x2506), chr(0x2500), chr(0x254c));
my @double_tree_style  = (chr(0x2560), chr(0x255a), chr(0x2551), chr(0x2551), chr(0x2550), chr(0x2550));
my @rounded_tree_style = (chr(0x251c), chr(0x2570), chr(0x2502), chr(0x2506), chr(0x2500), chr(0x254c));
my @thick_tree_style   = (chr(0x2523), chr(0x2517), chr(0x2503), chr(0x2507), chr(0x2501), chr(0x254d));

# Style Attributes:                         |-           L_           |            :            -            --
my @single_vert_double_horiz_tree_style  = (chr(0x255e), chr(0x2558), chr(0x2502), chr(0x2506), chr(0x2550), chr(0x2550));
my @single_vert_thick_horiz_tree_style   = (chr(0x255e), chr(0x2558), chr(0x2502), chr(0x2506), chr(0x2501), chr(0x254d));
my @single_vert_arrow_horiz_tree_style   = (chr(0x251c), chr(0x2514), chr(0x2502), chr(0x2506), small_right_barbed_arrow, small_right_barbed_arrow);
my @double_vert_single_horiz_tree_style  = (chr(0x255f), chr(0x2559), chr(0x2551), chr(0x2551), chr(0x2550), chr(0x2550));
my @thick_vert_single_horiz_tree_style   = (chr(0x2520), chr(0x2516), chr(0x2503), chr(0x2507), chr(0x2500), chr(0x254c));

our %tree_styles = (
  'none'            => \@no_tree_style,
  'single'          => \@single_tree_style,
  'double'          => \@double_tree_style,
  'rounded'         => \@rounded_tree_style,
  'thick'           => \@thick_tree_style,

  'none,none'       => \@no_tree_style,

  'single,single'   => \@single_tree_style,
  'single,double'   => \@single_vert_double_horiz_tree_style,
  'single,thick'    => \@single_vert_thick_horiz_tree_style,
  'single,arrow'    => \@single_vert_arrow_horiz_tree_style,

  'double,double'   => \@double_tree_style,
  'double,single'   => \@double_vert_single_horiz_tree_style,

  'thick,thick'     => \@thick_tree_style,
  'thick,single'    => \@thick_vert_single_horiz_tree_style,
);

my $tree_label_markup_re = 
  qr{(?|
       (?>
         \% \{ 
         ([^\=\}]++) 
         (?> \= ($inside_braces_re))?
         \} 
       ) | 
       (?>
         (\t) ()
       )
     )}oax;

our %tree_command_name_to_id = (
  'label'                     => TREE_CMD_LABEL,
  'column'                    => TREE_CMD_COLUMN,
  'field'                     => TREE_CMD_FIELD,
    "\t"                      => TREE_CMD_FIELD,
    "\f"                      => TREE_CMD_FIELD,
  'max_field_width'           => TREE_CMD_MAX_FIELD_WIDTH,
  'subnodes'                  => TREE_CMD_SUBNODE_COUNT,
  'prefix'                    => TREE_CMD_PREFIX,
  'if_even'                   => TREE_CMD_IF_EVEN,
  'if_odd'                    => TREE_CMD_IF_ODD,
  'symbol'                    => TREE_CMD_SYMBOL,
  'branch_color'              => TREE_CMD_BRANCH_COLOR,
  'branch_style'              => TREE_CMD_BRANCH_STYLE,
  'branch_dashed'             => TREE_CMD_BRANCH_DASHED,
  'horiz_branch_length'       => TREE_CMD_HORIZ_BRANCH_LENGTH,
  'div'                       => TREE_CMD_DIV,
  'inc'                       => TREE_CMD_INCLUDE,
  'include'                   => TREE_CMD_INCLUDE,
);

noexport:; sub subtree_label {
  my ($label, $node, $leading_space,
      $branch_to_node_style, $branch_to_leaf_style,
      $sub_branch_to_node_style, $sub_branch_to_leaf_style,
      $branch_color, $sub_branch_color,
      $node_indicator, $leaf_indicator,
      $horiz_dashed, $vert_dashed, 
      $horiz_branch_length, $skip_branch,
      $max_field_widths,
      $output_line_number) = @_;

  my $subnode_count = (is_array_ref($node)) ? scalar(@$node)-1 : 0;

  my $is_even_line = ($output_line_number % 2) == 0;

  $leading_space //= '';

  my $per_line_header = '';

  my $field_id = 0;
  my @fields = ( '' );

  #
  # Even with an array, any literal chunks could still contain
  # %{tree_cmd=...} or \t (tab to next field), so also split 
  # any array elements that are scalars containing these.
  # (Text based commands can't use the INCLUDE command anyway).
  #
  my @chunks = (is_array_ref $label)
    ? (map {
      (!defined $_) ? ( ) :
      (is_array_ref $_) ? (($_->[0] == TREE_CMD_INCLUDE) ? (@{$_}[1..$#{$_}]) : ($_))
      : (split $tree_label_markup_re, $_)
    } @$label) : (split $tree_label_markup_re, $label); 

  foreach my $chunk (@chunks) {
    my $cmd; my $arg; my @args = ( );
    next if (!defined $chunk); # undef chunks are no-ops: just skip them

    if (is_array_ref($chunk)) {
      @args = @$chunk;
      $cmd = shift @args;
      $arg = $args[0] // '';
    } elsif ($chunk =~ /$tree_label_markup_re/oax) {
      ($cmd, $arg) = ($tree_command_name_to_id{$1}, $2 // '');
      @args = split(/,/, $arg);
      if (!defined $cmd) {
        warning('Invalid tree formatting command "'.$1.'" with arguments ['.
              join(', ', @args).']');
      }
    } else {
      $cmd = TREE_CMD_LABEL;
      $arg = $chunk;
    }

    my $added = undef;
    my $added_to_prefix = undef;

    if ($cmd == TREE_CMD_LABEL) {
      $added = $arg;
    } elsif ($cmd == TREE_CMD_SUBNODE_COUNT) {
      my $before = (if_there $args[0]) // $tree_subnode_count_prefix;
      my $after = (if_there $args[1]) // $tree_subnode_count_suffix;
      my $if_no_subnodes = (if_there $args[2]) // $tree_subnode_count_if_no_subnodes;
      $added = ($subnode_count > 0) ? $before.$subnode_count.$after : $if_no_subnodes;
    } elsif ($cmd == TREE_CMD_FIELD) {
      if (is_there($arg)) {
        $field_id = $arg;
      } else {
        # add a new field at the end
        $field_id++;
      }
    } elsif ($cmd == TREE_CMD_MAX_FIELD_WIDTH) {
      my $f = (if_there $args[1]) // $field_id;
      set_if_there($max_field_widths->[$f + 1], $args[0]);
    } elsif ($cmd == TREE_CMD_PREFIX) {
      $added_to_prefix = (is_there $args[1]) ?
        $args[$is_even_line ? 0 : 1] : ((if_there $args[0]) // '');
    } elsif ($cmd == TREE_CMD_SYMBOL) {
      $$node_indicator = (if_there $args[0]) // 
        ($tree_node_indicator_color.$tree_node_indicator);
      $$leaf_indicator = (if_there $args[1]) // (if_there $args[0]) // 
        ($tree_leaf_indicator_color.$tree_leaf_indicator);
    } elsif ($cmd == TREE_CMD_BRANCH_COLOR) {
      $$branch_color = (if_there $arg) // $tree_branch_color;
    } elsif ($cmd == TREE_CMD_BRANCH_STYLE) {
      my ($br_to_node, $br_to_leaf) = @args;
      set_if_empty $br_to_node, $$branch_to_node_style;
      set_if_empty $br_to_leaf, $br_to_node;
      $$branch_to_node_style = $tree_styles{$br_to_node};
      $$branch_to_leaf_style = $tree_styles{$br_to_leaf};
      if (!exists $tree_styles{$br_to_node}) { warn('Style "'.$br_to_node." (for branch to node) is invalid"); }
      if (!exists $tree_styles{$br_to_leaf}) { warn('Style "'.$br_to_leaf." (for branch to leaf) is invalid"); }
    } elsif ($cmd == TREE_CMD_SUB_BRANCH_COLOR) {
      $$sub_branch_color = (if_there $arg) // $$branch_color;
    } elsif ($cmd == TREE_CMD_SUB_BRANCH_STYLE) {
      my ($br_to_node, $br_to_leaf) = @args;
      set_if_empty $br_to_node, $$branch_to_node_style;
      set_if_empty $br_to_leaf, $br_to_node;
      $$sub_branch_to_node_style = $tree_styles{$br_to_node};
      $$sub_branch_to_leaf_style = $tree_styles{$br_to_leaf};
      if (!exists $tree_styles{$br_to_node}) { warn('Style "'.$br_to_node." (for branch to subnode) is invalid"); }
      if (!exists $tree_styles{$br_to_leaf}) { warn('Style "'.$br_to_leaf." (for branch to subleaf) is invalid"); }
    } elsif ($cmd == TREE_CMD_BRANCH_DASHED) {
      $$horiz_dashed = (if_there $args[0]) // 1;
      $$vert_dashed = (if_there $args[1]) // 0;
    } elsif ($cmd == TREE_CMD_BRANCH_SKIP) {
      $$skip_branch = 1;
    } elsif ($cmd == TREE_CMD_HORIZ_BRANCH_LENGTH) {
      $$horiz_branch_length = (if_there $args[0]) // $tree_horiz_branch_length;
    } elsif ($cmd == TREE_CMD_DIV) {
      $args[0] = (if_there $args[0]) // dashed_horiz_bar_2_dashes;
      $args[1] = (if_there $args[1]) // $$branch_color;
      $added = $args[1].($args[0] x 80);
    } elsif ($cmd == TREE_CMD_IF_EVEN) {
      $added = $arg if ($is_even_line);
    } elsif ($cmd == TREE_CMD_IF_ODD) {
      $added = $arg if (!$is_even_line);
    } else {
      die('Invalid formatting command #', $cmd,' with arguments ['.join_undefs(', ', @args).']');
    }

    if (defined $added) {
      $fields[$field_id] //= '';
      $fields[$field_id] .= $added;
    } elsif (defined $added_to_prefix) {
      $per_line_header .= $added_to_prefix;
    }
  }

  $per_line_header .= $leading_space;

  return ($per_line_header, @fields);
}

noexport:; sub subtree_to_text {
  my ($nodelist, $out, $level, $prefix, 
      $branch_to_node_style, $branch_to_leaf_style, 
      $branch_color, $parent_branch_color, $node_indicator, 
      $leaf_indicator, $horiz_dashed, $vert_dashed,
      $horiz_branch_length, $max_field_widths) = @_;

  $prefix //= '';

  my $nodecount = 0;
  
  my @empty_array = ( );

  my $node_count = scalar(@$nodelist);

  my $sub_branch_to_node_style = undef;
  my $sub_branch_to_leaf_style = undef;
  my $sub_branch_color = undef;

  my $skip_branch = 0;

  if ($level == 0) {
    # we need to print the header line for the top-level root node:
    my $root_branch_color = undef;
    my $root_branch_to_node_style = undef;
    my $root_branch_to_leaf_style = undef;
    my $root_node_indicator = undef;
    my $root_leaf_indicator = undef; # (this is only relevant for empty trees)

    my $this_horiz_dashed = $horiz_dashed;
    my $this_vert_dashed = $vert_dashed;
    my ($per_line_header, @fields) = subtree_label(
      ($nodelist->[0] // C.'root'.X),
      $node, $tree_leading_space,
      \$root_branch_to_node_style, \$root_branch_to_leaf_style,
      \$sub_branch_to_node_style, \$sub_branch_to_leaf_style,
      \$root_branch_color, \$sub_branch_color,
      \$root_node_indicator, \$root_leaf_indicator,
      \$this_horiz_dashed, \$this_vert_dashed,
      \$horiz_branch_length, \$skip_branch,
      $max_field_widths,
      scalar(@$out));

    #
    # Since the root node has no branch to its left, it is meaningless
    # to set its own branch style or color; in this case we instead set
    # the default sub-branch style and color (if not explicitly set)
    # to match the root style and color, so the first level branches
    # use these settings unless one or more of these first level 
    # branches override these settings using TREE_CMD_BRANCH_COLOR 
    # and/or TREE_CMD_BRANCH_STYLE or equivalently (for the root only)
    # TREE_CMD_SUB_BRANCH_STYLE and/or TREE_CMD_SUB_BRANCH_COLOR.
    #
    # These first level branches can also independently set the style and
    # color of their own sub-nodes (and their entire sub-tree by default)
    # using TREE_CMD_SUB_BRANCH_STYLE and/or TREE_CMD_SUB_BRANCH_COLOR.    
    #
    $branch_to_node_style = $root_branch_to_node_style // $sub_branch_to_node_style // $branch_to_node_style;
    $branch_to_leaf_style = $root_branch_to_leaf_style // $sub_branch_to_leaf_style // $branch_to_leaf_style;
    $branch_color = $root_branch_color // $sub_branch_color // $branch_color;
    $sub_branch_to_node_style //= $branch_to_node_style;
    $sub_branch_to_leaf_style //= $branch_to_leaf_style;
    $sub_branch_color //= $branch_color;
    $root_node_indicator //= $tree_root_indicator;

    $fields[0] = $tree_root_indicator_color.$root_node_indicator.' '.($fields[0] // '').' ';
    push @$out, [ $per_line_header, @fields ];
  }

  # $nodelist->[0] is this node's text to prints(already printed by the 
  # calling subtree_to_text()), so we start with index 1 here:

  for (my $i = 1; $i < $node_count; $i++) {
    my $node = $nodelist->[$i];
    my $is_last_node = ($i == ($node_count-1));
    my $is_array_node = is_array_ref($node);
    
    my $chunks = (((defined $node) && $is_array_node) ? $node->[0] : $node) // '';
    
    my $subnode_count = ($is_array_node ? scalar(@$node)-1 : 0);

    my $this_horiz_dashed = $horiz_dashed;
    my $this_vert_dashed = $vert_dashed;

    my ($per_line_header, @fields) = subtree_label(
      $chunks, $node, $tree_leading_space,
      \$branch_to_node_style, \$branch_to_leaf_style,
      \$sub_branch_to_node_style, \$sub_branch_to_leaf_style,
      \$branch_color, \$sub_branch_color,
      \$node_indicator, \$leaf_indicator,
      \$this_horiz_dashed, \$this_vert_dashed, 
      \$horiz_branch_length, \$skip_branch,
      $max_field_widths, 
      scalar(@$out));

    my $style_set = ($subnode_count > 0) ? $branch_to_node_style : $branch_to_leaf_style;
    
    my $style =
      ($is_last_node) ? LAST_BRANCH :
      (is_there $node) ? BRANCH :
      ($this_vert_dashed ? NO_BRANCH_DASHED : NO_BRANCH);
        
    my $horiz_style =
      ($this_horiz_dashed ? HORIZ_DASHED : HORIZ_LINE);

    die if (!defined $parent_branch_color);
    die if (!defined $branch_color);
    die if (!defined $tree_pre_branch_color);
    die if (!defined $style_set->[NO_BRANCH]);

    my $base_prefix = $parent_branch_color.$prefix.$branch_color;

    my $subnode_prefix = 
      $base_prefix.(($is_last_node) 
                    ? ($tree_pre_branch_spacer x $horiz_branch_length).$tree_pre_branch_spacer
                    : $style_set->[NO_BRANCH].(' ' x $horiz_branch_length));
   
    my $indicator = 
      (($subnode_count > 0)
        ? $node_indicator
        : (is_there($node) ? $leaf_indicator : $leaf_indicator));

    my $branch_symbols = $base_prefix.
      (($skip_branch)
         ? $style_set->[NO_BRANCH].(' ' x $horiz_branch_length)
         : $style_set->[$style].($style_set->[$horiz_style] x $horiz_branch_length)).
      $indicator.' '.(($subnode_count > 0) ? G : X);

    #
    # Prepend the branch symbols to the start of the first field,
    # rather than giving them their own field, since we want the
    # first field's label to appear immediately after the branches.
    #
    # (If this was aligned to the next field boundary, nodes closer
    # to the root would have a huge gap between the branch and its
    # label, which would look visually confusing).
    #
    @fields[0] = $branch_symbols.($fields[0] // '');

    push @$out, [ $per_line_header, @fields ];

    if ($subnode_count > 0) {
      subtree_to_text(
        $node, $out, $level+1, $subnode_prefix,
        $sub_branch_to_node_style // $branch_to_node_style,
        $sub_branch_to_leaf_style // $branch_to_leaf_style, 
        $sub_branch_color // $branch_color,
        $parent_branch_color, $node_indicator, $leaf_indicator, 
        $this_horiz_dashed, $this_vert_dashed, $horiz_branch_length,
        $max_field_widths);
    }
  }
}

noexport:; sub tree_to_lines {
  my $nodelist             = $_[0];
  my $branch_to_node_style = $_[1] // $tree_branch_to_node_style;
  my $branch_to_leaf_style = $_[2] // $tree_branch_to_leaf_style;
  my $branch_color         = $_[3] // $tree_branch_color;
  my $node_indicator       = $_[4] // $tree_node_indicator_color.$tree_node_indicator;
  my $leaf_indicator       = $_[5] // $tree_leaf_indicator_color.$tree_leaf_indicator;
  my $horiz_dashed         = $_[6] // $tree_horiz_dashed;
  my $vert_dashed          = $_[7] // $tree_vert_dashed;
  my $horiz_branch_length  = $_[8] // $tree_horiz_branch_length;

  if (!(exists $tree_styles{$branch_to_node_style}))
    { die('Undefined tree branch style "'.$branch_to_node_style.'"'); }

  $branch_to_node_style = $tree_styles{$branch_to_node_style};

  if (!(exists $tree_styles{$branch_to_leaf_style}))
    { die('Undefined tree branch style "'.$branch_to_leaf_style.'"'); }

  $branch_to_leaf_style = $tree_styles{$branch_to_leaf_style};

  my $parent_branch_color = $branch_color;

  if ((is_console_color_capable() >= ENHANCED_RGB_COLOR_CAPABLE)) {
    $parent_branch_color = fg_color_rgb(scale_rgb($branch_color, 0.5));
  }

  my $rows_and_columns = [ ];
  my $max_field_widths = [ undef ];

  subtree_to_text(
    $nodelist, $rows_and_columns, 0, '',
    $branch_to_node_style, $branch_to_leaf_style, 
    $branch_color, $parent_branch_color, 
    $node_indicator, $leaf_indicator,
    $horiz_dashed, $vert_dashed, 
    $horiz_branch_length,
    $max_field_widths);

  my @out = format_table($rows_and_columns, colseps => '', row_suffix => X.NL,
                         wrap_above_max_col_widths => $max_field_widths); 

  return (wantarray ? @out : \@out);
}

sub format_tree(+;@) {
  my ($node, @args) = @_;
  my $lines = tree_to_lines($node, @args);
  return (wantarray ? @$lines : join(NL, @$lines));
}

sub print_tree(+;$@) {
  my ($node, $fd, @args) = @_;
  $fd //= STDOUT;
  my $lines = tree_to_lines($node, @args);
  printfd($fd, join(NL, @$lines));
}

1;
