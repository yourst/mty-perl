#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::ListDeps::OutputFormat
#
# Copyright 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::ListDeps::OutputFormat;
use integer; use warnings; use Exporter qw(import);

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(@output_format_specs __format_deps_using_template_internal
     format_deps_as_tree format_deps_using_template);

use MTY::Common::Common;
use MTY::Common::Strings;
use MTY::Common::Hashes;
use MTY::Common::CommandLine;

use MTY::Filesystem::Files;
use MTY::Filesystem::FileStats;

use MTY::Display::Colorize;
use MTY::Display::ColorizeErrorsAndWarnings;
use MTY::Display::ColorCapabilityCheck;
use MTY::Display::ANSIColorREs;
use MTY::Display::TextInABox;
use MTY::Display::Table;
use MTY::Display::Tree;
use MTY::Display::TreeBuilder;
use MTY::Display::PrintableSymbols;
use MTY::Display::PrintableSymbolTools;
use MTY::Display::DataStructures;

use MTY::RegExp::FilesAndPaths;
use MTY::RegExp::PrefixStrings;
use MTY::RegExp::Strings;

use MTY::System::POSIX;
use MTY::System::Misc;

use MTY::Filesystem::SearchableDirList;

use MTY::ListDeps::Config;

#pragma end_of_includes

sub __format_deps_using_template_internal(++$$) :method {
  my ($filename, $deplist, $dep_type_name, $format) = @_;

  my $depstring = join(' ', @$deplist);

  my %placeholders = (
    'T' => $dep_type_name,
    'S' => $filename,
    'D' => $depstring,
  );

  my $out = substitute_placeholders($format, %placeholders);

  if (defined $wrap_long_lines)
    { $out = (word_wrap_long_lines($out, $wrap_long_lines) =~ s{\n}{ \\\n}roamsxg); }

  return $out;
}

sub format_deps_using_template(++++$) :method {
  my ($outspec, $top_level_source_filenames, $filenames_to_dep_lists, $filenames_to_sources, $deptype) = @_;

  my $format = $user_defined_output_format_template // $outspec->{format};
  my $dep_type_name = $dep_type_to_name[$deptype];

  my @out = ( );

  foreach (@$top_level_source_filenames) {
    my $filename = $_;
    my $deps = $filenames_to_dep_lists->{$filename};

    if ($strip_project_dir_from_output_filenames) {
      $filename = remove_from_start($filename, $project_dir);
      $deps = [ map { remove_from_start($_, $project_dir) } @$deps ];
    }
    
    if ($one_dep_per_line) {
      my @single_dep = ( undef );
      foreach my $dep (@$deps) {
        $single_dep[0] = $dep;
        push @out, __format_using_template_internal(
          $filename, \@single_dep, $dep_type_name, $format);
      }
    } else {
      push @out, __format_deps_using_template_internal(
        $filename, $deps, $dep_type_name, $format);
    }
  }

  return @out;
}

sub condense_filenames_by_directory(+) {
  my ($paths) = @_;

  my $dir_to_file_list = { };
  
  foreach my $path (@$paths) {
    my ($dir, $filename) = split_dir_and_filename($path);
    push @{$dir_to_file_list->{$dir}}, $filename;
  }

  return $dir_to_file_list;
}

#
# Recursive deps make no sense for tree format, since the structure
# of the tree itself depicts the recursion, so flattening it would
# serve no purpose and would erroneously yield a two level tree:
#
sub format_deps_as_tree(++++$) {
  my ($outspec, $top_level_source_filenames, $filenames_to_dep_lists, $filenames_to_sources, $deptype) = @_;

  my $filenames_to_labels = { };

  foreach my $source (values %$filenames_to_sources) {
    my $filename = $source->{filename};
    my $typespec = $source->{type};
    my $tree_node_symbol_cmd = $typespec->{tree_node_symbol_cmd} // arrow_tri;
    my $tree_node_symbol_dark_cmd = $typespec->{tree_node_symbol_dark_cmd} // arrow_open_tri;

    # my $deps = $filenames_to_dep_lists->{$filename};
    # my $deps_by_dir = condense_filenames_by_directory($deps);
    # while (my ($dir, $list) = each %$deps_by_dir) {  }

    my $label = [
      $tree_node_symbol_cmd,
      format_filename_with_path_prefix($source->{filename});
    ];

    my $path_prefix = get_path_prefix($filename);
    my $branch_color_tree_cmd = (defined $path_prefix) 
      ? $path_prefix_branch_color_tree_cmd{$path_prefix} : undef;
    push @$label, $branch_color_tree_cmd if (defined $branch_color_tree_cmd);

    $filenames_to_labels->{$filename} = $label;
  }

  $filenames_to_labels{(ALL_SELECTED_SOURCES_KEY)} = C.U.'(All Specified Input Files)'.UX;

  my $tree = dependency_graph_to_tree(ALL_SELECTED_SOURCES_KEY, 
                                      $filenames_to_dep_lists, $filenames_to_labels);
  my @out = format_tree($tree);
  push @out, format_path_prefix_abbreviation_table();

  return @out;
}

sub format_deps_with_graphviz(++++$) {
  my ($outspec, $top_level_source_filenames, $filenames_to_dep_lists, $filenames_to_sources, $deptype) = @_;
  die("graphviz output not implemented yet");
}

my $template_format_description = 
  'Output format to use for printing specified dependency list types '.
  '(%T = dep type, %S = source filename, %D = space separated dependency list)',

my $template_format_spec = {
  name => 'format', 
  aliases => [ ],
  description => $template_format_description,
  function => \&format_deps_using_template,
  command_line_options => [
    'format' => [ \$user_defined_output_format_template, OPTION_VALUE_REQUIRED, [ qw(fmt) ],
                undef, undef, undef, [ \$output_format_name => 'format' ] ],
  ],
  command_line_option_descriptions => [
    'format' => $template_format_description,
  ],
  # (private fields defined by each formatting plugin):
};

my $rawdeps_format_spec = {
  name => 'rawdeps', 
  aliases => [ qw(rawdeps raw) ],
  description => 'Show only the dependencies themselves, without indicating which sources depend on them. '.
  'This is often most useful in conjunction with -one-dep-per-line, then piping through sort '.
  'and uniq will yield a comprehensive list of everything the entire project depends on.',
  function => \&format_deps_using_template,
  # (private fields defined by each formatting plugin):
  format => '%D',
};

my $tabdelim_format_spec = {
  name => 'tabdelim', 
  aliases => [ qw(tabdelim machine-readable td) ],
  description => 'Simple tab delimited format, e.g. '.M.'deptype'.R.'<tab>'.M.'source'.R.'<tab>'.M.'dep1 dep2 '.M_1_2.'...'.X,
  function => \&format_deps_using_template,
  # (private fields defined by each formatting plugin):
  format => '%T\t%S\t%D',
};

my $makerules_format_spec = {
  name => 'makerules',
  aliases => [ qw(makerules m make makefile) ],
  description => 'Makefile rules with target and prerequisites, e.g. '.M.'/path/to/source.ext: /dir1/dep1.h /dir2/dep2.h'.X,
  function => \&format_deps_using_template,
  # (private fields defined by each formatting plugin):
  format => '%S: %D',
},

my $makedefs_format_spec = {
  name => 'makedefs',
  aliases => [ qw(makedefs md makevars) ],
  description => 'Makefile variable definitions, e.g. '.M.'deps[/path/to/source.ext] := /dir1/dep1.h /dir2/dep2.h ...'.X,
  function => \&format_deps_using_template,
  # (private fields defined by each formatting plugin):
  format => '%T[%S] := %D',
};
  
my $perlformat_format_spec = {
  name => 'perlformat',
  aliases => [ qw(perl-data-structs) ],
  description => 'Dependencies expressed through Perl source code formatted hashes and arrays',
  function => \&format_deps_using_template,
  # (private fields defined by each formatting plugin):
  format => '  \'%S\' => [ %D ],',
};

my $tree_format_spec = {
  name => 'tree',
  aliases => => [ ],
  description => 'Print a tree diagram of all recursive dependencies relative to each source',
  function => \&format_deps_as_tree,
  # (private fields defined by each formatting plugin):
};

my $graphviz_format_spec = {
  name => 'graphviz',
  aliases => [ qw(dot viz gv graph) ],
  description => 'Generate a GraphViz .dot format file of the dependency graph',
  function => \&format_deps_with_graphviz,
  # (private fields defined by each formatting plugin):
};

our @output_format_specs = (
  $template_format_spec,
  $rawdeps_format_spec,
  $tabdelim_format_spec,
  $makerules_format_spec,
  $makedefs_format_spec,
  $perlformat_format_spec,
  $tree_format_spec,
  $graphviz_format_spec,
);

INIT {
  printdebug{__PACKAGE__, ' initializing'};
  register_output_formats(@output_format_specs);
};

1;

