# -*- cperl -*-
#
# MTY::Display::StackTrace
#
# Copyright 2003 - 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Common::StackTrace;

use integer; use warnings; use Exporter qw(import);

use MTY::System::POSIX;
use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Common::Strings;
#pragma end_of_includes

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(%skip_packages_and_functions_in_stack_backtrace
     get_caller_and_args_at_level get_stack_backtrace print_stack_backtrace
     simple_format_stack_backtrace);

noexport:; sub get_caller_and_args_at_level($) {
  my ($level) = @_;

  my ($package, $filename, $line, $function, $has_args, $wantarray, $eval_text) = do {
    package 
      DB;
    @DB::args = ( );
    caller($level);
  };

  if (!defined $package) { return ( ); };

  my @args = ($has_args // 0) ? @DB::args : ( );

  $filename //= '<unknown>';
  $function //= '<unknown>';
  $line //= 0;

  my $is_eval = 0;
  if ($filename eq '-e') { $filename = '<eval>'; $is_eval = 1; }
  if ($function eq '(eval)') { $function = '<eval>'; $is_eval = 1; }

  return ($filename, $line, $package, $function, (($is_eval) ? ($eval_text // '') : @args));
}

sub get_stack_backtrace(;$) {
  my ($levels_to_skip) = @_;
  $levels_to_skip //= 1;

  my @stack = ( );

  for (my $level = $levels_to_skip; ; $level++) {
    my @info = get_caller_and_args_at_level($level);
    my ($filename, $line, $package, $function) = @info;

    last if (!defined $package);

    push @stack, [ @info ];
  }

  return (wantarray ? @stack : \@stack);
}

sub simple_format_stack_backtrace(+) {
  my ($stack) = @_;
  my $out = NL.'Stack backtrace:'.NL;

  while (my ($level, $info) = each @$stack) {
    my ($filename, $line, $package, $function) = @$info;
    my ($function_without_package) = ($function =~ /([^:]+)\Z/oax);

    $out .= '  ['.$level.']  '.$function_without_package.'() in '.
      $filename.':'.$line.' ('.$package.')'.NL;
  }

  return $out;
}

sub print_stack_backtrace(;$+) {
  my ($fd, $stack) = @_;
  $fd //= STDERR;
  # Skip two levels (this function and then get_stack_backtrace() itself)
  # so the stack originates where the caller called this function:
  $stack //= get_stack_backtrace(2);

  printfd($fd, simple_format_stack_backtrace($stack));
}

our %skip_packages_and_functions_in_stack_backtrace = (
  __PACKAGE__, 1,
  __PACKAGE__.'::get_stack_backtrace', 1,
  __PACKAGE__.'::get_caller_and_args_at_level', 1,
);

1;
