#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Common::PrintDebug
#
# Print debug log text strings if enabled per package at runtime;
# also provides the prints() and printfd() convenience functions
#
# Copyright 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Common::PrintDebug;

use integer; use warnings; use Exporter qw(import);
use MTY::Common::Common;
#pragma end_of_includes

preserve:; our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($undef_placeholder
     simple_format_printable_data
     prints printfd printdebug is_debug);

preserve:; our @EXPORT_OK = # (auto-generated by perl-mod-deps)
  qw(%debug_packages $debug_all_packages default_print_debug_function
     $print_debug_disabled $print_debug_filename $print_debug_line
     $print_debug_function $print_debug_package $print_debug_message_id
     $print_debug_call_stack_depth $print_debug_fields_only_if_changed
     $print_debug_callback $format_printable_data_callback
     $print_debug_align_messages);

our $undef_placeholder = '<undef>';

noexport:; sub simple_format_scalar(+$) {
  my ($obj, $type) = @_;
  
  return 
    ($type == SCALAR) ? (0+$obj) :
    ($type == STRING) ? '"'.$obj.'"' :
    ($type == DUAL) ? 'dual<"'.$obj.'"/'.(0+$obj).'>' :
    undef;
}

noexport:; sub simple_format_array_or_hash_item(+) {
  my ($obj) = @_;
  my $type = typeof($obj);
  return
    ((!defined $_) ? $undef_placeholder :
     (is_scalar_typeid($type)) ? simple_format_scalar($obj, $type) :
     '\\'.lc($typeid_to_string[$type]).'<'.sprintf('0x%x', refaddr($obj)).'>');
}

noexport:; sub simple_format_array(+) {
  my ($array) = @_;
  return ('['.join(', ', (map { simple_format_array_or_hash_item($_) } @$array)).']');
}

noexport:; sub simple_format_hash(+) {
  my ($hash) = @_;
  return ('{'.join(', ', (pairmap {
    "$a".' => '.simple_format_array_or_hash_item($b) 
  } %$hash)).'}');
}

sub simple_format_printable_data(+;$$) {
  my ($obj, $print_id, $arg_id, $multi_line) = @_;
  $multi_line //= 0;

  my $type = typeof($obj);
  my $gentype = generic_typeid($type);
  my $hexref = sprintf('0x%x', refaddr($obj) // 0);

  my $text =
    (!defined $obj) ? $undef_placeholder :
    ($gentype == SCALAR) ? simple_format_scalar($obj, $type) :
    ($type == SCALAR_REF) ? '\\# '.simple_format_scalar(${$obj}, $type) :
    ($type == STRING_REF) ? '\\$ '.simple_format_scalar(${$obj}, $type) :
    ($type == DUAL_REF) ? '\\'.simple_format_scalar(${$obj}, $type) :
    ($type == REF_REF) ? '\\ref -> '.$hexref :
    ($type == ARRAY_REF) ? '@'.simple_format_array($obj) :
    ($type == HASH_REF) ? '%'.simple_format_hash($obj) :
    ($type == REGEXP_REF) ? 'qr{'.$obj.'}' :
    ($type == CODE_REF) ? '&sub '.$hexref :
      (lc($typeid_to_string[$type] // 'typeid#'.$type)).
        ' -> '.$hexref;

  return ($text);
}

our $format_printable_data_callback = \&simple_format_printable_data;

sub printfd($;@) {
  my $fd = shift;

  #
  # The format_printable_data_callback function can add additional text
  # to be printed only after we've finished printing all the arguments.
  # This is generally used to return only a short placeholder for some
  # complex arguments like arrays, etc., with the real multi-line output
  # shown below the original line to print.
  #
  my @print_after_all_args = ( );

  my $formatted_arg_index = 0;
  my $arg_index = 0;

  syswrite($fd, join('', (map {
    my $result;
    if (!ref $_) {
      $result = ($_ // $undef_placeholder);
    } else {
      my ($output, $after) = $format_printable_data_callback->($_, $formatted_arg_index++, $arg_index);
      push @print_after_all_args, $after if (is_there $after);
      $result = $output;
    }
    $arg_index++;
    $result;
  } @_)));

  foreach my $text (@print_after_all_args) { syswrite($fd, $text); }
}

sub prints { printfd(STDOUT, @_); }

our $print_debug_disabled;
BEGIN { $print_debug_disabled = 1; }

our %debug_packages = ( );
our $debug_all_packages = 0;
my @debug_enabled_for_wildcards = ( );
my @debug_disabled_for_wildcards = ( );
my $debug_enabled_regexp = undef;
my $debug_disabled_regexp = undef;

sub is_debug(;$) {
  return 0 if ($print_debug_disabled);

  my $package = $_[0] // (caller) // 'main';

  my $package_setting = $debug_packages{$package};

  return (bool $package_setting) if (defined $package_setting);

  my $enabled =
    $debug_all_packages ||
    ((defined $debug_enabled_regexp) && ($package =~ $debug_enabled_regexp));

  my $disabled =
    ((defined $debug_disabled_regexp) && ($package =~ $debug_disabled_regexp));

  # Put it into the hash for fast lookup in the future:
  my $debug = bool ($enabled && (!$disabled));
  $debug_packages{$package} = $debug;
  return $debug;
}

my $prev_header_length = 0;
my $prev_depth = 0;

sub default_print_debug_function($$$$$;@) {
  my ($id, $function, $package, $filename, $line, $depth, @args) = @_;
  $depth //= 0;

  my $show_any = any_defined $id, $function, $package, $filename, $line;

  my @header = ('#');
  push @header, '[' if ($show_any);
  push @header, '('.$id.')' if (defined $id);
  push @header, $function.'()' if (defined $function);
  push @header, 'in '.$package if (defined $package);
  push @header, '@' if (any_defined $filename, $line);
  push @header, $filename if (defined $filename);
  push @header, ((defined $filename) ? ':' : 'line ').$line if (defined $line);
  push @header, '] ' if ($show_any);

  my $header = join(' ', @header);
  $header .= (' ' x ($prev_header_length - (length $header)));

  set_max($prev_header_length, length $header);
  $prev_depth = $depth;
  $header .= ('. ' x $depth);
  # Slap the header text onto the start of every new line:
  printfd(STDERR, $header, (map { (($_ eq NL) ? NL.$header : $_) } @args), NL);

  return 1;
}

our $print_debug_filename = 1;
our $print_debug_line = 1;
our $print_debug_function = 1;
our $print_debug_package = 0;
our $print_debug_message_id = 1;
our $print_debug_call_stack_depth = 0;
our $print_debug_align_messages = 0;

our $print_debug_fields_only_if_changed = 1;
our $print_debug_callback = \&default_print_debug_function;

my $prev_filename = '';
my $prev_line = 0;
my $prev_function = '';
my $prev_package = '';
my $prev_message_id = 0;

my $strip_package_name_re = qr{([^\:]++)\Z}oax;

#
# In a normal function call, all of the arguments are evaluated 
# unconditionally before the function is actually executed. This
# is highly undesirable when calling printdebug while debug output
# for the calling package (or any package) has been disabled, 
# since evaluating the arguments would be a pointless waste of
# time (and often a lot of time if evaluating the arguments
# involves calling other functions to collect the information
# to be printed).
#
# To avoid this problem (thereby ensuring printdebug has almost
# zero overhead if debug printing is disabled), the printdebug
# function is invoked with an unusual syntax:
#
#   printdebug { list, of, things, to, print, ... };
#
# Notice the use of { ... } brackets instead of ( ... ) parentheses.
# This is because the "arguments" to printdebug are actually a single
# reference to a block of code (i.e. lambda closure) whose purpose is
# to evaluate each of the arguments to be printed and then return the
# list of these evaluated arguments to printdebug. 
#
# If and only if printdebug determines it will actually print these
# arguments, it will evaluate the block by calling it like a function;
# only at this point will anything inside the { ... } be evaluated.
# 

sub printdebug(&) {
  return 0 if ($print_debug_disabled);

  my $package = (caller) // 'main';
  return 0 if (!($debug_packages{$package} // is_debug($package)));

  my ($caller_package, $caller_filename, $caller_line) = caller(0);
  $caller_package //= 'main';
  my $caller_function = ((caller(1))[3]) // '<package>';

  my $depth = 0;
  if ($print_debug_call_stack_depth)
    { while (scalar caller($depth)) { $depth++; } }

  # Actually evaluate the arguments in their original closure context:
  my $eval_func = $_[0];
  my @args = $eval_func->();

  ($caller_function) = ($caller_function =~ $strip_package_name_re);

  my $always = !$print_debug_fields_only_if_changed;
  my $show_package = ($print_debug_package && ($always || ($caller_package ne $prev_package)));
  my $show_function = ($print_debug_function && ($always || ($caller_function ne $prev_function)));
  my $show_filename = ($print_debug_filename && ($always || ($caller_filename ne $prev_filename)));
  my $show_line = ($print_debug_line && ($always || ($caller_line ne $prev_line)));

  $print_debug_callback->(
    ($print_debug_message_id) ? $prev_message_id : undef,
    ($show_function) ? $caller_function : undef,
    ($show_package) ? $caller_package : undef,
    ($show_filename) ? $caller_filename : undef,
    ($show_line) ? $caller_line : undef,
    ($print_debug_call_stack_depth) ? $depth : undef,
    (map { (is_string $_) ? (split /(\n)/oamsx, $_) : $_ } @args));

  $prev_package = $caller_package;
  $prev_function = $caller_function;
  $prev_filename = $caller_filename;
  $prev_line = $caller_line;
  $prev_message_id++;

  return 1;
}

INIT {
  my $env = $ENV{'DEBUG'};
  if (is_there $env) {
    $print_debug_disabled = 0;

    #
    # Examples of valid syntax for DEBUG environment variable:
    #
    # My::Package::Name=1     # enables: print debug output from any code within My::Package::Name
    # My::Package::Name=0     # disable: do not print debug output from any code within My::Package::Name
    # My::Package::Name       # enables: equivalent to My::Package::Name=1
    # My::Package::Name=      # disable: equivalent to My::Package::Name=0
    #
    # Wildcards:
    # 
    # Other::Package::*=1     # enables: matches all packages named Other::Package::<anything>
    # Other::Package::Sub*=0  # disable: matches Other::Package::SubPackage, Subset, SubXXX, etc.
    #
    # Options for all packages:
    #
    # .name=value           # Sets option 'name' to 'value'
    # .name                 # Enables option 'name (equivalent to '.name=1')
    # .name=                # Disables option 'name' (equivalent to '.name=0')
    #
  
    my $debug_setting_re = 
      qr{\G \s*+ 
         (?|
           (?>
             (\!?) ((?> \w++ ::)*+) 
             (?|
               (?> (\w++) (\*?)) |
               (?> ( )    (\*) )
             )
             (?> (=) (?> ([1-9YyAa\+]) | ([0NnXx\-\!]))?)?
           ) | 
           (?> (\.) ([\w\_\-]++) \=? ([^\s\,\;\=]*+))
         )
         (?> [\s\,\;]++ | \Z)
      }oamsx;

    my %debug_config_env_to_vars = (
      multikey(qw(filenames filename files file source-file sources source)
        => \$print_debug_filename),
      multikey(qw(source-lines source-line lines line)
        => \$print_debug_line),
      multikey(qw(caller function func sub) 
        => \$print_debug_function),
      multikey(qw(packages package modules module pkg mod)
        => \$print_debug_package),
      multikey(qw(message-index message-id index id numbered number num)
        => \$print_debug_message_id),
      multikey(qw(only-if-changed changes)
        => \$print_debug_fields_only_if_changed),
      multikey(qw(call-stack-depth stack-depth depth level levels)
        => \$print_debug_call_stack_depth),
    );

    my $last_pos = pos($env) // 0;

    while ($env =~ /$debug_setting_re/oamsxg) {
      my ($prefix, $leading, $final, $wildcard, $eq, $enabled, $disabled) = ($1, $2, $3, $4, $5, $6, $7);
      $last_pos = pos($env);
      $disabled //= ''; $prefix //= '';
      if ($prefix eq '.') {
        my ($setting, $value) = ($leading, $final);
        my $var = $debug_config_env_to_vars{$setting};
        if (defined $var) {
          ${$var} = (!length $value) ? 1 : $value;
        } else {
          printfd(STDERR, 'WARNING: unrecognized setting ".', $setting, '" in DEBUG environment variable was ignored');
        }
        next;
      }
      
      $enabled = ((!$eq) || ($eq && ((length $enabled) > 0))) && 
        ((length $disabled) == 0) && ($prefix ne '!');
      my $package = $leading.$final;

      #
      # Make 'Package::Prefix::' equivalent to 'Package::Prefix::*':
      # (wildcard entries may also end with a wildcard partway through
      # a package name component, e.g. Package::Pre*):
      #
      $wildcard = '*' if (!length $final);

      if ($wildcard) {
        if ((($leading.$final) eq '*') && $enabled) {
          $debug_all_packages = 1;
        } else {
          my $list = ($enabled) 
            ? \@debug_enabled_for_wildcards :
              \@debug_disabled_for_wildcards;
          push @$list, $package;
        }
      } else {
        $debug_packages{$package} = bool $enabled;
      }
    }
    
    if ($last_pos < length($env)) {
      die('DEBUG environment variable format was unrecognized starting at offset '.$last_pos.':'.NL,
           $env.NL, (' ' x $last_pos).'^'.NL);
      $print_debug_disabled = 1;
      $debug_all_packages = 0;
      %debug_packages = ( );
      @debug_enabled_for_wildcards = ( );
      @debug_disabled_for_wildcards = ( );
      return 0;
    }
  
    if ($debug_all_packages) {
      @debug_enabled_for_wildcards = ( );
    } elsif (@debug_enabled_for_wildcards) {
      @debug_enabled_for_wildcards = 
        sort_by_descending_length_then_alphabetical @debug_enabled_for_wildcards;

      my $enabled_re_text = '\A(?>'.join('|', @debug_enabled_for_wildcards).')';
      $debug_enabled_regexp = qr{$enabled_re_text}oamsx;
    }

    if (@debug_disabled_for_wildcards) {
      @debug_disabled_for_wildcards = 
        sort_by_descending_length_then_alphabetical @debug_disabled_for_wildcards;
      
      my $disabled_re_text = '\A(?>'.join('|', @debug_disabled_for_wildcards).')';
      $debug_disabled_regexp = qr{$disabled_re_text}oamsx;
    }
  
    printfd(STDERR, '#'.NL.'# Debug messages configured by DEBUG environment variable for these packages:'.NL,
      (($debug_all_packages) ? ('#   ENABLED  for wildcard * (ALL packages)'.NL) : ( )),
      (pairmap { '#   '.(($b > 0) ? 'ENABLED ' : 'disabled').' for '.$a.NL } (
        (map { 'wildcard: '.$_.'*' => 1 } @debug_enabled_for_wildcards),
        (map { 'package:  '.$_ => 1 } grep { $debug_packages{$_} } sort keys %debug_packages),
        (map { 'wildcard: '.$_.'*' => 0 } @debug_disabled_for_wildcards),
        (map { 'package:  '.$_ => 0 } grep { (!$debug_packages{$_}) } sort keys %debug_packages),
       )));

    printfd(STDERR, '#'.NL.'# Global debug configuration:'.NL,
            '#   Print debug outputs with extra fields:'.NL.'#   ',
            (map {
              my $v = ${$debug_config_env_to_vars{$_}}; 
              (($v) ? (' '.$_) : ( ));
            } qw(filename line package function message-id only-if-changed)), NL.'#'.NL);
  }
}

1;
