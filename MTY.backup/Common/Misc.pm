#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Common::Misc
#
# Additional miscellaneous useful functions and tools which
# are not used frequently enough to belong in the Common
# package but are nonetheless useful.
#
# Copyright 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Common::Misc;

use integer; use warnings; use Exporter qw(import);
use MTY::Common::Common;
#pragma end_of_includes

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(COMPARE_AND COMPARE_ANDNOT COMPARE_EQ COMPARE_GE COMPARE_GT
     COMPARE_INTEGERS COMPARE_LE COMPARE_LT COMPARE_MASK_ALL COMPARE_MASK_ANY
     COMPARE_MASK_NONE COMPARE_MASK_NOT_ALL COMPARE_NE COMPARE_NOR COMPARE_NOT
     COMPARE_NOT_REGEXP COMPARE_OR COMPARE_REGEXP COMPARE_STRINGS COMPARE_TO
     COMPARE_XOR binary_search compare_arrays compare_integers compare_strings
     compare_vec_to_scalar_and_generate_bitmask compare_with_expression
     create_line_offset_map extractbits find_line_containing_offset
     masked_store_into_array partition_into_parallel_arrays
     partition_into_subarrays topological_sort_dependencies);

sub compare_arrays(++) {
  my ($a, $b) = @_;

  my $n = min(scalar(@{$a}), scalar(@{$b}));
  my $i;
  for $i (0..($n-1)) {
    if ($a->[$i] ne $b->[$i]) { last; }
  }
  return $i;
}

#
# Partition the specified array into groups of N consecutive elements,
# and return a new array of references to these N-element sub-arrays.
#
sub partition_into_subarrays(+;$) {
  my ($array, $n) = @_;
  $n //= 1;
  my $len = scalar @$array;
  my $chunks = ($len + ($n-1)) / $n;
  my @out = ( );

  foreach (my $i = 0; $i < $len; $i += $n) 
    { push @out, [ @{$array}[$i..($i+($n-1))] ]; }

  return ((wantarray) ? @out : \@out);
}

#
# Partition the specified array into N parallel subarrays, where
# subarray 0 holds input array elements 0, N, 2*N, 3*N, etc.,
# subarray 1 holds input array elements 1, N+1, (2*N)+1, etc.
# and so forth. The subarrays are returned as a list of references
# to those subarrays.
#
sub partition_into_parallel_arrays(+;$) {
  my ($array, $n) = @_;
  $n //= 1;
  my $len = scalar @$array;
  my @out;
  foreach my $i ($n) { $out[$i] = [ ]; }
  my $i = 0;
  foreach my $v (@$array) {
    my $a = $out[$i];
    push @{$out[$i]}, $v;
    # avoid modulo operator for better performance:
    $i = ($i + 1); if ($i == $n) { $i = 0; }
  }

  return (wantarray ? @out : \@out);
}

sub extractbits {
  my $v = shift;
  my $out = 0;
  while (my ($bitoffs, $bitwidth) = each @_) 
    { $out = ($out << $bitwidth) | bits($v, $bitoffs, $bitwidth); }
  return $out;
}

#
# topological_sort_dependencies(%key_to_array_of_dep_keys, $from, (optional) \@depths):
#
# Perform a topological sort on the list of all dependencies of $from,
# where the returned array lists all dependencies before the nodes which
# depend on them, obtained through a depth first search of the graph of
# dependencies starting from $from. If a circular dependency is found,
# returns the key of the first node in that dependency loop.
#
# The %key_to_array_of_dep_keys hash maps each key to an array of the 
# keys it depends on. The $from argument, keys in %key_to_array_of_dep_keys
# and elements in the arrays of dependencies may be strings, numbers, 
# references or any other scalar data type. If any key or the list of
# dependencies is undefined, it is handled like a node with no dependencies
# and will be ignored. If a ref to the @depths array is provided, this array
# will be filled with integers representing the recursion depth of $from 
# (at depth 0) and each subsequent dependency.
#
# The $found and $out arguments are internally used during recursion only.
#

sub topological_sort_dependencies { # prototype (+$;+$++)
  my ($h, $from, $depths, $depth, $found, $out) = @_;

  $depth //= 0;
  $found //= { };
  $out //= [ ];

  my $deps = $h->{$from} // \@empty_array;
  if (!ref $deps) { $deps = [ $deps ]; };

  foreach my $dep (@$deps) {
    next if (!defined $dep);
    if (exists $found->{$dep}) { return $dep; }
    topological_sort_dependencies($h, $dep, $depths, $depth+1, $found, $out);
  }

done:
  if (defined $depths) { push @$depths, $depth; }
  push @$out,$from;

  return $out;
}

sub masked_store_into_array(+$$) {
  my ($array, $value, $mask) = @_;

  foreach my $item (@$array) {
    $item = $value if (($mask & 1) == 1);
    $mask >>= 1;
  }

  return $array;
}

sub compare_vec_to_scalar_and_generate_bitmask(+$) {
  my ($array, $value) = @_;
  my $n = sizeof($array);
  my $b = 0;
no warnings; # it's OK if we compare undef to undef:
  for (my $i = $n-1; $i >= 0; $i--) {
    $b <<= 1;
    $b |= (($array->[$i] == $value) ? 1 : 0);
  }
use warnings;
  return $b;
}

#
# Relations for comparisons
#
use constant {
  COMPARE_EQ =>  1,
  COMPARE_NE => -1,
  COMPARE_GE =>  2,
  COMPARE_LT => -2,
  COMPARE_GT =>  3,
  COMPARE_LE => -3,
  COMPARE_MASK_ALL     =>  4,
  COMPARE_MASK_NOT_ALL => -4,
  COMPARE_MASK_ANY     =>  5,
  COMPARE_MASK_NONE    => -5,
  COMPARE_REGEXP       =>  6,
  COMPARE_NOT_REGEXP   => -6,
};

#
# Combinators and modifiers for relations
#
use constant enum qw(
  COMPARE_TO
  COMPARE_NOT
  COMPARE_AND
  COMPARE_OR
  COMPARE_XOR
  COMPARE_ANDNOT
  COMPARE_NOR
);

#
# Comparison types
#
use constant enum qw(
  COMPARE_INTEGERS
  COMPARE_STRINGS
);

sub compare_integers($$$) {
  my ($a, $b, $rel) = @_;
  my $inv = ($rel < 0) ? 1 : 0;
  $rel = ($inv) ? -$rel : $rel;

  my $out = 
    ($rel == COMPARE_EQ) ? ($a == $b) :
    ($rel == COMPARE_GE) ? ($a >= $b) :
    ($rel == COMPARE_GT) ? ($a >  $b) :
    ($rel == COMPARE_MASK_ALL) ? (($a & $b) == $b) :
    ($rel == COMPARE_MASK_ANY) ? (($a & $b) != 0) :
    undef;

  return (defined $out) ? (($out ? 1 : 0) ^ $inv) : undef;
}

sub compare_strings($$$) {
  my ($a, $b, $rel) = @_;

  my $inv = ($rel < 0) ? 1 : 0;
  $rel = ($inv) ? -$rel : $rel;

  my $out = 
    ($rel == COMPARE_EQ) ? ($a eq $b) :
    ($rel == COMPARE_GE) ? ($a ge $b) :
    ($rel == COMPARE_GT) ? ($a gt  $b) :
    ($rel == COMPARE_REGEXP) ? ($a =~ $b) :
    undef;

  return (defined $out) ? (($out ? 1 : 0) ^ $inv) : undef;
}

#
# Compare items from an array against a tree of expressions
# in the following form:
#
#   <id>    := array index in @input array (value is $input[<id>])
#   <term>  := [ COMPARE_TO, <id>, <relation>, <literal> ]
#   <expr>  := [ <combinator>, <term>, <term>, ... ]
#
# Example:
# 
#   my $input = [ 111, 222, 'text here' ];
#
#   my $expr  = [
#     COMPARE_OR,
#     [ COMPARE_TO, 0, COMPARE_GT, 500 ],  # $input[0] > 500
#     [ COMPARE_AND,
#       [ COMPARE_TO, 1, COMPARE_LT, 300 ], # $input[1] < 300
#       [ COMPARE_TO, 2, COMPARE_REGEXP, qr{here}oax ],  # $input[2] =~ /here/oax
#     ],
#   ],
#
#   $result = compare_with_expression($input, $expr);
#
#   (in this case, $result == 1):
#
sub compare_with_expression(++) {
  my ($input, $expr) = @_;

  my $combinator = $expr->[0];
  # my $ok = ...
  # foreach ...
  # (TODO)
}

#
# ($nearest_value, $index, $relation) = binary_search($target, @array) or
# ($nearest_value, $index, $relation) = binary_search($target, @array, \&func):
#
# Performs a binary search for $target (a string or number) in the sorted
# array @array to find the value nearest the specified target value.
#
# Returns ($nearest_value, $index_where_found, $relation), where $relation
# is -1, 0 or 1 to express the result of comparing the $nearest_value result
# against the target value. In scalar context, only returns $nearest_value.
#
# The optional comparator argument is reference to a function that will
# be passed the values of two elements from @array to compare using the
# same ordering and -1/0/1 return values as Perl's cmp and <=> operators.
#
# The input @array must be sorted in ascending order and cannot contain
# duplicate values; otherwise erroneous results may be returned or this
# function may even go into an infinite loop and will never return.
#

sub binary_search(+$;&$) {
  my ($t, $array, $comparator, $start) = @_;
  my $is_string = is_string($t);

  if ((!defined $array) || (!defined $t)) { return ( ); }

  my $e = $#{$array};
  my $l = 0;
  my $h = $e;

  my ($v, $c);
  my $i = $start // (($l + $h) / 2);

  while (1) {   
    $v = $array->[$i];
    $c = (defined $comparator) ? $comparator->($v, $t) :
      ($is_string) ? ($v cmp $t) : ($v <=> $t);

    last if ((!$c) || ($h <= $l));
    
    $l = ($c < 0) ? (($i < $e) ? ($i+1) : $e) : $l;
    $h = ($c < 0) ? $h : (($i > 0) ? ($i-1) : 0);
    $i = ($l + $h) / 2;
  }
  
  return (wantarray ? ($v, $i, $c) : $v);
}

#
# @offsets or $offsets = create_line_offset_map($text):
#
# Given an input string with lines separated by "\n" newline characters,
# this function returns an array of offsets in the input string of the
# start of each line. This may be passed to find_line_containing_offset()
# (see below) to efficiently determine which line number a given offset
# falls within.
#

my $newline_re = qr{\n}oamsx;

sub create_line_offset_map($) {
  my ($text) = @_;

  my @offsets = ( 0 );

  while ($text =~ /$newline_re/oamsxg) { push @offsets, (pos $text); }

  #
  # If the file ends with a newline, remove the final empty 
  # line to match the traditional definition of line counts:
  #
  if ($offsets[-1] == (length $text)) { pop @offsets; }

  return (wantarray ? @offsets : \@offsets);
}

#
# $line = find_line_containing_offset($string, $offset, $map):
#
# Given an offset within a string S and an array generated using
# create_line_offset_map(S), this function returns the line number
# containing that offset, or undef if the offset is outside S.
#
sub find_line_containing_offset($$+) {
  my ($string, $offset, $line_to_offset_map) = @_;
  
  my $last = $line_to_offset_map->[-1] // -1;
  if (($offset < 0) || ($offset >= $last)) { return undef; }

  my ($nearest_offset, $line, $relation) = 
    binary_search($offset, $line_to_offset_map);

  $line = ($relation < 0) ? $line : (($line > 0) ? ($line-1) : 0);
  my $start_offset = $line_to_offset_map->[$line];
  my $col = $nearest_offset - $start_offset;

  return (wantarray ? ($line, $col, $start_offset) : $line);
}

1;
