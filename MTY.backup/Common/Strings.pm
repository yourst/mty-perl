#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Common::Strings
#
# Character string and text related utility functions
# (except for regular expressions, which are in MTY::RegExp::*)
#
# Copyright 1997 - 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Common::Strings;

use integer; use warnings; use Exporter qw(import);

use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Common::PrintDebug;
use MTY::RegExp::Define;
use MTY::RegExp::Strings;
use MTY::RegExp::Blocks;
use MTY::Display::ANSIColorREs;

use Text::Tabs ();
#pragma end_of_includes

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($control_chars_re %boolean_words @powers_of_1024_unit_names ALIGN_CENTER
     ALIGN_JUSTIFIED ALIGN_LEFT ALIGN_RIGHT add_prefix_and_suffix
     add_prefix_and_suffix_in_place append_with_sep
     chop_off_start_and_end_markers contains count_and_remove_leading_spaces
     count_and_remove_trailing_spaces count_lines count_matching_chars
     count_non_matching_chars delimited_strings_to_subarrays ends_with
     format_size_with_units hexstring insert_thousands_separators
     interpolate_control_chars join_around join_undefs join_undefs_with_sep
     join_with_prefix_and_suffix length_with_thousands_separators maxlength
     padstring padstring_with_suffix padstrings
     parse_list_of_key_equals_value_into_hash printed_length
     recursively_process_strings remove_from_end remove_from_start
     remove_leading_space remove_leading_trailing_space 
     remove_leading_trailing_space_and_undef_if_empty remove_trailing_space
     remove_with_regexp_and_return_removed_char_count replace_unicode_chars
     sep_if_not_first split_into_words_and_line_breaks starts_with
     substitute_placeholders truncate_printed_string truncate_printed_strings
     word_wrap_long_lines wrap_long_lines);

# Re-export these from PrintDebug package for convenience:
push @EXPORT, @MTY::Common::PrintDebug::EXPORT;

sub contains($$) {
  return (index($_[0], $_[1]) >= 0) ? 1 : 0;
}

sub starts_with($$) {
  my ($s, $prefix) = @_;
  return (((length $s) >= (length $prefix)) && (substr($s, 0, length($prefix)) eq $prefix)) ? 1 : 0;
}

sub ends_with($$) {
  my ($s, $suffix) = @_;
  return (((length $s) >= (length $suffix)) && (substr($s, -length($suffix), length($suffix)) eq $suffix)) ? 1 : 0;
}

sub remove_from_start($$) {
  my ($s, $prefix) = @_;
  my $n = length($prefix);
  return (((length $s) >= $n) && (substr($s, 0, $n) eq $prefix)) ? substr($s, $n) : $s;
}

sub remove_from_end($$) {
  my ($s, $suffix) = @_;
  my $n = length($suffix);
  return (((length $s) >= $n) && (substr($s, -$n, $n) eq $suffix)) ? substr($s, 0, (length $s) - $n) : $s;
}

sub join_undefs_with_sep($@) {
  my ($sep, @list) = @_;

  return join($sep, (map { $_ // $undef_placeholder } @list));
}

sub join_undefs {
  return join('', (map { $_ // $undef_placeholder } @_));
}

our %boolean_words = (
  '0' => 0,
  'no' => 0,
  'n' => 0,
  'false' => 0,
  'f' => 0,
  'off' => 0,
  'disable' => 0,
  'disabled' => 0,
  'without' => 0,
  'skip' => 0,
  'exclude' => 0,
  '-' => 0,

  'not' => -1,
  '~' => -1,
  '^' => -1,

  '1' => 1,
  'yes' => 1,
  'y' => 1,
  'true' => 1,
  't' => 1,
  'on' => 1,
  'enable' => 1,
  'enabled' => 1,
  'with' => 1,
  'use' => 1,
);

sub append_with_sep($$$) {
  $_[0] .= $_[2] if (length($_[0]) > 0);
  $_[0] .= $_[1];
  return $_[0];
}

#
# count_matching_chars($string_to_search, $chars_to_match):
#
# Given the set of individual characters in <$chars_to_match>, return the total
# number of characters in <string_to_search> that appear in this set (multiple
# appearances of any character(s) in <string_to_search> are counted each time
# they appear).
#

sub count_matching_chars($$) {
  return ($_[0] =~ tr/$_[1]//);
}

sub count_non_matching_chars($$) {
  return ($_[0] =~ tr/$_[1]//c);
}

sub count_lines($) {
  my $n = 0;
  foreach my $arg (@_) { $n += ($_[0] =~ tr/\n//s); }
  return $n;
}

our $control_chars_re = compile_regexp
  (qr{\\([abentrf])}oamsx, 'control_chars');

my %control_char_escapes_to_chars = 
  ('a' => "\a",
   'b' => "\b",
   'e' => "\e",
   'n' => "\n",
   't' => "\t",
   'r' => "\r",
   'f' => "\f");

sub interpolate_control_chars($) {
  return $_[0] =~ 
    s{$control_chars_re}
     {$control_char_escapes_to_chars{$1} // ('\\'.$1)}roamsxge;
}

#
# $outstring = chop_off_start_and_end_markers($instring, $startchar, $endchar):
#
sub chop_off_start_and_end_markers($$$) {
  local (*s, *startchar, *endchar) = \ (@_);

  my $ec = chop($s);
  if ((ord($ec) ne ord($endchar)) || (ord($s) != ord($startchar))) {
    die('chop_off_start_and_end_markers('.$s.', '.$startchar.', '.$endchar.'): '.
        'real start was '.chr(ord($s)).' and end was '.$ec."\n");
  }
  return substr($s, 1, length($s)-1);
}

#
# maxlength($string1, $string2, ...):
# 
# Returns the length in characters of the longest string in the specified list.
#
# NOTE: This finds the raw length in characters; if you want the visual appearance 
# based printed length (taking into account control codes, special glyphs and tabs),
# use printed_length() instead (see below).
#

sub maxlength {
  my $m = 0;
  foreach my $s (@_) { set_max($m, length($s // '')); }
  return $m;
}

#
# printed_length($string1, $string2, ...):
#
# This function finds the true length of a string in printable characters:, even with 
# strings containing embedded console escape codes (e.g. for colors and attributes), 
# since it doesn't count those escapes when it calculates the true length of the string
# (unlike perl's length() function). It also expands each tab (\t) into 8 spaces.
#
# If multiple strings are specified as a list, printed_length() returns the length
# of the longest string in the list (*not* the sum of the lengths).
#

sub printed_length {
  my $maxlength = 0;
  foreach my $s (@_) {
    next if (!defined($s));
    my $n = length($s);
    my $nonprinted_or_unicode_count = ($s =~ tr/\x00-\x1F\xD0-\xEF//);
    if ($nonprinted_or_unicode_count > 0) {
      # slow path: only do the following if the string contains control chars:
      $n = length(Text::Tabs::expand($s =~ s/$ansi_console_escapes_and_nonprinted_characters_re//roamsxg)); 
    }
    set_max($maxlength, $n);
  }
  return $maxlength;
}

sub truncate_printed_string($$) {
  my ($s, $limit) = @_;

  return '' if ((!defined($_[0])) || ((length $_[0]) == 0) || ($_[1] == 0));
  # fast path: avoid the following unless string has control chars:
  if ($_[0] !~ tr/\x00-\x1F//s) { return substr($_[0], 0, $_[1]); }

  if ($s =~ tr/\t//s) { $s = Text::Tabs::expand($s); }

  set_min($limit, length($s));
  pos($s) = 0;
  my $n = 0;

  while ($n < $limit) {
    if ($s =~ /$ansi_console_escapes_and_nonprinted_characters_re/oamsxg) {
      ; # no action needed - just skip over these char(s), since they aren't printable
    } elsif ($s =~ /$printable_chars_re/oamsxg) {
      my $span_length = ($+[0] - $-[0]);
      my $over_length = ($n + $span_length) - $limit;
      if ($over_length > 0) { 
        $span_length -= $over_length;
        pos($s) = pos($s) - $over_length;
        $n = $limit;
        last;
      }
      $n += $span_length;
    }
  }

  return substr($s, 0, pos($s));
}

sub truncate_printed_strings {
  my $limit = shift;
  foreach my $s (@_) {
    $s = printed_substr($s, $limit);
  }

  return (wantarray ? @_ : \@_);
}

sub recursively_process_strings {
  my ($obj, $callback, @extra_args) = @_;

  my $type = typeof($obj);
  if ($type == STRING) {
    $_[0] = $callback->($obj, @extra_args);
  } elsif ($type == STRING_REF) {
    ${$obj} = $callback->(${$obj}, @extra_args);
  } elsif (($type == ARRAY_REF) || ($type == HASH_REF)) {
    foreach my $elem (($type == HASH_REF) ? %$obj : @$obj) {
      if (is_string($elem)) {
        $elem = $callback->($elem, @extra_args);
      } elsif (is_scalar($elem)) {
        next; # no need to recurse into it
      } else { # must be nested array ref or hash ref (or anything else we just ignore)
        recursively_process_strings($elem, $callback, @extra_args);
      }
    }
  }
}

sub replace_unicode_chars(+) {
  my ($arg) = @_;
  
  my $type = typeof($arg);
#  if ($type == ARRAY_REF) {
#    return map { ppreplace_unicode_chars
#++MTY TODO
}

use constant {
  ALIGN_LEFT => -1,
  ALIGN_CENTER => 0,
  ALIGN_RIGHT => +1,
  ALIGN_JUSTIFIED => -1
};

#
# padstring($string, $alignment, $desired_length_in_chars, 
#   $optional_padding_string_to_repeat, $fill_right_when_centered, $suffix):
#
# Pad a string to the desired length in characters by repeating the padding string (or
# a single space (" ") if no padding is specified) until the combined length of the string
# plus the padding is at least the desired length (it may be longer than this if the string's
# length already exceeds the desired length, in which case no padding will be used).
#
# This function works correctly even with strings containing embedded console escape
# codes  (e.g. for colors and attributes); see printed_length() for details on this. Only the
# string may contain escape codes; the pad must only contain spaces or printable characters.
#
# In cases where the string would normally contain such escape codes (and optionally more text
# after them), padstring() will be more efficient if the escape codes and any subsequent text
# (which should be the same length if padstring() is being used to align columns) are removed
# from $string and instead placed in the $suffix argument (whose length is *not* counted when
# determining how much padding to insert). This optimization allows the normal lengthof() to
# be used on $string without the overhead of having to first remove its control codes.
#
# (For convenience the padstring_with_suffix() function is equivalent to this but without
# having top pass undef for the intervening arguments before $suffix).
#
sub padstring($$;$$$$) {
  my ($width, $align, $pad, $fill_right_when_centered, $suffix) = @_[1..5];
  my $rs = undef;

  if (!defined $_[0]) { return '<undef>'; }

  $align //= -1;
  $pad //= ' ';
  $fill_right_when_centered //= 0;

  # Negative width means align to the right:
  if ($width < 0) { $width = -$width; $align = +1; }
  my $len = printed_length($_[0]);
  if (length($pad) > 1) { $pad = substr($pad, 0, 1); }

  if ($len > $width) {
    $rs = substr($_[0], 0, $width);
    $len = min(printed_length($rs), $width);
  }

  my $n = $width - $len;
  my $leftpad; my $rightpad;

  if ($align == 0) { 
    # (0 = centered):
    my $n2 = int($n / 2);
    my $leftover = $width - ($n2 + $len + $n2);
    $leftpad = $n2;
    $rightpad = ($fill_right_when_centered ? ($n2 + $leftover) : 0);
  } elsif ($align < 0) {
    # (-1 = left):
    $leftpad = 0;
    $rightpad = $n;
  } elsif ($align > 0) {
    $leftpad = $n;
    $rightpad = 0;
  }

  return (($pad x $leftpad) . ($rs // $_[0]) . ($suffix // '') . ($pad x $rightpad));
}

sub padstring_with_suffix($$$;$) {
  my ($string, $suffix, $width, $alignment) = @_;
  return padstring($string, $width, $alignment, undef, undef, $suffix);
}

sub padstrings(+$;$$) {
  my $array = shift;
  foreach my $s (@$array) {
    $s = padstring($s, @_);
  }
  return $array;
}

sub hexstring($;$;$) {
  my ($value, $width, $pad) = @_;
  my $format = '0x%'.((($width // 0) < 0) ? '-' : '').
    ($pad // '').((defined $width) ? abs($width) : '').'llx';

  return sprintf($format, $value);
}

#
# join_with_prefix_and_suffix($prefix, $suffix, $sep, @list): 
# wrap a $prefix and $suffix around each item in the list of arguments, 
# then return a string of these wrapped items separated by $sep. (This
# is essentially an enhanced version of perl's join() function):
#

sub add_prefix_and_suffix {
  my ($prefix, $suffix, $listref) = @_;

  if (!is_array_ref($listref)) { $listref = \@_[2..scalar(@_)-1]; }
  my @out = map { $prefix.$_.$suffix; } @$listref;
  return (wantarray ? @out : \@out);
}

sub add_prefix_and_suffix_in_place {
  my ($prefix, $suffix, $listref) = @_;

  if (!is_array_ref($listref)) { $listref = \@_[2..scalar(@_)-1]; }
  foreach my $elem (@$listref) { $elem = $prefix.$elem.$suffix; }
  return (wantarray ? @$listref : $listref);
}

sub join_around($$$@) {
  my ($left, $sep, $right, @list) = @_;
  return $left.join($right.$sep.$left, @list).$right;
}

sub join_with_prefix_and_suffix {
  my ($prefix, $suffix, $separator, $listref) = @_;

  if (!is_array_ref($listref)) { $listref = \@_[3..scalar(@_)-1]; }
  if (!@$listref) { return $always_fail_re; }
  return $prefix.join($suffix.$separator.$prefix, @$listref).$suffix;
}

#
# Alternative regexps for removing leading and trailing whitespace:
#
#   m/\A \s* (.*?) \s* \Z/oamsxg      or:      s/^\s+ | \s+$/oamsxg
#   (sets $1)                                  (replaces original)
#
#                                     or:      s/^\s+//oamsx;
#                                              s/\s+$/oamsx/;
#                                              (even more efficient)
#

my $leading_spaces_re = qr{^\s*+}oamsx;
my $trailing_spaces_re = qr{\s*+$}oamsx;

sub remove_with_regexp_and_return_removed_char_count {
  return undef if (!defined($_[0]));
  my $re = $_[1] // $trailing_spaces_re;
  my $n = length($_[0]);
  $_[0] =~ s{$re}{}oamsxg;
  return ($n - length($_[0]));
}

sub count_and_remove_leading_spaces {
  return remove_with_regexp_and_return_removed_char_count($_[0], $leading_spaces_re);
}

sub count_and_remove_trailing_spaces {
  return remove_with_regexp_and_return_removed_char_count($_[0], $trailing_spaces_re);
}

sub remove_leading_space {
  return undef if (!defined($_[0]));
  return ($_[0] =~ s/$leading_spaces_re//roamsxg);
}

sub remove_trailing_space {
  return undef if (!defined($_[0]));
  return ($_[0] =~ s{$trailing_spaces_re}{}roamsxg);
}

sub remove_leading_trailing_space($) {
  return undef if (!defined($_[0]));
  return ($_[0] 
          =~ s/$leading_spaces_re//roag
          =~ s/$trailing_spaces_re//roag);
}

sub remove_leading_trailing_space_and_undef_if_empty($) {
  return undef if (!defined($_[0]));
  my $s = ($_[0] 
           =~ s/$leading_spaces_re//roag
           =~ s/$trailing_spaces_re//roag);
  return (length($s) > 0) ? $s : undef;
}

sub sep_if_not_first($;$) {
  my $sep = $_[1] // ' ';
  return ((defined $_[0]) && ((length $_[0]) > 0)) ? $sep : '';
}

my $spaces_or_tabs_or_newline_re = qr{(\n | [\ \t]++)}oamsx;

my $split_into_words_and_line_breaks_re = 
  qr{[\ \t]*+ (\S++ | \n)}oamsx;

sub split_into_words_and_line_breaks(+) {
  my ($s) = @_;
  my @a = ( );
  while ($s =~ /$split_into_words_and_line_breaks_re/oamsxg) 
    { push @a, (($1 eq NL) ? undef : $1); }
  return (wantarray ? @a : \@a);
}

sub wrap_long_lines(+;$$$$$$) {
  my ($list_or_string, $maxlength, $sep, $first_line_prefix, $subsequent_line_prefix, $suffix, $initial) = @_;

  $maxlength //= 78;
  $sep //= ' ';
  $subsequent_line_prefix //= ($first_line_prefix // '  ');
  $first_line_prefix //= '';
  $suffix //= '';
  $initial //= '';

  my $list = is_array_ref($list_or_string) ? $list_or_string : 
    split_into_words_and_line_breaks($list_or_string);

  my $sep_length = length($sep);
  my $first_line_prefix_length = printed_length($first_line_prefix);
  my $subsequent_line_prefix_length = printed_length($subsequent_line_prefix);

  my $accum_line = $first_line_prefix;
  my $char_count_so_far = printed_length($initial) + $first_line_prefix_length;
  my $word_in_line = 0;
  my @out = ( );

  foreach my $word (@$list) {
    my $force_nl = 0;
    if (!defined $word) { $force_nl = 1; $word = ''; }
    my $n = printed_length($word);
    my $sepn = (($word_in_line > 0) ? $sep_length : 0);

    if ((($char_count_so_far + $sepn + $n) > $maxlength) || $force_nl) {
      $accum_line .= $suffix;
      push @out, $accum_line;
      $accum_line = $subsequent_line_prefix;
      $sepn = 0; # no word separator at start of new line
      $char_count_so_far = $subsequent_line_prefix_length;
      $word_in_line = 0;
    }

    $accum_line .= (($word_in_line > 0) ? $sep : '') . $word;
    $char_count_so_far += $sepn + $n;
    $word_in_line++;
  }

  if (length $accum_line) {
    $accum_line .= $suffix;
    push @out, $accum_line; 
  }

  return (wantarray ? @out : join(NL, @out));
}

sub word_wrap_long_lines($;$$$$) {
  my ($s, $maxlength, $first_line_prefix, $subsequent_line_prefix, $suffix, $initial) = @_;

  return wrap_long_lines($s, $maxlength, ' ', $first_line_prefix, $subsequent_line_prefix, $suffix, $initial);
}

sub delimited_strings_to_subarrays(+;$) {
  my ($rows, $delim) = @_;

  return [ map { [ split($delim, $_) ] } @$rows ];
}

my $placeholder_re = qr{(?! \\) % ((?| ([^\{]) | \{ ([^\}]++) \}))}oamsx;

sub substitute_placeholders($+) {
  my ($format, $placeholder_to_var_ref) = @_;

  return ($format =~ s{$placeholder_re}{
    my $valueref = $placeholder_to_var_ref->{$2};
    my $value = (is_code_ref $valueref) ? $valueref->($2, $1) : 
      (is_ref $valueref) ? $$valueref : $valueref;
    $value;
  }roamsxge);
}

sub parse_list_of_key_equals_value_into_hash($;+$) {
  my ($s, $hash, $default_value) = @_;
  $hash //= { };
  $default_value //= undef;

  while ($s =~ /$key_equals_or_colon_value_comma_re/oamsxg) {
    my ($key, $value) = ($1, $2);
    $hash->{$key} = $value // $default_value;
  }

  return $hash;
}

my $groups_of_3_digits_re = qr{\d\d\d \K (?= \d)}oax;

sub insert_thousands_separators($;$) {
  my ($s, $sep) = @_;
  $sep //= ',';

  my $n = length($s);
  if ($n <= 3) { return $s; }

  my $mod = $n % 3;
  return 
    substr($s, 0, $mod).
    (($mod > 0) ? $sep : '').
      (substr($s, $mod) =~ s{$groups_of_3_digits_re}{$sep}roaxg);
}

sub length_with_thousands_separators($;$) {
  my ($s, $sep) = @_;
  $s = "$s";
  $sep //= ',';

  my $n = length($s);
  return $n + (($n <= 3) ? 0 : ((($n - 1) / 3) * length($sep)));
}

our @powers_of_1024_unit_names = (' ', 'K', 'M', 'G', 'T', 'P', 'E');

sub format_size_with_units($;$$$$$) {
  my ($size, $max_decimal_digits, $separator, $units_prefix, $units_suffix, $custom_powers_of_1024_unit_names) = @_;
  $max_decimal_digits //= 7;
  $separator //= ',';
  $units_prefix //= ' ';
  $units_suffix //= 'b';
  $custom_powers_of_1024_unit_names //= \@powers_of_1024_unit_names;

  my $powers_of_1024 = 0;
  my $n = $size;

  while (length("$n") > $max_decimal_digits) {
    $n = ($n + 512) >> 10; 
    $powers_of_1024++;
  }

  my $sizestr = (is_there($separator)) ? insert_thousands_separators($n, $separator) : "$n";

  if ($powers_of_1024 > 0) {
    $sizestr .= $units_prefix.
      ($powers_of_1024_unit_names[$powers_of_1024] // '?').$units_suffix;
  }

  return $sizestr;
}

1;
