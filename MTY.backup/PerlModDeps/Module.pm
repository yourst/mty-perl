# -*- cperl -*-
#
# MTY::PerlModDeps::Module
#
# Copyright 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::PerlModDeps::Module;

use integer; use warnings; use Exporter qw(import);

use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Common::Strings;

use MTY::Filesystem::Files;

use MTY::Display::Colorize;
use MTY::Display::ColorizeErrorsAndWarnings;
use MTY::Display::PrintableSymbols;
use MTY::Display::PrintableSymbolTools;
use MTY::Display::Tree;
use MTY::Display::PPITreeFormatter;
use MTY::Display::TextInABox;

use MTY::RegExp::Define;
use MTY::RegExp::Tools;
use MTY::RegExp::PerlRegExpParser;
use MTY::RegExp::PerlSyntax;
use MTY::Common::PerlSourceTools;
use MTY::RegExp::Blocks;
use MTY::RegExp::Strings;
use MTY::RegExp::Numeric;
use MTY::System::POSIX;

use MTY::PerlModDeps::Common;


use PPI;
use PPI::Document;
use PPI::Token;
use PPI::Statement;
use PPI::Structure;
use PPI::Cache;
use PPI::Dumper;

use File::Basename qw(fileparse);
#pragma end_of_includes

nobundle:; our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(add_module_or_program add_module_to_bundle analyze_ppi_subtree
     check_for_same_export_name_in_other_modules_and_add extract_constants
     parse_module read_and_check_file);

my $perl_qw_identifier_list_re = 
  qr{\b qw [^\w\s] \s*+ ([\w\s]++) [^\w\s]}oamsx;

noexport:; sub extract_constants($;+) {
  my ($node, $constants) = @_;

  $constants //= [ ];

  my $enum_keywords = $node->find(
    sub { 
      my $c = $_[1]->content;
      $_[1]->isa('PPI::Token::Word') && (($c eq 'enum') || ($c eq 'enumbits')) 
    });

  my $is_enum = (scalar @$enum_keywords) ? 1 : 0;

  my $const_constructor = $node->find_first('PPI::Structure::Constructor');
  my $enum_list_constructor = $node->find_first('PPI::Structure::List');
  my $enum_qw_constructor = $node->find_first('PPI::Token::QuoteLike::Words');

  my $exprlist = undef;

  if ($is_enum && (defined $enum_list_constructor) && (!!$enum_list_constructor)) {
    $exprlist = $enum_list_constructor->find_first('PPI::Statement::Expression');
    $exprlist = (defined $exprlist) ? $exprlist->{children} : undef;
  } elsif ($is_enum && (defined $enum_qw_constructor) && (!!$enum_qw_constructor)) {
    # This is a special case that returns directly since PPI's QuoteLike::Words
    # class doesn't further subdivide the word list into expressions:
    my ($qw) = (($enum_qw_constructor->content) =~ /$perl_qw_identifier_list_re/oamsx);
    my @words = split(/\s+/oamsx, $qw);
    push @$constants, @words;
    return (wantarray ? @{$constants} : $constants);
  } elsif ((defined $const_constructor) && (!!$const_constructor)) {
    # List of constants, i.e. "use constant { A => 123, B => 456, ... };" 
    # where the part inside the { ... } is a PPI::Statement::Expression
    # nested within a PPI::Structure::Constructor in this node's list:
    $exprlist = $const_constructor->find_first('PPI::Statement::Expression');
    # Notice we use schildren here instead of children, since "s" means 
    # (s)ignificant, i.e. excluding any whitespace or comment tokens:
    $exprlist = (defined $exprlist) ? $exprlist->{children} : undef;
  } else {
    # Simple one-liner "use constant XYZ => abc;" form: we handle this exactly
    # like the multi-constant expression list above, but the list is simply the
    # original PPI::Statement::Include node's list of children, and it only has
    # one constant to the left of the '=>' operator.
    $exprlist = $node->{children};
  }

  # Only examine a non-null expression list (it could be null if the code 
  # contains some valid but pointless construct like "use constant { };"):
  if (defined $exprlist) {
    foreach my $obj (@$exprlist) {
      if ($is_enum && (defined $enum_list_constructor)) {
        if ($obj->isa('PPI::Token::Word')) {
          my $const_name = $obj->content;
          push @$constants, $const_name; 
        } elsif ($obj->isa('PPI::Token::Quote::Single')) {
          my ($const_name) = ($obj->content =~ /$single_quoted_string_re/oamsx);
          push @$constants, $const_name;
        }
      } elsif ($obj->isa('PPI::Token::Operator') && ($obj->content eq '=>')) {
        # the previous (significant) Word token is always the constant's name:
        my $const_name = $obj->sprevious_sibling();
        # check for a major syntax error, i.e. "use constant { <= 0; }"
        # with no constant name before the value mapping operator:
        die if (!defined $const_name); 
        push @$constants, $const_name;
      }
    }
  }

  return (wantarray ? @{$constants} : $constants);
}

sub add_module_or_program($) {
  my $filename = $_[0];

  if (!((-f $filename) || (-l $filename) || (-p $filename))) {
    # Don't try to process directories here - let the caller use wildcards:
    return undef;
  }

  # We add an extra possible space for every directory component (/), since these
  # slashes will most likely become '::' once we know the real perl module name:
  my $guessed_module_name = $filename
    =~ s{$remove_modpath_re}{}roag
    =~ s{/}{::}roag;

  my $n = length($guessed_module_name);
  $max_module_name_length = max($max_module_name_length, length($guessed_module_name));

  my %modinfo = (
    index => scalar(@modlist),
    filename => $filename,
    module_name => undef,
    code => undef,
    origcode => undef,
    preserve => 0,
    # ref to hash of symbol name => ref to PPI::Node of declaration:
    # for constants, keys (names) are prefixed with '=':
    exports => { },
    # ref to hash of symbol name => 
    #   tag string (if a tagged export), or undef (if an optional export):
    # for constants, keys (names) are prefixed with '=':
    optional_or_tagged_exports => { },
    # ref to hash (symbol_name => (number of refs to that symbol))
    imported_symbols => { },
    # ref to hash (explicitly imported module name => 1)
    explicitly_imported_modules => { },
    # ref to hash (module_name => ($ref -> %module))
    imported_modules => { },
    # ref to hash (module_name => ($ref -> $module))
    dependent_modules => { },
    # ref to hash (symbol name => 1)
    known_local_symbol_names => { },
    # ref to hash of (fully qualified bundle name => 
    #                 ref to array of all modules in that bundle)
    # (unless 'nobundle' attribute is set)
    bundle_name => { },
  );
  
  push @modlist, \%modinfo;
  return \%modinfo;
}

sub read_and_check_file($$) {
  my ($m, $warning_prefix) = @_;

  my $filename = $m->{filename};

  my $warning = undef;

  if ($filename =~ /^\.\#/) {
    $warning = 'an Emacs autosave file';
  } elsif ($filename =~ /\~$/) {
    $warning = 'an Emacs backup file';
  } elsif ((!$is_stdio) && (!((-f $filename) || (-p $filename)))) {
    $warning = 'neither a file, nor a pipe, nor a terminal';
  } elsif (! -r $filename) {
    $warning = 'not readable (check permissions and/or ACLs)';
  }

  if (defined $warning) { goto invalid_file; }

  my $origcode = read_file($filename);

  if (!defined $origcode) { 
    $warning = 'not readable (errno '.($!).', extended error '.($^E).')'; 
    goto invalid_file;
  }

  $m->{origcode} = $origcode;

  my $code = $origcode;
  $m->{code} = $code;

  my ($scope, $module_name) = ($code =~ /$perl_package_decl_re/oamsx);

  $m->{module_name} = $module_name;
  my $is_module = (defined $module_name) ? 1 : 0;

  if (is_empty($module_name) && (!($filename =~ /\.p[lmh]$/oaxi))) {
    if (!($origcode =~ /$perl_program_first_line_shebang_re/oamsx)) {
      $warning = ($DEBUG) ? 'neither a Perl package (missing a package name declaration) '.
        'nor a Perl program (missing #!/usr/bin/perl)' : undef;
      goto invalid_file;
    }
  }
  
  my $effective_filename = 
    ($is_module) ? (($module_name =~ s{::}{/}roamsxg).'.pm') : $filename;

  $m->{effective_filename} = $effective_filename;

  $module_name_or_filename_to_module{$module_name} = $m if (defined $module_name);
  $module_name_or_filename_to_module{$effective_filename} = $m;
  $module_name_or_filename_to_module{$filename} = $m;

  # File appears to be OK:
  return $m;
  
invalid_file:
  printfd(STDERR, $warning_prefix.$warning.$X.NL) if (defined $warning);
  return undef;
}

my $equals_prefixed_constant_flag_re = qr{^\=(\w+)$}oax;

sub check_for_same_export_name_in_other_modules_and_add(+$$$;+) {
  my ($m, $name, $export_optional, $export_tag_label, $node) = @_;

  my $name_prefix = '';
  if ($name =~ /$equals_prefixed_constant_flag_re/oax) 
    { $name = $1; $name_prefix = '='; }

  my $existing_def_mod = $symbol_to_defining_module{$name};
  
  if ((defined $existing_def_mod) && ($existing_def_mod->{module_name} ne $m->{module_name})) {
    warning('Symbol '.$G.$name.$R.' was already '.
      $R.'exported by module '.$Y.$existing_def_mod->{module_name}.$R.'; '.
      $R.'overriding with new definition in module '.$Y.$m->{module_name}.$R) unless $no_warnings;
  }
  
  $symbol_to_defining_module{$name} = $m;
  $m->{exports}->{$name_prefix.$name} = $node;
  if ($export_optional || defined($export_tag_label)) {
    my $v = 
    $m->{optional_or_tagged_exports}->{$name_prefix.$name} =
      (defined $export_tag_label) ? $export_tag_label :
        ($export_optional ? undef : undef);
  }

  return (defined $existing_def_mod) ? 1 : 0;
}

sub add_module_to_bundle($$) {
  my ($m, $bundle_name) = @_;

  my $parent_namespace = parent_package_name($m->{module_name});
  $bundle_name = $parent_namespace.(($bundle_name ne '') ? '::'.$bundle_name : '');
  my $other_mods_in_bundle = append_to_hash_of_arrays(%bundle_name_to_list_of_modules, $bundle_name, $m);
  $m->{bundle_name}->{$bundle_name} = $other_mods_in_bundle;
  return $other_mods_in_bundle;
}

sub analyze_ppi_subtree {
	my ($node, $parent, $m, $level) = @_;

  $level //= 0;

  my $nodetype = ref($node);

  return undef if ($nodetype eq 'PPI::Token::Whitespace' ||
                    $nodetype eq 'PPI::Token::Comment');

  my $subnodes = $node->{children} // [ ];

  my $is_module = (defined ($m->{module_name})) ? 1 : 0;

  #
  # Should we skip recursively descending into subnodes 
  # (e.g. if we already have what we needed?)
  #
  my $skip_descent = 0;
  my $skip_message = 0;
  my $always_skip_message = 0;
  my $line = 0;
  my $column = 0;

  my $message = '';

  $next_decl_label //= '';
  my $export_label = ($next_decl_label eq 'export') ? 1 : 0;
  my $noexport_label = ($next_decl_label eq 'noexport') ? 1 : 0;
  my $export_optional_label = ($next_decl_label eq 'export_optional') ? 1 : 0;
  my $preserve_exports_label = ($next_decl_label eq 'preserve') ? 1 : 0;
  my $export_tag_label = undef;
  if ($next_decl_label =~ /^export_tag_(\w+)$/oax) { $export_tag_label = $1; }

  my $export_requested = $export_by_default ? (!$noexport_label) : 
    ($export_label || $export_optional_label || defined($export_tag_label));

  my $export_status_override = ($export_requested != $export_by_default);

  my $autoimport_label = ($next_decl_label eq 'autoimport') ? 1 : 0;

  my $optional_or_tagged_desc = ($export_tag_label || $export_optional_label) ?
    ($M.' ('.$U.(defined($export_tagged_label) ? 'tag '.$G.$export_tagged_label : 'optional').$M.$UX.')'.$X) : '';

  $next_decl_label = undef;
  
  my $is_import = ($nodetype eq 'PPI::Statement::Include');
  my $is_const_decl = ($is_import && ($node->type eq 'use') && ($node->module eq 'constant'));
  my $is_symbol = ($nodetype eq 'PPI::Token::Symbol');
  my $is_generic_word = ($nodetype eq 'PPI::Token::Word');
  my $is_keyword = ($is_generic_word && (exists $perl_keywords_and_built_in_functions{$node->content // ''}));
  my $is_word = ($is_generic_word && (!$is_keyword));

  if ($is_keyword) { $nodetype = 'PPI::Token::Keyword'; }
  elsif ($is_const_decl) { $nodetype = 'PPI::Statement::Constant'; }

  my $type_icon = '   ';

  if ($nodetype eq 'PPI::Statement::Package') {
    #-------------------------------------------------------------------------
    # Package declaration:
    #   package My::Package::Name;
    #
    # (sets $m->{module_name})
    #
    $skip_descent = 1;
    $m->{module_name} = $node->namespace;
    if ($raw_deps_mode) { 
      $message .= $C.$U.'PACKAGE'.$UX.' '.'mod  '.$Y.format_perl_package_name($m->{module_name}, $Y); 
      $type_icon = PACKAGE_ICON;
    }
  } elsif ($is_const_decl) {
    #-------------------------------------------------------------------------
    # Constant declaration:
    #   use constant { A => 123, B => 456, ... };
    #   ...or...
    #   use constant A => 123;
    #
    # (both may optionally be preceeded by "noexport: use constant ...")
    #

    $skip_descent = 1;
    my @constants = extract_constants($node);

    my $exported = ($is_module && $export_requested);
    my $color = ($exported ? $M : $export_status_override ? $R : $K);

    if ($raw_deps_mode) {
      $message .= $color.($exported ? ($U.'EXPORT'.$UX.' ') : 'NOxport').
        ' '.$M.'cst'.'  ';
      $type_icon = ($exported) ? EXPORTED_ICON : LOCAL_ICON;
      $skip_message |= (!$exported);
    }

    foreach $name (@constants) {
      if ($raw_deps_mode) 
        { $message .= $color.$name.$B.' '.dashed_vert_bar_3_dashes.' '.$K; }
      if ($exported) { 
        check_for_same_export_name_in_other_modules_and_add
          ($m, '='.$name, $export_optional_label, $export_tag_label, $node); 
      }
      $m->{known_local_symbol_names}->{$name} = 1;
    }

    if ($raw_deps_mode) { $message .= $optional_or_tagged_desc; }
  } elsif ($is_import) {
    #-------------------------------------------------------------------------
    # Package import:
    #   use My::Package::Name;                (explicitly imported)
    #   ...or...
    #   autoimport: use My::Package::Name;    (marker added if auto-imported)
    #
    if (($node->type eq 'use') && (!$node->pragma)) {
      $skip_descent = 1;
      $max_module_name_length = max($max_module_name_length, length($node->module));
      if ($autoimport_label) {
        # Just ignore this imported package, since we'll find it automatically
        if ($raw_deps_mode) { $message .= $R.'import  '.'auto '.$R.$node->module; }
      } else {
        $m->{explicitly_imported_modules}->{$node->module} = 1;
        if ($raw_deps_mode) { $message .= $M.'import  '.'expl '.$M.format_perl_package_name($node->module, $M); }
      }
    } else {
      if ($DEBUG) {
        $message .= $R.'import  '.$M.padstring($node->type, 4).' '.
          format_perl_package_name($node->module, $M);
      } else {
        $skip_message = 1;
      }
    }
    $type_icon = IMPORTED_PACKAGE_ICON;
  } elsif ($nodetype eq 'PPI::Statement::Variable') {
    #-------------------------------------------------------------------------
    # Variable declaration:
    #   [our|my|local|state] [$|@|%]varname ... ;
    #   ...or...
    #   [our|my|local|state] ([$|@|%]var1, [$|@|%]var2, ...)
    #
    # (either form may optionally be preceeded by "noexport: our ..."
    #

    #
    # Note that we skip descending into PPI::Statement::Variable nodes, so we'll
    # never directly encounter their PPI::Token::Symbol declarations. Therefore,
    # if we do see a PPI::Token::Symbol node here, it genuinely uses the variable:
    #

    my $scope = $node->type;
    my @symbol_def_list = $node->symbols;

    my $exported = ($is_module && ($scope eq 'our') && $export_requested);
    my $color = ($exported ? $G : $export_status_override ? $R : $K);

    if ($raw_deps_mode) {
      $message .= $color.($exported ? ($U.'EXPORT'.$UX.'  ') :
                  ($export_status_override ? ('NOxport ') : ('declare '))).
                  sprintf('%-3s', substr($scope, 0, 3)).'  ';
      $skip_message |= (!$exported);
      $type_icon = ($exported) ? EXPORTED_ICON : LOCAL_ICON;
    }

    foreach my $name (@symbol_def_list) {
      my $is_export_clause = (($name eq '@EXPORT') || ($name eq '@EXPORT_OK'));
      my $existing = (exists $m->{known_local_symbol_names}->{$name}) ? 1 : 0;

      if ($raw_deps_mode) {
        $message .= $color.$name.$K.($existing ? ' (redeclared)' : '').
          $B.' '.dashed_vert_bar_3_dashes.' '; 
      }

      if ($exported && (!$is_export_clause)) {
        check_for_same_export_name_in_other_modules_and_add
          ($m, $name, $export_optional_label, $export_tag_label, $node); 
      }

      $m->{known_local_symbol_names}->{$name} = 1;
    }

    if ($raw_deps_mode) { $message .= $optional_or_tagged_desc; }
  } elsif ($nodetype eq 'PPI::Statement::Sub') {
    #-------------------------------------------------------------------------
    # Subroutine declaration:
    #   sub mysub { ... }
    #   ...or...
    #   sub mysub($%@+prototype) { ... }
    #   ...or...
    #   sub mysub(...) ;        # (forward declaration)
    #
    # Any of these forms may optionally be preceeded by "noexport: sub ..."
    #
    my $name = $node->name;

    my $exported = ($is_module && $export_requested);
    $skip_message |= (!$exported);

    if ($raw_deps_mode) {
      my $color = ($exported ? $C : $export_status_override ? $R : $K);
      my $prototype = $node->prototype;
      $message .= $color.($exported ? ($U.'EXPORT'.$UX.'  ') : 
                   ($export_status_override ? ('NOxport ') : ('declare '))).
                   'sub'.'  '.$name.($prototype ? ' '.$B.$prototype : '').
                   $optional_or_tagged_desc;
      $type_icon = ($exported) ? EXPORTED_ICON : LOCAL_ICON;
    }
    
    if ($exported) {
      check_for_same_export_name_in_other_modules_and_add
        ($m, $name, $export_optional_label, $export_tag_label, $node); 
    }

    $m->{known_local_symbol_names}->{$name} = 1;
  } elsif ($is_symbol || $is_word) {
    #-------------------------------------------------------------------------
    # Use of variable, subroutine call or constant:
    #   [$|@|%]varname
    #   ...or...
    #   mysub(...)
    #   ...or...
    #   possibly_mysub_or_const
    #
    # Note that it is inherently ambiguous whether or not the given word
    # really refers to a symbol exported by another module - we'll only 
    # know for sure once we work backwards from the export lists.
    #

    my $name = ($is_symbol) ? $node->symbol : $node->content;
    my $sigil = ($is_symbol) ? $node->symbol_type : '';
    my $known_local = (exists $m->{known_local_symbol_names}->{$name});
    my $existing_import = (exists $m->{imported_symbols}->{$name});

    if ($known_local) {
      if ($raw_deps_mode) { 
        $message .= $K.'use-loc '.($is_word ? 'sub' : 'var').'  '.$name;
        $type_icon = LOCAL_ICON;
        $skip_message = 1;
      }
    } else {
      if ($raw_deps_mode) { 
        $message .= $Y.$U.'IMPORT'.$UX.'  '.($is_word ? $C.'sub' : $Y.'var').'  '.
          $name.$K.($existing_import ? ' (reused)' : '');
        $skip_message |= $existing_import;
      }
      
      $type_icon = IMPORTED_ICON;
      if ($existing_import) {
        $m->{imported_symbols}->{$name}++;
      } else { # ! $existing-import
        $m->{imported_symbols}->{$name} = 1;
        my $deplist = $symbol_to_list_of_dependent_modules{$name};
        if (!defined $deplist) {
          $deplist = [ $m ];
          $symbol_to_list_of_dependent_modules{$name} = $deplist;
        } else {
          if ($DEBUG) {
            $message .= $K.'; '.$B.'add to dep list'. #.$deplist.
                  ' (#'.(scalar(@$deplist)+1).')'; 
          }
          push @$deplist, $m;
        }
      }
    }
  } elsif ($is_keyword) {
    #-------------------------------------------------------------------------
    # Keywords (ignored as a no-op)
    #
    if ($DEBUG) {
      $message .= $R.'keyword '.$R.'   '.'  '.$M.$node->content;
    }
    $always_skip_message = 1;
    $skip_descent = 1; # no-op
  } elsif ($nodetype eq 'PPI::Token::Label') {
    #-------------------------------------------------------------------------
    # Labels controlling perl-mod-deps (see documentation for details):
    #
    $skip_descent = 1;
    my $label = ($node->content =~ s/:$//roamsx);

    $next_decl_label =
      ((exists $special_label_names{$label}) || 
         ($label =~ /^ (?: export_tag_ | bundle _?) \w++ $/oax)) ? $label : undef;

    if (is_there($next_decl_label)) {
      if (($next_decl_label eq 'preserve') || ($next_decl_label eq 'nobundle')) {
        $m->{$next_decl_label} = 1;
      } elsif ($next_decl_label =~ /(no)?export_by_default/oax) {
        $export_by_default = ($1 ne 'no'); 
      } elsif ($next_decl_label =~ /^bundle(?: _ (\w*+))?/oax) {
        add_module_to_bundle($m, $1 // $default_bundle_name);
      }
    }

    if ($raw_deps_mode) {
      $message .= $B.$U.'LABEL'.$UX.'   '.'     '.
        $Y.$label.(is_there($next_decl_label) ? $G.' (handled by perl-mod-deps)' : '').$X;
    }
  } else {
    #-------------------------------------------------------------------------
    # Other PPI tokens, statements and structures we don't need to handle:
    #
    if ($DEBUG) {
      $message .= $R.'UNKNOWN '.$R.'   '.'  '.$C.
        ref($node).$K.' = '.$Y.format_chunk($node->content, 120);
    }
    $always_skip_message = 1;
  }

  if ($raw_deps_mode) { 
    $message = line_and_column_header($line, $column, $lineout % 2).$G.' '.
      $type_icon.'  '.$X.
      #($exprtype_to_icon{$nodetype} // checkmark).
      ' '.$X.$message.$X.NL;
  }

  if ($DEBUG) { $skip_message = 0; }
  $skip_message |= $always_skip_message;
  if ($raw_deps_mode && (!$skip_message)) { printfd(STDERR, $message); $lineout++; }

  if (!$skip_descent) {
    foreach $subnode (@$subnodes) {
      my $subtype = ref($subnode);
      next if ($subtype eq 'PPI::Token::Whitespace' || 
               $subtype eq 'PPI::Token::Comment');
      analyze_ppi_subtree($subnode, $node, $m, $level+1);
    }
  }

  return $m;
}

#------------------------------------------------------------------------------
# parse_module($module)
#------------------------------------------------------------------------------
sub parse_module(+) {
  my ($m) = @_;

  my $tree = PPI::Document->new($m->{filename}, readonly => 1, tab_width => 2);
  die if (!defined $tree);

  $m->{tree} = $tree;

  $lineout = 0;
  $next_decl_label = undef;
  $export_by_default = 1;

  analyze_ppi_subtree($tree, undef, $m, 0);

  my $filename = $m->{filename};
  my $module_name = $m->{module_name};
  my $is_module = (defined $module_name) ? 1 : 0;
  my $module_or_file_name = $module_name // $filename;
  my $code = \($m->{code});

  $max_module_name_length = max($max_module_name_length, length($module_or_file_name));

  if ($DEBUG) {
    my $message = $K.($is_module ? 'module ' : 'program ').$Y.$U.
      ($module_or_file_name).$X.NL;

    printfd(STDERR, text_in_a_box($message, 0, $Y, 'double'));
  }

  if ($is_module) {
    my $expected_filename_of_module_name = ($module_name =~ s{::}{/}roamsxg).'.pm';
    my $n = length($expected_filename_of_module_name);
    my $actual_filename_stem = substr($filename, length($filename)-$n, $n);
    
    if ($actual_filename_stem ne $expected_filename_of_module_name) {
      warning('Module source file '.$Y.$filename.$R.' specifies inconsistent package name '.$C.$module_name.$R) unless $no_warnings;
    }
  }

  #
  # Remove any automatic imports so we can update them
  #
  #$m->{code} =~ s/($use_auto_import_module_names_re)//oamsxg;

  return $m;
}
