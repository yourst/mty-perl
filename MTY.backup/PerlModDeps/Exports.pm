# -*- cperl -*-
#
# MTY::PerlModDeps::Exports
#
# Copyright 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::PerlModDeps::Exports;

use integer; use warnings; use Exporter qw(import);

use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Common::Strings;
use MTY::Filesystem::Files;
use MTY::Display::Colorize;
use MTY::Display::ColorizeErrorsAndWarnings;
use MTY::Display::PrintableSymbols;
use MTY::Display::PrintableSymbolTools;
use MTY::Display::Tree;
use MTY::Display::TextInABox;
use MTY::RegExp::Define;
use MTY::RegExp::Tools;
use MTY::RegExp::PerlRegExpParser;
use MTY::RegExp::PerlSyntax;
use MTY::Common::PerlSourceTools;
use MTY::RegExp::Blocks;
use MTY::RegExp::Strings;
use MTY::RegExp::Numeric;
use MTY::System::POSIX;

use MTY::PerlModDeps::Common;
use MTY::PerlModDeps::Module;
#pragma end_of_includes

nobundle:; our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($perl_exports_exports_ok_export_tags_clauses_after_re
     $perl_exports_exports_ok_export_tags_clauses_before_re
     $perl_exports_exports_ok_export_tags_clauses_re generate_exports_decl);

#------------------------------------------------------------------------------
# generate_exports_decl($module)
#------------------------------------------------------------------------------

#
# It's quicker and easier to update the @EXPORT clause using a regexp 
# substitution rather than using PPI to do this, since we can replace
# several elements all at once while precisely specifying the syntax
# of the output code.
#
our $perl_exports_exports_ok_export_tags_clauses_before_re =
  qr{^ \s*+ (?> (?! our) \w+ : ;? \s*+)*+ our \s*}oamsx;

our $perl_exports_exports_ok_export_tags_clauses_after_re =
  qr{\s*+ = \s*+ (?> \# \N++ \n)? 
     \s*+ (?> qw)? \s*+ $parens_re \s*+ \;}oamsx;

our $perl_exports_exports_ok_export_tags_clauses_re =
  qr{(?: 
       $perl_exports_exports_ok_export_tags_clauses_before_re
       @ EXPORT
       $perl_exports_exports_ok_export_tags_clauses_after_re
     )
     (?: 
       \s*+
       $perl_exports_exports_ok_export_tags_clauses_before_re
       @ EXPORT_OK
       $perl_exports_exports_ok_export_tags_clauses_after_re
     )?
     (?: 
       \s*+
       $perl_exports_exports_ok_export_tags_clauses_before_re
       % EXPORT_TAGS
       $perl_exports_exports_ok_export_tags_clauses_after_re
     )?
    }oamsx;
  
sub generate_exports_decl($;$) {
  my ($m, $do_not_update_placeholder) = @_;
  $do_not_update_placeholder //= 0;

  my $result = undef;

  my $filename = $m->{filename};
  my $module_name = $m->{module_name};
  my $is_module = (defined $module_name) ? 1 : 0;
  my $module_or_file_name = $module_name // $filename;

  if (!$m->{module_name}) {
    $m->{code} = $m->{origcode};
    printfd(STDERR, '  '.$K.padstring($filename, $max_module_name_length).
            $Y.'  '.arrow_head.'     '.$Y.'program'.$K.' had no exports, '.
            'but still processed imports'.$X.NL);
    return (wantarray ? (GEN_EXPORTS_DECL_NOT_MODULE, undef) : GEN_EXPORTS_DECL_NOT_MODULE);
  }
    
  my $exported_sub_count = 0;
  my $exported_scalar_count = 0;
  my $exported_array_count = 0;
  my $exported_hash_count = 0;
  my $exported_const_count = 0;

  my @exports = ( );

  my $optional_or_tagged_exports = $m->{optional_or_tagged_exports};
  my $optional_export_count = 0;
  my $tagged_export_count = 0;
  my @optional_exports = ( );
  my %tag_to_sym_list = ( );

  foreach my $name (keys %{$optional_or_tagged_exports}) {
    my $tag = $optional_or_tagged_exports->{$name};
    $tagged_export_count += (defined($tag)) ? 1 : 0;
    $optional_export_count += (!defined($tag)) ? 1 : 0;

    if (defined $tag) { 
      my $taglist = $tag_to_sym_list{$tag};
      if (defined $taglist) {
        push @{$taglist},$name;
      } else {
        $taglist = [ $name ];
        $tag_to_sym_list{$tag} = $taglist;
      }

      $tagged_export_count++;
    }

    # Names in EXPORT_TAGS must also appear in @EXPORT or @EXPORT_OK:
    push @optional_exports,($name =~ s/^\=//roax);
    $optional_export_count++;
  }

  foreach $name (keys %{$m->{exports}}) {
    next if ($name =~ /^\@(EXPORT|ISA|ALL)/oax);
    my $origname = $name;
    my ($symbol, $type, $basename) = ($name =~ /$perl_identifier_sigil_and_symbol_re/oax);

    my $is_const = ($type eq '=') ? 1 : 0;

    $exported_scalar_count += ($type eq '$') ? 1 : 0;
    $exported_array_count +=  ($type eq '@') ? 1 : 0;
    $exported_hash_count +=   ($type eq '%') ? 1 : 0;
    $exported_sub_count +=    ($type eq '') ? 1 : 0;
    $exported_const_count +=  ($is_const)   ? 1 : 0;

    #
    # We only use the '=' sigil to differentiate between subs and consts for
    # counting purposes, but perl doesn't recognize this, so remove it here:
    #
    if ($is_const) { $name = $basename; $type = ''; }

    if (!(exists $optional_or_tagged_exports->{$origname})) { push @exports,$name; }
  }

  @exports = sort_by_ascending_length_then_alphabetical @exports;
  @optional_exports = sort_by_ascending_length_then_alphabetical @optional_exports;

  # Create an :ALL tag for convenience:
  if (($optional_export_count > 0) || ($tagged_export_count > 0)) 
    { $tag_to_sym_list{'ALL'} = [ @exports, @optional_exports ]; }

  my $outsep = $X.$B.' '.dashed_vert_bar_3_dashes.' '.$X;
  my $export_list_summary =
    $C.padstring($exported_sub_count,    -3).'  &subs'.$outsep.
    $G.padstring($exported_scalar_count, -3).'  $scalars'.$outsep.
    $Y.padstring($exported_array_count,  -3).'  @arrays'.$outsep.
    $M.padstring($exported_hash_count,   -3).'  %hashes'.$outsep.
    $B.padstring($exported_const_count,  -3).'  =consts'.$outsep.
    (($optional_export_count > 0) ?
       $R.padstring($optional_export_count, -3).'  optional'.$outsep : '').
    (($tagged_export_count > 0) ?
       $R.padstring($tagged_export_count, -3).'  tagged'.$outsep : '');

  $m->{code} = $m->{origcode};

  my $new_export_clauses = NL;
  if ($m->{nobundle}) { $new_export_clauses .= 'nobundle:; '; }

  my @member_of_bundles = (exists $m->{bundle_name}) ? (sort keys %{$m->{bundle_name}}) : ( );
  
  foreach my $b (@member_of_bundles) 
    { $new_export_clauses .= 'bundle_'.$b.':; '; }

  if ($m->{preserve}) { $new_export_clauses .= 'preserve:; '; }

  $new_export_clauses .= 'our @EXPORT = # (auto-generated by perl-mod-deps)'.NL.
    '  qw('.wrap_long_lines(@exports, 78, ' ', '', '     ', '', '  qw(').');';

  if ($optional_export_count > 0) {
    $new_export_clauses .= NL.NL.'our @EXPORT_OK = '.NL.
    '  qw('.wrap_long_lines(@optional_exports, 78, ' ', '', '     ', '', '  qw(').');';
  }

  if ($tagged_export_count > 0) {
    $new_export_clauses .= NL.'our %EXPORT_TAGS = (';
    foreach $tag (sort keys %tag_to_sym_list) {
      my $taglist = $tag_to_sym_list{$tag};
      my $prefix = NL.'  '.$tag.' => [qw(';
      my $clause = wrap_long_lines(@{$taglist}, 78, ' ', '',
        (' ' x length($prefix)), '', $prefix);
      $new_export_clauses .= NL.$prefix.$clause.')], ';
    }
    $new_export_clauses .= NL.');';
  }

  my $found_export_array = undef;

  if ((defined $m->{code}) && (!$do_not_update_placeholder)) {
    if (!$m->{preserve}) {
      $found_export_array = ($m->{code} =~ 
        s{$perl_exports_exports_ok_export_tags_clauses_re}
         {$new_export_clauses}oamsxg);
    }
  } else {
    #
    # If code is undefined, this means the caller just wants the generated
    # exports array returned as a string of code, rather than replacing the
    # old export declaration in the original source file. (This is used by
    # the module bundle generator and various other uses).
    #
    $found_export_array = 1;
  }

  my $changed_anything = (!defined $m->{origcode}) || ($m->{code} ne $m->{origcode});
  my $mod_name_color = (defined $found_export_array) ? $G : ($m->{preserve}) ? $K : $R;
  my $msg = $mod_name_color.padstring(format_perl_package_name($module_name, $mod_name_color), $max_module_name_length);

  my $do_not_print_message = 0;

  if (defined $found_export_array) {
    if ($do_not_update_placeholder) {
      $result = GEN_EXPORTS_DECL_ONLY_GENERATE_NO_UPDATE;
      $msg = $msg.$G.'  '.checkmark.'  '.$export_list_summary.$X.NL; 
    } elsif ($changed_anything) {
      $result = GEN_EXPORTS_DECL_UPDATED;
      $msg = $msg.$G.'  '.checkmark.'  '.$export_list_summary.$X.NL; 
    } else {
      $result = GEN_EXPORTS_DECL_UNCHANGED;
      if ($show_unmodified_modules) {
        $msg = $msg.$B.'  '.checkmark_in_box.'  '.$B.'(no changes required)'.$X.NL;
      } else {
        $do_not_print_message = 1; 
      }
    }
  } elsif ($m->{preserve}) {
    $msg = $msg.$Y.'  '.asterisk.'     '.$Y.$U.'skipped'.$X.$R.
      ' because preserve label was applied to @EXPORT list'.$X.NL;
    $result = GEN_EXPORTS_DECL_PRESERVE;
  } else { # ! $found_export_array
    $msg = $msg.$R.'  '.x_symbol.'     '.$Y.$U.'skipped'.$X.$R.
      ' because it\'s missing an applicable placeholder @EXPORT list'.$X.NL;
    $result = GEN_EXPORTS_DECL_MISSING_PLACEHOLDER;
  }

  if (!$do_not_print_message) {
    if ($DEBUG) {
      printfd(STDERR, text_in_a_box($msg, -1, $G));
    } else {
      printfd(STDERR, '  '.$msg);
    }
  }    

  return (wantarray ? ($result, $new_export_clauses) : $result);
}
