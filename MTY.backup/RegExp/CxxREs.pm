#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::RegExp::CxxREs
#
# C++ Parser grammar regexps for relevant portions of the C++ language
# (i.e. class/struct/union definitions, templates, typedefs, operators, etc.)
#
# Copyright 2008-2015 Matt T. Yourst <yourst@yourst.com>. All rights reserved.
#

package MTY::RegExp::CxxREs;

use integer; use warnings; use Exporter qw(import);

nobundle:; our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($c_comment_re $c_cxx_comment_re $c_cxx_include_guard_or_pragma_once_re
     $c_cxx_included_deps_re
     $c_cxx_included_filename_with_angle_bracket_or_quote_re
     $class_struct_union_re $cxx_assignment_operators_except_simple_equals_re
     $cxx_assignment_operators_re $cxx_balanced_structural_chars_re
     $cxx_binary_arith_logic_compare_operators_re $cxx_comment_re
     $cxx_double_quoted_string_re
     $cxx_extended_assignment_operators_except_simple_equals_re
     $cxx_extended_assignment_operators_re $cxx_extended_operators_re
     $cxx_identifier_re $cxx_keywords_re $cxx_only_keywords_re
     $cxx_operators_re $cxx_opt_space_re
     $cxx_preprocessor_define_directive_arguments_re
     $cxx_preprocessor_directive_names_re $cxx_preprocessor_directive_re
     $cxx_preprocessor_include_directive_arguments_re
     $cxx_preprocessor_include_directive_re $cxx_quoted_literal_nocap_re
     $cxx_quoted_re $cxx_quoted_string_re $cxx_raw_delimited_string_re
     $cxx_single_quoted_character_re $cxx_single_quoted_string_re
     $cxx_space_re $cxx_token_re $cxx_unary_postfix_operators_re
     $cxx_unary_prefix_operators_re $declaration_or_block_re $enum_def_re
     $field_decl_re $function_decl_argument_list_item_re
     $function_type_name_args_body_re $identifier_chars $if_or_ifdef_endif_re
     $inside_if_or_ifdef_optional_else_endif_re $looks_like_cxx_re
     $non_identifier_syms $preprocessor_define_re $preprocessor_line_info_re
     $preprocessor_re $ptr_or_ref_re $rvalue_expression_re
     $standalone_type_spec_nocap_re $strip_non_functional_cxx_syntax_re
     $template_spec_re $template_type_list_re $type_spec_re $typedef_decl_re
     %cxx_assignment_operator_to_name %cxx_keywords %cxx_operator_to_name
     @all_capture_group_names @cxx_keyword_list CXX_TOKEN_COMMENT
     CXX_TOKEN_IDENTIFIER CXX_TOKEN_NUMERIC CXX_TOKEN_OPERATOR
     CXX_TOKEN_PREPROCESSOR CXX_TOKEN_QUOTED CXX_TOKEN_STRUCTURAL
     CXX_TOKEN_WHITESPACE);

use MTY::Common::Common;
use MTY::Common::Strings;
use MTY::Common::Hashes;
use MTY::RegExp::Define;
use MTY::RegExp::Blocks;
use MTY::RegExp::Strings;
use MTY::RegExp::Numeric;
#pragma end_of_includes

#
# ONLY use these if input has been preprocessed to remove redundant whitespace:
#
our $cxx_space_re = '\s';
our $cxx_opt_space_re = '\s?'; # optional whitespace

our $identifier_chars = 'A-Za-z0-9_\$';
# Remember that '$' is a valid identifier character in C/C++ (and of course in perl :-)
our $non_identifier_syms = '\:\;\,\.\=\+\-\*\/\%\&\|\^\~\!\?\@\#\(\)\{\}\[\]\<\>\'\`\"';

our $cxx_identifier_re = compile_regexp(
  qr{[A-Za-z_\$] [A-Za-z0-9_\$]*+ \b}oamsx, 'cxx_identifier',
  'C++ identifier (starts with a letter, _, or $, optionally followed by '.
  'any number of letters, numbers, _, or $ symbols');

our @cxx_keyword_list =
  ('alignas', 'alignof', 'and', 'and_eq', 'asm', 'auto', 'bitand', 'bitor', 
   'bool', 'break', 'case', 'catch', 'char', 'char16_t', 'char32_t', 'class',
   'compl', 'const', 'const_cast', 'constexpr', 'continue', 'decltype', 
   'default', 'delete', 'do', 'double', 'dynamic_cast', 'else', 'enum', 
   'explicit', 'export', 'extern', 'false', 'final', 'float', 'for', 'friend', 
   'goto', 'if', 'inline', 'int', 'long', 'mutable', 'namespace', 'new', 
   'noexcept', 'not', 'not_eq', 'nullptr', 'operator', 'or', 'or_eq', 
   'override', 'private', 'protected', 'public', 'register', 'reinterpret_cast', 
   'return', 'short', 'signed', 'sizeof', 'static', 'static_assert', 
   'static_cast', 'struct', 'switch', 'template', 'this', 'thread_local', 
   'throw', 'true', 'try', 'typedef', 'typeid', 'typename', 'union', 'unsigned', 
   'using', 'virtual', 'void', 'volatile', 'wchar_t', 'while', 'xor', 'xor_eq');

our %cxx_keywords = array_to_hash_keys(@cxx_keyword_list);

our $cxx_keywords_re = compile_regexp(qr{
  \b (?>
  a(?>lign(?>as|of) | nd(?>_eq)? | sm | uto) |
  b(?>it(?>and|or) | ool | reak) | 
  c(?>ase | atch | har(?>16_t|32_t)? | lass | ompl | onst(?>_cast|expr)? | ontinue) |
  de(?>cltype | fault | lete) | d(?>o(?>uble)?) | dynamic_cast | 
  e(?>lse | num | (?>xp(?>licit|ort)) | xtern) |
  f(?>alse | inal | loat | or | riend) | 
  (?>goto) | i(?>f | n(?>line|t)) | (?> long) | 
  (?>mutable) | n(?>amespace | ew | oexcept | ot(?>_eq)? | ullptr) |
  o(?>perator | r(?>_eq)? | verride) | 
  p(?>rivate | rotected | ublic) | 
  re(?>gister | interpret_cast | turn) | 
  s(?>hort | igned | izeof | tatic(?>_assert|_cast)? | truct | witch) | 
  t(?>emplate | h(?>is | read_local | row) | r(?>ue|y) | ype(?>def|id|name)) |
  un(?>ion|signed) | using | 
  v(?>irtual | oid | olatile) | 
  w(?>char_t | hile) | xor(?>_eq)?) \b}oamsx,
  'cxx_keywords',
  'C and C++ keywords, in a regexp highly optimized for fast matching');

# (less optimized alternative): our $cxx_keywords_re = compile_regexp_list_of_alternatives(@cxx_keywords, 'cxx_keywords');

our $cxx_only_keywords_re = compile_regexp(qr{
  \b (?>
  bool | c (?>lass | onst (?> _cast | expr) | atch) |
  de(?>cltype | lete) | dynamic_cast | 
  ex (?>plicit | tern) |
  f(?>inal | riend) | (?>mutable) | n(?>amespace | ew | oexcept) |
  o(?>perator | r(?>_eq)? | verride) | 
  p(?>rivate | rotected | ublic) | 
  reinterpret_cast | 
  static_(?>assert|cast) | 
  t(?>emplate | h(?>is | read_local | row) | r(?>ue|y) | ype(?>id|name)) |
  using | virtual) \b}oamsx,
  'cxx_only_keywords',
  'C++ keywords only found in C++ but not in C, '.
  'in a regexp highly optimized for fast matching');

our $looks_like_cxx_re = compile_regexp(
  qr{$cxx_only_keywords_re |
     # C++ references, only found in C++ with syntax "Identifier& refvar"
     (?> (?<= ;) \s*+ \w++ \s*+ (?> const \s*+)? \& \&? \s*+ \w++)}oamsx,
  'looks_like_cxx_re');


#our $rvalue_expression_re = compile_regexp(
#  \qr/(?> [^\(\)\,\;\"\']++ | $parens_re | $cxx_quoted_re )+/oamsx,
#  'rvalue_expression', '');

our $cxx_double_quoted_string_re = compile_regexp(
  qr{(?'char_encoding' L | u8 | u | U)? 
     (?'quote_type' \") 
     (?'string' (?> [^\"\\]++ | \\ .)*+) \"
  }oamsx, 'cxx_double_quoted_string',
  'Match double quote delimited string ("...") with optional '.
  'embedded escaped double quote characters or literal single quotes',
  \('string' => 'text between quotes',
    'quote_type' => 'type of quotation marks: single (\') or double (")',
    'char_encoding' => '(optional) character encoding: '.
                       'L = 16 bit (wchar_t), u8 = UTF-8, u = UTF-16, '.
                       'U = UTF-32'));

#
# C++11 has *finally* added Perl-style string literals
# where you can choose your own starting and ending
# delimiters that don't conflict with any characters in
# the string, thus making escaped characters unnecessary:
#
# (optional L|u8|u|U prefix) R "delimiter( raw_characters )delimiter"
#                              ^^^^^^^^^^^                ^^^^^^^^^^^
#
our $cxx_raw_delimited_string_re = compile_regexp(
  qr{(?'char_encoding' L | u8 | u | U)? 
     R \" 
     (?'quote_type' [^\s\(\)\\]*+) \(
     (?'string' .*?)
     \) \g{-2} \" 
  }oamsx, 'cxx_raw_delimited_string',
  'Match C++11 style raw string bounded by user specified delimiters '.
  'of the form:     R"(???      and closing with:       ???)',
  \('string' => 'text between quotes',
    'quote_type' => 'the user defined delimiter(s) between the R" and the (',
    'char_encoding' => '(optional) character encoding: '.
                       'L = 16-bit wchar_t, u8 = UTF-8, u = UTF-16, U = UTF-32'));

our $cxx_single_quoted_string_re = compile_regexp(
  qr{(?'char_encoding' L | u8 | u | U)? 
     (?'quote_type' \') 
     (?'string' (?> [^\'\\]++ | \\ .)*+) \'
  }oamsx,
  'cxx_single_quoted_string',
  'Match single quote delimited (\'...\') string with optional '.
  'embedded escaped single quote characters or literal double quotes',
  \('string' => 'text between quotes',
    'quotetype' => 'type of quotation marks: single (\') or double (")',
    'char_encoding' => '(optional) character encoding: '.
                       'L = 16 bit (wchar_t), u8 = UTF-8, u = UTF-16, '.
                       'U = UTF-32'));

our $cxx_single_quoted_character_re = compile_regexp(
  qr{' (?'char'
       \\ (?> 
         [\'\"\?\\0abfnrtv] |
         (?> [nxu] [0-9A-Fa-f]{2,4})
       )
       [^\'\\]) '
  }oamsx, 'cxx_single_quoted_character',
  'Match single quote delimited (\'...\') single character '.
  'or a backslash escaped character or an octal/hex/unicode '.
  'escaped character code',
  \('string' => 'text between quotes'));

our $cxx_quoted_re = compile_regexp(
  qr{(?> (?'string_with_quotes' $cxx_double_quoted_string_re | $cxx_single_quoted_string_re | $cxx_raw_delimited_string_re))}oamsx, 
  'cxx_quoted', 'Match either a double quoted string (as in double_quoted_string_re) '.
  'or a single quoted character (as in single_quoted_character_re)');

our $cxx_quoted_string_re = compile_regexp(
  qr{(?> ($cxx_double_quoted_string_re | $cxx_single_quoted_string_re | $cxx_raw_delimited_string_re))}oamsx, 
  'cxx_quoted_string', 'Match either a double quoted string (as in double_quoted_string_re) '.
  'or a single quoted character (as in single_quoted_character_re)');

our $cxx_quoted_literal_nocap_re = compile_regexp(
  qr{
  (?> [LUu]8?)?+
  (?>
    (?> \" (?> (?> [^\"\\]++ | \\ .)*+ \")) |
    (?> \' (?> (?> [^\'\\]++ | \\ .)*+ \')) |
    (?> R \" (?> 
      ([^\s\(\)\\]{0,256}+) \(
      (?> [^\)] | \) (?! \g{-1}))*+
      \) \g{-1} \"
    ))
  )}oamsx, 'quoted_literal_nocap');

our $rvalue_expression_re = compile_regexp(
 qr{(?> [^\(\)\,\;\"\'] | $parens_re | $cxx_quoted_re )++}oamsx,
  'rvalue_expression', '');

our $c_comment_re = compile_regexp(
  qr{
    \Q/*\E
    (?: [^\*] | \* (?! \/))*+
    \Q*/\E
  }oamsx, 
  'c_comment', 'C comment /* ... */');

our $cxx_comment_re = compile_regexp(qr{// \N*+ (?= \n)}oamsx, 
  'cxx_comment', 'C++ comment // ...');

our $c_cxx_comment_re = compile_regexp(qr{
  (?> / (?>
    (?>
      \* (?> [^\*] | \* (?! \/))*+ \* \/
    ) |
    (?> \/ \N*+ (?= \n)) 
  ) )
                                        }oamsx,
  'c_cxx_comment_re', 'C or C++ comments (// ... or /* ... */)');

our $preprocessor_re = compile_regexp
  (qr{^\# (?> (?> \\ \n) | \N)*+ (?= \n)}oamsx,
  'preprocessor', 'Preprocessor lines starting with "#"');

our $preprocessor_define_re = compile_regexp
  (qr{^\# \s*+ define [\ \t]++ 
       (\w++)
       (?> \( ([^\(\)]*+) \))? 
       [\ \t]*+ 
       ((?> (?> \\ \n) | \N)*+) \n}oamsx,
   'preprocessor', 
   'Preprocessor #define directive with symbol name, '.
   'optional argument list (arg1, arg2, ...) and optional '.
   'value to assign to that symbol (captured as $1, $2, $3, '.
   'respectively.');

our $preprocessor_line_info_re = compile_regexp(
  qr{^ \# (?: line)? \s*+
      (?'line' \d++) \s++
      \" (?'filename' [^\"]*+) \" \s*+
      (?'extra' \N*+)
      \n
  }oamsx, 'preprocessor_line_info', 
  'Preprocessor line info # 123 "filename" extra-numbers');

our $cxx_preprocessor_directive_names_re = compile_regexp(
  qr{(?>
        assert | define |
        e(?>l(?>if|se) | ndif | rror) |
        i(?>dent | f(?>def|ndef)? | mport |
        nclude (?> _next)?) | line | pragma | 
        sccs | un(?>assert|def) | warning)
      }oax, 'cxx_preprocessor_directive_names',
  'Names of all valid C/C++ standard preprocessor directives '.
  '(i.e. "#directivename ..."). Only for matching (no captures)');

our $cxx_preprocessor_directive_re = compile_regexp(
  qr{^\# [\ \t]*+ ($cxx_preprocessor_directive_names_re) [\ \t]++ 
      $line_with_optional_backslash_newlines_re}oamsx,
  'cxx_preprocessor_directive',
  'C/C++ preprocessor directive line (i.e. "#directive args..."), '.
  'which captures any valid standard directive names into $1 and '.
  'the remainder of the line (or lines, if "\" and newline was used).');

our $cxx_preprocessor_include_directive_arguments_re = compile_regexp(
  qr{([\<\"]?) ([^\>]++) [\>\"]?}oamsx,
  'cxx_preprocessor_include_directive_arguments',
  'Argument to #include directive, of the form "dir/included.h" or '.
  '<dir/included.h>');

our $cxx_preprocessor_include_directive_re = compile_regexp(
  qr{^\# [\ \t]*+ include [\ \t]++ ([\<\"]?) ([^\>]++) [\>\"]?}oamsx,
  'cxx_preprocessor_include_directive',
  'C/C++ preprocessor include directive line, provided as a faster '.
  'alternative to $cxx_preprocessor_directive_re for cases where only '.
  'the included header filenames are needed (but note that this may be '.
  'a superset of what the compiler would really include, since ifdefs '.
  'are not considered and thus cannot suppress some inclusions). Captures '.
  'the same fields as $cxx_preprocessor_include_directive_arguments_re.');

our $cxx_preprocessor_define_directive_arguments_re = compile_regexp(
  qr{^ ([\w\_\$]++) (?> \( ($inside_parens_re) \))? \s++ (.++) $}oamsx,
  'cxx_preprocessor_define_directive_arguments',
  'Arguments to #define directive, in the form "#define SYMBOL value" or '.
  '"MACRO(macro_arg1, ...) contents_to_expand"');

#$cxx_binary_arith_logical_operators_re = qr{(?:[\+\-\*\/\%\&\|\^]=?|\&\&|\|\||
#$cxx_arithmetic_logical_assignment_operators_re = qr}(?:(?:[\=\+\-\&\|\<\>]{1,2})|[\*\/\%\^])/oa;

#
# Operators defined by Standard C++ 11
#   == ++ --       && || << >> ::
#   =  +  -  *  /  &  |  <  >     !  ^  %  ~  ,  .
#   += -= *= /= %= &= |= ^= <= >= != 
#   -> ->* .* ?: () []
#   <<= >>= sizeof throw
#   new delete new[] delete[]
#
# (Note that this does't use \Q...\E literals as much as normally possible
# since this breaks emacs cperl highlighting and indenting, but fortunately
# it doesn't affect the performance of the compiled regexp).
# 
our $cxx_operators_re = compile_regexp(qr{
  (?>
    \<\<\= | \>\>\= | \.\.\. |
    \-\>\*? | \.\* | 
    [\=\+\-\*\/\%\&\|\^\<\>\!] \=? |
    (?: ([\+\-\&\|\<\>\:\.\#]) \g{-1}?) |
    [\~\,\?] | \(\) | \[\] |
    (?: \b (?> new|delete) \b (?> \s? \[\])?) |
    (?: \b (?> size|length|offset|align)of \b) | \b throw \b
  )}oamsx, 'cxx_operators', '');

our $cxx_extended_operators_re = compile_regexp(qr{
  (?>
    \<\<[\=\<] | \>\>[\=\>] | \.\.\. | \-\>\*? |
    \.\* | \=\> | 
    (?: (?<= operator \s) (?: \(\) | \[\])) |
    \[\[ | \]\] | [\(\[\]\)] |
    (?>
      ([\=\+\-\&\|\^\<\>\:\.\#\?\%\@\~])
      (?> = | \g{-1})?
    ) |
    (?> [\*\/\!] =?) | [\,\;] |
    (?> \b (?: new|delete) \b (?: \s? \[\])?) |
    (?> \b (?: size|length|offset|align)of \b) | \b throw \b
  )}oamsx, 'cxx_extended_operators', '');

#
# Overloadable C++ operators:
# Nearly the same as $cxx_operators_re, but excludes
# the following non-overloadable operators: . :: .* ?:
#

# ++ --
# +  -  !  ~  &  *  (where & and * are used on pointers)
our $cxx_unary_prefix_operators_re = compile_regexp(qr{
  \+\+ | \-\- | [\+\-\!\~\&\*]   
  }oamsx, 'cxx_unary_prefix_operators');

our $cxx_unary_postfix_operators_re = compile_regexp(qr{
  \+\+ | \-\-          # ++ --
  }oamsx, 'cxx_unary_postfix_operators');

#  <= >= ==
#  &  |  <  >  &&  ||  <<  >>
#  +  -  *  /  %   ^   ,   .  ?  :
our $cxx_binary_arith_logic_compare_operators_re = compile_regexp(qr{
  [\<\>\=]\= |             
  && | \|\| | << | >> | [\&\|\<\>] |
  [\+\-\*\\\/\%\^\,\.\:\?] | 
  \-\>\*?}oamsx, 'cxx_binary_arith_logic_compare_operators'); 

our $cxx_assignment_operators_re = compile_regexp(qr{
  (?>
    \<\<\= | \>\>\= | \+\+ | \-\- |
    (?> [\+\-\*\/\%\&\|\^]?+ \=)
  )}oamsx, 'cxx_assignment_operators', '');

our $cxx_assignment_operators_except_simple_equals_re = compile_regexp(qr{
  (?>
    \<\<\= | \>\>\= | \+\+ | \-\- |
    (?> [\+\-\*\/\%\&\|\^] \=)
  )}oamsx, 'cxx_assignment_operators_except_simple_equals', '');

our $cxx_extended_assignment_operators_re = compile_regexp(qr{
  (?>
    \<\<\= | \>\>\= | \+\+ | \-\- | \=\> |
    (?> [\+\-\*\/\%\&\|\^\:\.\?\@\~]?+ \=)
  )}oamsx, 'cxx_extended_assignment_operators', '');

our $cxx_extended_assignment_operators_except_simple_equals_re = compile_regexp(qr{
  (?:
    \<\<\= | \>\>\= | \+\+ | \-\- | \=\>
    (?> [\+\-\*\/\%\&\|\^\:\.\?\@\~] \=)
  )}oamsx, 'cxx_extended_assignment_operators_except_simple_equals', '');

our %cxx_operator_to_name = (
  '+' => 'add',
  '-' => 'sub',
  '*' => 'mul',
  '/' => 'div',
  '%' => 'mod',
  '&' => 'and',
  '|' => 'or',
  '^' => 'xor',
  '=' => 'assign',
  '==' => 'eq',
  '!=' => 'ne',
  '>' => 'gt',
  '<' => 'lt',
  '>=' => 'ge',
  '<=' => 'le',
  #...todo
  );

our %cxx_assignment_operator_to_name = (
  '=' => 'set',
  '+=' => 'add',
  '-=' => 'sub',
  '*=' => 'mul',
  '/=' => 'div',
  '%=' => 'mod',
  '&=' => 'and',
  '|=' => 'or',
  '^=' => 'xor',
  '<<=' => 'shl',
  '>>=' => 'shr',
  '++' => 'inc',
  '--' => 'dec'
  );

#
# Remove any whitespace which is unnecessary in syntactically correct C/C++ code.
# Specifically, whitespace will only be retained where it:
#
# - separated two word characters (i.e. \w+ $cxx_opt_space_re \w+)
# - separated two operators (e.g. to prevent 'x + +3 from becomming x++3)
# - appeared inside of a string literal ("... words with spaces ...")
#
# In all of these cases (except for string literals), multiple consecutive spaces
# will be condensed into a single space character. Note that this also removes
# intervening newlines, tabs and any and all other unnecessary whitespace.
#
# This dramatically simplifies and accelerates many of our regular expressions,
# which would otherwise have to include countless instances of '$cxx_opt_space' patterns
# to handle cases wher the original code had gratuitous spaces where they
# weren't really needed, i.e.:
#
#   original: void   myfunc ( int x , int y ) ;
#   becomes:  void myfunc(int x,int y);
#

our $ptr_or_ref_re = compile_regexp(
  qr{(?> \* \s){0,256} \&{0,2}+}oamsx, 'ptr_or_ref',
  'Pointer (*) and/or reference type extension, with arbitrary '.
  'indirection (*, **, ***, etc) followed by either lvalue '.
  'reference (&) or rvalue reference (&&)');

#our $template_type_list_item_re = compile_regexp(
#  \qr/\G (?'typename_or_class_or_type_or_template) ( (?: [^\<\>\,]+ | $angle_brackets_re)+ )
#    (?: , | \Z)
#  /oamsx,

our $template_type_list_re = compile_regexp(
  qr{(?> [^\<\>\(\)\;\{\}] | $angle_brackets_re | $parens_re){0,1024}+}oamsx,
  'template_type_list_re',
  'Template type specification list, excluding angle brackets');

our $template_spec_re = compile_regexp(qr{
  template \s \< (?> \s $template_type_list_re \s \>)
  }oamsx, 'template_spec_re');

our $type_spec_re = compile_regexp(
  qr{(?'type_attributes' 
        (?> \b (?> const(?>expr)? | volatile | mutable | static) \s)*+
      )
      (?'type_specifier'
        (?>
          \b (?'type_alias_operator' decltype | typeof) \s
          \( (?'expr_of_type' (?> $inside_parens_re)) \) \s
        ) |
        (?'fundamental_type_name' \b
          (?>
            (?> # note: this will match erroneous repeats or conflicts like 
              # 'int int', 'short long', 'unsigned signed long long long', etc.
              # but these will still be properly caught by the compiler itself.
              # Unfortunately C and C++ let these reserved words appear in any
              # order while still specifying a valid non-ambiguous type:
              unsigned|s(?>igned|hort)|double|float|bool|char|void|long|int 
            ) \s
          ){1,4}
        ) |
        (?>
          (?'type_name' $cxx_identifier_re \s)
          (?: < (?> 
            \s 
            (?'type_template_params' (?> $template_type_list_re)) 
            \s? > \s)
          )?+
        )
      )
      (?> (?'type_ptr_or_ref' (?> $ptr_or_ref_re)) \s)?+
     }oamsx, 'type_spec', 'C++ type specification, including attributes, type name '.
                          '(or decltype alias), optional template parameters, and '.
                          'pointer and/or reference specifiers');

our $standalone_type_spec_nocap_re = compile_regexp(
  qr{
      #
      # In C++, all declarations of any kind must follow either a preceeding 
      # semicolon (if after any kind of declaration or a statement), or a
      # right brace (if after any kind of function or block definition).
      #
      # The inclusion of this constraint *dramatically* speeds up this regexp:
      #
      (?> (?<= [\;\}] \s) | \A)
      (?> \b (?> const(?:expr)? | volatile | mutable | static) \s){0,5}
      (?:
        (?>
          \b (?> decltype | typeof) \s
          $parens_re \s
        ) |
        (?>
          (?>
            (?> (?:un)?signed | double | short | float | bool | char | void | long | int) \s
          )++
        ) |
        (?> 
          (?> $cxx_identifier_re) \s
          (?> \< \s (?> $template_type_list_re) \s?+ \> \s)?+
        )
      )
      (?> $ptr_or_ref_re \s)?+
     }oamsx, 'type_spec_nocap', 'C++ type specification, including attributes, type name '.
                                         '(or decltype alias), optional template parameters, and '.
                                         'pointer and/or reference specifiers');

our $field_decl_re = compile_regexp(
  qr{\G 
     (?'field_name'
       (?> $cxx_identifier_re) |    # simple identifier for field name
       (?= \s? \: \s \d+)      # ...or nameless padding field but (lookahead) followed by :123 field width
     ) \s?
     (?:
       (?:
         \: \s (?'bitwidth' \d++) |                 # name:123, (bitfield)
         (?: \[ (?'array_size' $inside_square_brackets_re) \])      # name[123],  (array)
       )
       \s
     )?
     (?: \= \s
       (?'init_value'
         $braces_re |                 # = {1, 2, 3, ...}
         $rvalue_expression_re        # = anything-else-incl-nested-parens
       )
     )?
     \s? [,;] \s?}oamsx, 'field_decl', '');

our $typedef_decl_re = compile_regexp(
  qr{(?'typedef_decl'
       (?'type_ptr_or_ref' $ptr_or_ref_re) \s
       (?'typedef_new_type_name' $cxx_identifier_re)
       (?> \s \[ (?'array_size' $inside_square_brackets_re) \] )?
     )
     \s (?> [,;] | \Z)
    }oamsx, 'typedef_decl', '');

our $function_type_name_args_body_re = compile_regexp(
  qr{(?> $template_spec_re \s)?
     (?'function_attributes'
       (?> \b (?: const(?>expr)? | static | volatile |
           inline | explicit | noexcept | virtual |
           friend | atomic) \s ){0,10}
     )
     (?:
       (?'function_name'
         (?'constructor_name' $cxx_identifier_re) |
         (?'destructor_name' \~ \s $cxx_identifier_re) |
         (?: \b operator \s (?'casting_operator_name' (?> $type_spec_re)))
       ) |
       (?:
         (?'return_type' $type_spec_re)
         (?'function_name'
           (?> 
             operator \s
             (?'operator_name' $cxx_extended_operators_re)
           ) |
           $cxx_identifier_re
         )
       )
     ) \s
     \( (?'argument_list' $inside_parens_re) \) \s
     (?'trailing_function_attributes'
       (?>
         (?: && | const | volatile | noexcept (?> \s $parens_re)?) \s 
       ){0,4}
     )
     (?:
       (?> \= \s \b (?'default_or_delete_or_purevirt_suffix' de(?>fault|lete) | 0))? \s ; |
       (?>
         (?> \: (?'constructor_initializer_list' (?: \s $cxx_identifier_re \s $parens_re \s \,?){1,1024}))?
         \{ (?'function_body' $inside_braces_re) \} \s ;?
       )
     )}oamsx, 'function_type_name_args_body', '');

our $function_decl_argument_list_item_re = compile_regexp(
  qr{\G \s?
      (?:
        (?'variadic_arg' (?> $cxx_identifier_re)? \s \.\.\.) |
        (?>
          (?> $type_spec_re)
          (?> (?'arg_name' $cxx_identifier_re))?
          (?'default_arg_value' \s \= \s $rvalue_expression_re)?
        )
      )
      \s? (?> , | \Z)
     }oamsx, 'function_decl_argument_list_item_re', '');

our $enum_def_re = compile_regexp(
  qr{\b enum
     (?> \s (?'enum_name' $cxx_identifier_re))?
     (?> \s \: \s (?'enum_datatype' $cxx_identifier_re))?
     \s \{ (?'enum_list' $inside_braces_re) \} \s ; 
     }oamsx, 'enum_def', '');

our $declaration_or_block_re = compile_regexp(
  qr{\G (?> \s*+)
      (?>
        $enum_def_re |  # enum { ... }
        (?> \b (?'access_spec' p(?>ublic|r(?>otected|ivate))) \s \:) |
        (?>
          \b typedef \s
          (?'typedef_base_type' (?> $type_spec_re))
          (?'typedef_decl_list' [^\;]+) \s ;
         ) |
         (?'function_chunk' $function_type_name_args_body_re) |
         (?> $type_spec_re) (?'field_decl_list' [^;]+ \s ;) # field declaration
       ) \s*+}oamsx, 'declaration_or_block', '');

our $class_struct_union_re = compile_regexp(
  qr{(?> $template_spec_re \s)? # (optional) template specification
      (?> \w+ \s)*+              # (optional) attributes, e.g. autogen, etc.
      (struct|union|class) \s    # class, struct or union
      (?> ($cxx_identifier_re))     # name
      (?> \s \: \s [^\{\;]*+)?  # (optional) inheritance specification
      \s \{ ($inside_braces_re) \} \s \;
     }oamsx, 'class_struct_union');

# regex to match any C/C++ token, from http://www.perlmonks.org/?node_id=1049222
#our $old_cxx_token_re = compile_regexp(
#  \qr/(((\?+|(\?\/|\/)(\?\/)*\?*)|([^\'\"\/\s\?]|((\?|\/)\?+[^\s\?\"])|((\?\/|\/)(\?\/)*([^\'\"\/\s\?\*]|\?(\?+[^\?\"\s]|[^\'\"\/\s\?]))))([^\'\"\/\s\?]|\?\?+[^\?\"\s]|(\/|\?\/)(\?\/)*([^\'\"\/\s\?\*]|\?(\?+[^\?\"\s]|[^\'\"\/\s\?])))*((\?+|(\/|\?\/)(\?\/)*\?*)?))|((\'([^\'?\\]|\\.|\?(\?+(\/.|[^?\/])))*(\'|\?\'))|(\"([^\"\\?]|\\.|\?\?+(\/.|[^\?\"\/]))*(\"|\?+\"))))/oamsx,
#  'cxx_token');

our $if_or_ifdef_endif_re = compile_regexp(
  qr{((?:
    \#if(?:def)?
    (?:
      (?> [^\#]+) | \# (?! if (?:def)?) (?! endif) | (?-1)
    )*
    \#endif
  ))}oamsx, 'if_or_ifdef_endif_re',
  '#if or #ifdef with enclosed text optionally including nested #if/#ifdef '.
  ' blocks, #else clauses, or #elif clauses, and terminated by properly '.
  ' balanced #endif',
  \('1' => 'entire matched block including balanced delimiters'));

our $inside_if_or_ifdef_optional_else_endif_re = compile_regexp(
  qr{(?:
    \# (?'if_or_ifdef' if(?:def)?) \s (?'if_condition' (?: \\\n | \N)+) \n
    (?'if_contents' (?: 
      $if_or_ifdef_endif_re | \# (?! endif) | \# (?! else) | [^\#]+
    )*)
    (?: \# (?'else' else) \b (?'else_comment' \N*) \n)?
    (?'else_contents' (?: 
      $if_or_ifdef_endif_re | \# (?! endif) | [^\#]+
    )*)
    \# endif \s? (?'endif_comment' \N*) \n
  )}oamsx, 'inside_if_or_ifdef_optional_else_endif_re');

our $cxx_balanced_structural_chars_re = compile_regexp(
  qr{([\{\(\[\<])|([\}\)\]\>])}oamsx, 'cxx_balanced_structural_chars');

use constant {
  CXX_TOKEN_WHITESPACE   => 1,
  CXX_TOKEN_COMMENT      => 2,
  CXX_TOKEN_QUOTED       => 3,
  CXX_TOKEN_NUMERIC      => 4,
  CXX_TOKEN_OPERATOR     => 5,
  CXX_TOKEN_IDENTIFIER   => 6,
  CXX_TOKEN_STRUCTURAL   => 7,
  CXX_TOKEN_PREPROCESSOR => 8,
};

our $cxx_token_re = compile_regexp(
  qr{\G
      (                                           # entire token is $1
        (?>
          $c_cxx_comment_re (*:2) |
          $cxx_identifier_re (*:6) |
          $cxx_quoted_literal_nocap_re (*:3) |             # $2 embedded within quoted_literal_nocap_re, for the raw string backref)
          $numeric_literal_nocap_re (*:4) |
          $preprocessor_re (*:8)|
          $cxx_extended_operators_re (*:5) |           # $3 embedded within cxx_extended_operators_re, for the repeated operators backref e.g. ++ -- && || << >> etc.
          [\(\)\{\}\[\]\;\,] (*:7)
        )
      )
      (?'whitespace' (?> \s | (?: \\ \n))*+)
      }oamsx, 'cxx_token');

our $c_cxx_include_guard_or_pragma_once_re =  compile_regexp(
  qr{^ \s*+ \# \s*+ 
     (?|
       (?> (pragma) \s++ () (once)) |
       (?> 
         ifndef \s++ (\w+? _ [Hh] _*) [\ \t]*+ \n
         define \s++ \g{-1} [\ \t]*+ \n
       )
     )}oamsx, 'c_cxx_include_guard_or_pragma_once_re');

my $c_cxx_preprocessor_include_directive_or_pragma_end_of_includes_re = compile_regexp(
  qr{^ \s*+ \# \s*+ (?|
       (?> (include) \s++ ([\<\"]) ([^\>\"]++) [\>\"]) |
       (?> (pragma) () \s++ (end_of_(?> headers | includes)))
     )}oamsx, 'c_cxx_preprocessor_include_directive_or_pragma_end_of_includes_re');

our $strip_non_functional_cxx_syntax_re = compile_regexp(
  qr{(?> $c_cxx_comment_re) | 
     (?> $cxx_quoted_literal_nocap_re)
  }oamsx, 'strip_non_functional_cxx_syntax',
  'Matches any non-functional elements in C/C++ source code, '.
  'including comments and quoted strings. These should all be '.
  'stripped or ignored when searching for identifiers in C/C++ '.
  'code, to prevent such identifiers within e.g. comments or '.
  'strings from being erroneously matched.');

# Required vs optional whitespace
my $S = qr{[\ \t]++};
my $S_ = qr{[\ \t]*+};

our $c_cxx_included_filename_with_angle_bracket_or_quote_re = compile_regexp(
  qr{([\<\"]) ([^\>\"]++) ([\>\"])}oamsx,
  'c_cxx_included_filename_with_angle_bracket_or_quote_re');

our $c_cxx_included_deps_re = compile_regexp(
  qr{(?|
       # We use three empty capture groups before the parts we strip
       # to ensure no capture groups within the stripping regexps
       # (which need to define capture groups for recursion even
       # though they are not intended to capture anything useful) 
       # will be erroneously matched instead of being ignored.
       #
       # Therefore, callers should ignore any apparent matches 
       # for which $1 is an empty string.
       #
       (?> () () () (?> $c_cxx_comment_re | $cxx_quoted_literal_nocap_re) (*:ignore)) |
       #
       # Actual dependency on an included file (at least by its relative path):
       #
       ^ [\ \t]*+ \# [\ \t]*+
       (?|
         (?> (include) [\ \t]++ $c_cxx_included_filename_with_angle_bracket_or_quote_re (*:include)) |
         #
         # The 'pragma once' and 'ifndef/define' header guard patterns help us
         # distinguish header files from compilable source files:
         #
         (?> (pragma) [\ \t]++ () (end_of_ (?> headers | includes) | hdrstop | once) (*:pragma)) | 
         (?> (if) (*:if) (?|
           (?> (n?)def [\ \t]++ (\w++)
             (?> \n [\ \t]*+ \# [\ \t]*+ define [\ \t]++ (\w++))?
           ) |
           (?> 
             [\ \t\(]*+ (\!?) [\ \t]*+ 
             (?> \b defined [\ \t\(]*+ )? 
             \b (\w++)
              )
            )
         ) |
         (?> (endif) \b () () (*:endif)) |
         (?> 
           (define) [\ \t]++ () (\w++) [\ \t]++ 
           ((?> [^\n/]++ | / [^\*\/])*) (*:define)
         ) |
         (?> (?> (line) [\ \t]++)? (\d++) [\ \t]++ $double_quoted_string_re (*:line))
       )
      \N*+ [\ \t]*+ \n
     )}oamsx, 'c_cxx_included_deps_re',
  'Finds all header files included by the input C/C++ source code, along with '.
  'several related constructs, specifically ifndef/define style include guards, '.
  'pragma once and pragma end_of_includes. $1 captures the directive (include, '.
  'pragma, ifdef, ifndef, endif), $2 captures either a left angle bracket (<) or '.
  'a quote (") specifying the set of include search paths to use (see the cpp man '.
  'page for details), $3 is the relative filename to be included. If a match is '.
  'found but $1 is empty, the match should be ignored (this is an artifact of how '.
  'this regexp ignores spurious appearances of comments and strings).');

our @all_capture_group_names = 
  qw(access_spec 
     alias_to_type
     argument_list
     array_size
     bitwidth
     casting_operator_name
     constructor_initializer_list
     constructor_or_destructor_name
     default_or_delete_or_purevirt_suffix
     enum_datatype
     enum_list
     enum_name
     field_decl_list
     field_decl_rest
     field_name
     function_attributes
     function_body
     function_chunk
     function_name
     trailing_function_attributes
     init_value
     operator_name
     type_attributes
     type_name
     type_ptr_or_ref
     type_specifier
     typedef_base_type
     typedef_decl_rest
     typedef_new_type_name);

1;
