#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::RegExp::CxxParser
#
# C++ Parser for relevant portions of the language grammar
# (i.e. class/struct/union definitions, templates, typedefs, operators, etc.)
#
# Copyright 2008-2014 Matt T. Yourst <yourst@yourst.com>. All rights reserved.
#

package MTY::RegExp::CxxParser;

use integer; use warnings; use Exporter::Lite;

nobundle:; our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($cxx_parser_error $debug_strings
     $enable_template_angle_bracket_special_case $leading_whitespace_re
     $nl_cr_ff_not_bs_nl_re $print_token_type_names
     $print_whitespace_after_tokens @cxx_token_type_full_names
     @cxx_token_type_names @cxx_token_type_to_color
     cxx_tokenize_and_extract_strings parse_struct_def
     print_parsed_struct_enums print_parsed_struct_fields
     print_parsed_struct_function print_parsed_struct_functions
     print_parsed_struct_typedefs print_tokenized_cxx
     reconstruct_member_function reconstruct_member_functions
     reinsert_extracted_strings replace_tokens_with_macro_defs_callback
     tokenize_and_extract_strings_callback tokenize_cxx);

our @EXPORT_OK = qw(
  $DEBUG);

use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Common::Strings;
use MTY::Filesystem::Files;
use MTY::RegExp::Define;
use MTY::RegExp::Tools;
use MTY::RegExp::Blocks;
use MTY::RegExp::Strings;
use MTY::RegExp::Numeric;
use MTY::RegExp::CxxREs;
use MTY::Display::Colorize;
use MTY::Display::PrintableSymbols;
use MTY::Display::PrintableSymbolTools;

export_optional: our $DEBUG = 0;

our @cxx_token_type_names = 
  ('token',
   hatched_square_medium, # whitespace
   '/*', # comment
   left_quote.right_quote, # quoted string
   '#', # numeric
   plus_minus_symbol, # operator
   'id', # identifier
   bold_left_brace.bold_right_brace, # structural
   'pp' # preprocessor
  ); 

our @cxx_token_type_to_color = 
  ('',
   $B, # '__',
   $K, # '/*',
   $C, # '""',
   $C, # '##',
   $G, # 'OP',
   $Y, # 'ID',
   $M, # 'ST',
   $R, # 'PP'
);

our @cxx_token_type_full_names = 
  ('token',
   'whitespace',
   'comment',
   'quoted_literal',
   '<quoted_literal_internal_cap_group>',
   'numeric_literal',
   'operator',
   'identifier',
   'structural',
   'preprocessor');

#
# To simplify and accelerate all subsequent regular expressions,
# we first normalize the entire file (*without* altering the C/C++
# code's semantics) as follows:
#
# - The input is tokenized according to the standard C/C++ tokenization
#   grammar, and the output consists of each token followed by a single
#   whitespace character which is:
#
#   - a newline (\n) if and only if the whitespace character(s) after the
#     original token contained at least one newline, or:
#
#   - a space (' ') otherwise (if the trailing whitespace had no newlines)
#
# This space-or-newline rule helps maintain the original source's line
# numbers so compiler error messages will still be (mostly) accurate.
#
# - All strings (double quoted or single quoted) are replaced with
#   placeholder strings of the form:
#
#     "ID12345"
#
#   where 12345 is the index into the @extracted_strings array where we
#   saved the original string (including its quotes, i.e. "" or '').
#   After all other passes are performed, the original strings are
#   substituted back into the code according to these placeholders.
#
#   This avoids situations where our regular expressions could erroneously
#   match parts of quoted strings which appear to be valid C/C++ syntax.
#   (This is very common in C++ code which automatically generates other
#   code, as well as in code which simply prints out data structures).
#   Without this step, every regexp would have to explicitly check if each
#   prospective match was part of a string and thus should be ignored,
#   which is impractical or even impossible to express in many regexps.
#

our $cxx_parser_error = undef;

our $debug_strings = 0;
our $print_token_type_names = 0;
our $print_whitespace_after_tokens = 1;
our $enable_template_angle_bracket_special_case = 0;

our $nl_cr_ff_not_bs_nl_re = qr{[\n\r\f] | (?> [^\\] \n)}oamsx;

#
# Prime the loop by eating any initial leading whitespace;
# this way we only need to handle whitespace at the end of
# the token (i.e. between two tokens) from now on:
#
our $leading_whitespace_re = qr{\A (\s*)}oamsx;

sub tokenize_and_extract_strings_callback($$$$$$;$+) {
  my ($token, $token_type_id, $whitespace, $startpos, $line, $debuglog_ref, 
      # These are passed through from the caller of tokenize_cxx():
      $output_ref, $extracted_strings) = @_;

  # negative value of the current line argument indicates the end of that line:
  my $newline = ($line < 0) ? 1 : 0;

  if (($token_type_id == CXX_TOKEN_QUOTED) && defined($extracted_strings)) {
    my $id = scalar(@$extracted_strings);
    push @$extracted_strings, $token;
    my $placeholder = '"ID'.$id.'"';
    
    if ($debug_strings && defined($tokendump)) {
      my $len = length($token);
      ${$tokendump} .= $K.left_quote.$C.($token =~ s/["']//roamsxg).$K.right_quote.
        $B.' '.arrow_barbed.' '.$K.left_quote.$G.'ID'.$id.$K.right_quote.$X;
      #' ('.$Y.$len.$K.' chars '.
      #'@ line '.$Y.$line.$K.', offset '.$Y.$offs.$K.')'.$X.NL;
    }

    ${$output_ref} .= $placeholder;
  } elsif ($token_type_id == CXX_TOKEN_COMMENT) {
    ; # skip comments with no output
  } else {
    ${$output_ref} .= $token;
  }

  ${$output_ref} .= ($newline) ? NL : ' ';

  return $token;
}

sub replace_tokens_with_macro_defs_callback($$$$$$;$+) {
  my ($token, $token_type_id, $whitespace, $startpos, $line, $debuglog_ref, 
      # These are passed through from the caller of tokenize_cxx():
      $output_ref, $defs) = @_;

  if ($token_type_id == CXX_TOKEN_IDENTIFIER) {
    my $replacement = $defs->{$token};
    if (defined $replacement) {
      if ($DEBUG) {
        print(STDERR 'Replaced token '.format_chunk($token).' with '.
                format_chunk($replacement).' at offset '.$startpos.NL);
      }
      $token = $replacement;
    }
  }

  ${$output_ref} .= $token . $whitespace;

  return $token;
}

sub tokenize_cxx ($&;@) {
  my $original = shift;
  my $callback = shift;
  # remaining args are forwarded to each invocation of callback

  my ($leading_whitespace) = ($original =~ /$leading_whitespace_re/oamsxgc);
  my $line = 1 + length($leading_whitespace =~ s/[^\n]//roamsxg);
  
  if ($DEBUG) { 
    print(STDERR $B.'Leading whitespace had '.length($leading_whitespace).
          ' characters with '.($line-1).' newlines'.$X.NL);
    print(STDERR $B.'pos(original) = '.pos($original).$X.NL);
  }

  local $REGMARK = undef;
  local $REGERROR;

  my $braces_level = 0;
  my $parentheses_level = 0;
  my $square_brackets_level = 0;
  my $angle_brackets_level = 0;

  my $chars_on_this_line = 0;
  my $max_chars_per_line = $ENV{'COLUMNS'} // 120;

  while ($original =~ /$cxx_token_re/oamsxgc) {
    my $token = $1;
    my $whitespace = $+{whitespace} // ''; 
    my $token_type_id = $REGMARK // CXX_TOKEN_WHITESPACE;
    my $basepos = $-[0];

    my $color = '';    
    if ($DEBUG) { 
      $color = $cxx_token_type_to_color[$token_type_id]; 
      if (($token_type_id == CXX_TOKEN_IDENTIFIER) && 
          (exists $cxx_keywords{$token})) {
        $color = $M;
      }
    }

    my $tokendump = '';

    $token =~ s/$backslash_newline_re/ /oamsxg;
    $whitespace =~ s/$backslash_newline_re/ /oamsxg;
    rewind($whitespace);

    if (($token_type_id == CXX_TOKEN_OPERATOR) && ($enable_template_angle_bracket_special_case)) {
      #
      # According to the C++11 spec, the '>>' token is treated as two separate
      # '>' tokens if and only if both of the following conditions are true:
      #
      # 1. The >> token appears where one or more left angle brackets are active,
      #    i.e. not yet balanced by a right angle bracket.
      #
      # 2. The >> token is not nested within a delimited expression context,
      #    i.e. < ... (x << y, ...) ...> is parsed as an operator since it's
      #    within parentheses, square brackets or braces.
      #
      if ($token =~ /$cxx_balanced_structural_chars_re/oamsxg) {
        my $incr = (defined $1) ? +1 : (defined $2) ? -1 : undef;
        if ($token eq '{' || $token eq '}') {
          $braces_level += $incr;
        } elsif ($token eq '(' || $token eq ')') {
          $parentheses_level += $incr;
        } elsif ($token eq '[' || $token eq ']') {
          $square_brackets_level += $incr;
        } elsif ($token eq '<' || $token eq '>') {
          $angle_brackets_level += $incr;
        } elsif ($token eq '>>') {
          if (($angle_brackets_level >= 2) && 
             ($parentheses_level == 0) &&
             ($square_brackets_level == 0)) {
            $token = '> >';
          }
        } elsif ($token eq '>>>') {
          if (($angle_brackets_level >= 3) && 
              ($parentheses_level == 0) &&
              ($square_brackets_level == 0)) {
            $token = '> > >';
          }
        }
      }
    }

    #
    # If the whitespace following the token contained a newline (\n), 
    # consolidate the whitespace into only that newline; otherwise
    # output a single space instead. This helps preserve the compiler's
    # line numbering to provide more accurate error and warning messages.
    #

    rewind($whitespace);
    my $newline = ($whitespace =~ /$nl_cr_ff_not_bs_nl_re/oamsx) ? 1 : 0;
    rewind($whitespace);

    my $result = $callback->($token, $token_type_id, $whitespace, $basepos, 
                             ($newline ? -$line : +$line), \$tokendump, @_);

    if ($DEBUG) { 
      $token_type_name = $cxx_token_type_names[$token_type_id] // ('?'.$token_type_id);
      $tokendump .= $color;
      if ($print_token_type_names) { $tokendump .= $token_type_name.' '; };
       
      if ($token_type_id != CXX_TOKEN_QUOTED) {
        $tokendump .= special_chars_to_printable_symbols($token, $color).$X;
      }
      if (($whitespace =~ /[^\ ]/oams) && $print_whitespace_after_tokens) {
        $tokendump .= $B.dotted_vert_bar_3_dots.$R.special_chars_to_printable_symbols($whitespace, $color).$X;
      }
    }

    $line += $newline;

    if ($DEBUG) {
      if ($newline) { 
        $tokendump .= ' '.$B.return_enter_key_symbol.$X;
      } else {
        $tokendump .= $B.dashed_vert_bar_4_dashes.$X;
      }

      my $tokendump_length = printed_length($tokendump);
      if (($chars_on_this_line + $tokendump_length) >= $max_chars_per_line) {
        print(STDERR NL.$tokendump);
        $chars_on_this_line = $tokendump_length;
      } else {
        print(STDERR $tokendump);
        $chars_on_this_line += $tokendump_length; 
      }
      if ($newline) {
        print(STDERR $tokendump.NL);
        $chars_on_this_line = 0;
      }
    }

    last if (!defined($result));
  }

  if ($DEBUG) {
    print(STDERR NL);
  }

  my $p = pos($original) // 0;
  
  if ($p < length($original)) {
    my $parsed_so_far = special_chars_to_printable_symbols(substr($original, max($p - 160, 0), min($p, 160)), $G);
    my $remaining = special_chars_to_printable_symbols(substr($original, $p, 160), $R);
    
    $cxx_parser_error = 
      $Y.'Could not tokenize input: '.$W.NL.'last good token was near line '.
      $C.$line.$W. ' at offset '.$C.$p.$X.NL.$W.
      'Remaining input after that point ('.$C.(length($original)-$p).
      $W.' chars):'.$X.NL.$R.$remaining.$K.'...'.$X.NL.NL.
      $W.'Parsed input up to that point:'.NL.$B.'...'.$G.$parsed_so_far.$X.NL;

    return undef;
  }

  return $original;
}

sub cxx_tokenize_and_extract_strings($;+$) {
  my ($original, $extracted_strings, $DEBUG) = @_;


  my ($leading_whitespace) = ($original =~ /$leading_whitespace_re/oamsxgc);
  my $line = 1 + length($leading_whitespace =~ s/[^\n]//roamsxg);
  my $text = '';
  
  if ($DEBUG) { 
    print(STDERR $B.'Leading whitespace had '.length($leading_whitespace).
          ' characters with '.($line-1).' newlines'.$X.NL);
    print(STDERR $B.'pos(original) = '.pos($original).$X.NL);
  }

  local $REGMARK = undef;
  local $REGERROR;

  my $braces_level = 0;
  my $parentheses_level = 0;
  my $square_brackets_level = 0;
  my $angle_brackets_level = 0;

  my $chars_on_this_line = 0;
  my $max_chars_per_line = $ENV{'COLUMNS'} // 120;

  while ($original =~ /$cxx_token_re/oamsxgc) {
    my $token = $1;
    my $whitespace = $+{whitespace} // ''; 
    my $token_type_id = $REGMARK // CXX_TOKEN_WHITESPACE;
    
    my $color = '';    
    if ($DEBUG) { 
      $color = $cxx_token_type_to_color[$token_type_id]; 
      if (($token_type_id == CXX_TOKEN_IDENTIFIER) && 
          (exists $cxx_keywords{$token})) {
        $color = $M;
      }
    }
    my $tokendump = '';

    $token =~ s/$backslash_newline_re/ /oamsxg;
    $whitespace =~ s/$backslash_newline_re/ /oamsxg;
    rewind($whitespace);

    #my $result = $process_token_func->($token, $token_type_id, $whitespace, $line);

    if (($token_type_id == CXX_TOKEN_QUOTED) && defined($extracted_strings)) {
      my $id = scalar(@$extracted_strings);
      push @$extracted_strings, $token;
      my $placeholder = '"ID'.$id.'"';
     
      if ($debug_strings) {
        my $len = $+[0] - $-[0];
        my $offs = $-[0];
        $tokendump .= $K.left_quote.$C.($token =~ s/["']//roamsxg).$K.right_quote.
              $B.' '.arrow_barbed.' '.$K.left_quote.$G.'ID'.$id.$K.right_quote.$X;
        #' ('.$Y.$len.$K.' chars '.
        #'@ line '.$Y.$line.$K.', offset '.$Y.$offs.$K.')'.$X.NL;
      }
      $text .= $placeholder;
    } elsif ($enable_template_angle_bracket_special_case && ($token_type_id == CXX_TOKEN_OPERATOR)) {
      #
      # According to the C++11 spec, the '>>' token is treated as two separate
      # '>' tokens if and only if both of the following conditions are true:
      #
      # 1. The >> token appears where one or more left angle brackets are active,
      #    i.e. not yet balanced by a right angle bracket.
      #
      # 2. The >> token is not nested within a delimited expression context,
      #    i.e. < ... (x << y, ...) ...> is parsed as an operator since it's
      #    within parentheses, square brackets or braces.
      #
      if ($token =~ /$cxx_balanced_structural_chars_re/oamsxg) {
        my $incr = (defined $1) ? +1 : (defined $2) ? -1 : undef;
        if ($token eq '{' || $token eq '}') {
          $braces_level += $incr;
        } elsif ($token eq '(' || $token eq ')') {
          $parentheses_level += $incr;
        } elsif ($token eq '[' || $token eq ']') {
          $square_brackets_level += $incr;
        } elsif ($token eq '<' || $token eq '>') {
          $angle_brackets_level += $incr;
        } elsif ($token eq '>>') {
          if (($angle_brackets_level >= 2) && 
             ($parentheses_level == 0) &&
             ($square_brackets_level == 0)) {
            $token = '> >';
          }
        } elsif ($token eq '>>>') {
          if (($angle_brackets_level >= 3) && 
              ($parentheses_level == 0) &&
              ($square_brackets_level == 0)) {
            $token = '> > >';
          }
        }
      }
      $text .= $token;
    } elsif ($token_type_id == CXX_TOKEN_COMMENT) {
      ; # just skip it
    } elsif ($token_type_id != CXX_TOKEN_QUOTED) {
      $text .= $token;
    }

    if ($DEBUG) { 
      $token_type_name = $cxx_token_type_names[$token_type_id] // ('?'.$token_type_id);
      $tokendump .= $color;
      if ($print_token_type_names) { $tokendump .= $token_type_name.' '; };
       
      if ($token_type_id != CXX_TOKEN_QUOTED) {
        $tokendump .= special_chars_to_printable_symbols($token, $color).$X;
      }
      if (($whitespace =~ /[^\ ]/oams) && $print_whitespace_after_tokens) {
        $tokendump .= $B.dotted_vert_bar_3_dots.$R.special_chars_to_printable_symbols($whitespace, $color).$X;
      }
    }

    #
    # If the whitespace following the token contained a newline (\n), 
    # consolidate the whitespace into only that newline; otherwise
    # output a single space instead. This helps preserve the compiler's
    # line numbering to provide more accurate error and warning messages.
    #
    #my $newline = (defined($whitespace) && ($whitespace =~ /$nl_cr_ff_not_bs_nl_re/oamsxg));
    rewind($whitespace);
    my $newline = ($whitespace =~ /$nl_cr_ff_not_bs_nl_re/oamsx) ? 1 : 0;
    $text .= ($newline) ? NL : ' ';
    $line += $newline;
    #print(STDERR NL.$R.'Text so far after adding '.format_chunk($token).' with whitespace ('.length($whitespace).' chrs -> ord '.ord($whitespace).' = '.format_chunk($whitespace).$R.' (NL? '.$newline.'): '.$X.format_chunk($text).$X.NL);

    if ($DEBUG) {
      if ($newline) { 
        $tokendump .= ' '.$B.return_enter_key_symbol.$X;
      } else {
        $tokendump .= $B.dashed_vert_bar_4_dashes.$X;
      }

      my $tokendump_length = printed_length($tokendump);
      if (($chars_on_this_line + $tokendump_length) >= $max_chars_per_line) {
        print(STDERR NL.$tokendump);
        $chars_on_this_line = $tokendump_length;
      } else {
        print(STDERR $tokendump);
        $chars_on_this_line += $tokendump_length; 
      }
      if ($newline) {
        print(STDERR $tokendump.NL);
        $chars_on_this_line = 0;
      }
    }
  }

  if ($DEBUG) {
    print(STDERR NL);
  }

  my $p = pos($original) // 0;
  
  if ($p < length($original)) {
    my $parsed_so_far = special_chars_to_printable_symbols(substr($original, max($p - 160, 0), min($p, 160)), $G);
    my $remaining = special_chars_to_printable_symbols(substr($original, $p, 160), $R);
    
    $cxx_parser_error = 
      $Y.'Could not tokenize input: '.$W.NL.'last good token was near line '.
      $C.$line.$W. ' at offset '.$C.$p.$X.NL.$W.
      'Remaining input after that point ('.$C.(length($original)-$p).
      $W.' chars):'.$X.NL.$R.$remaining.$K.'...'.$X.NL.NL.
      $W.'Parsed input up to that point:'.NL.$B.'...'.$G.$parsed_so_far.$X.NL;

    return undef;
  }

  return $text;
}

sub print_tokenized_cxx($) {
  return cxx_tokenize_and_extract_strings($_[0], undef, 1);
}

my $extracted_string_placeholder_re = qr{\"ID(\d+)\"}oamsx;

sub reinsert_extracted_strings($+) {
  my $extracted_strings = $_[1];
  
  #
  # (at the end!):
  # Re-insert the string constants we previously extracted and 
  # replaced with numeric ID placeholders:
  #

  my $extracted_string_count = scalar(@$extracted_strings);
  my $reinserted_string_count = 0;
  $_[0] =~ s/$extracted_string_placeholder_re/$reinserted_string_count++, $extracted_strings->[$1]/oamsxge;

  if ($DEBUG) {
    printf(STDERR $B.'Extracted '.$extracted_string_count.' string constants '.
           'and then reinserted '.$reinserted_string_count.' of them'.$X.NL);
  }

  if ($extracted_string_count != $reinserted_string_count) {
    print(STDERR $R.'extracted_string_count = '.$extracted_string_count.
          ' but reinserted_string_count = '.$reinserted_string_count.
          ' (delta of '.($reinserted_string_count-$extracted_string_count).
          ' may be harmless if code restructuring or auto-generation passes'.
          ' removed expressions which contained the affected string constants'.
          ' and/or duplicated some of them.'.$X.NL);
  }

  return $_[0];
}

sub parse_struct_def {
  my ($struct_class_union, $structname, $inheritance, $block) = @_;


  my @fields = ();
  my @functions = ();
  my @typedefs = ();
  my @enums = ();
  my @nested_structs = ();

  my $blocklen = length($block);

  if ($DEBUG) {
    print(STDERR $Y.$U.'process_struct_def:'.$X.' '.$struct_class_union.' '.
          $G.$structname.$X.' (inherits from'.$M.' '.$inheritance.' '.$X.'): '.
          'block ('.$blocklen.' chars'.') = '.NL);
    print(STDERR format_chunk($block, 120) . NL);
  }

  my $word_index = 0;
  my $ending_pos_in_block = 0;

  pos($block) = 0;
  my $startpos = pos($block);

  if ($DEBUG) {
    print(STDERR NL.$C.$U.'Parsing struct '.$Y.$structname.':'.$X.NL.NL);
    print(STDERR $B.'startpos = '.$startpos.$X.NL);
  }

  my $current_access_spec = (($struct_class_union eq 'class') ? 'private' : 'public');
  my $fieldid = 0;
  my $funcid = 0;
  my $memberid = 0;

  while ($block =~ /$declaration_or_block_re/oamsgc) {
    foreach my $k (@all_capture_group_names) { undef $$k; }
    my $startbit = 0; my $endbit = 0; my $bitwidth = 0;

    my $endpos = pos($block);
    my $matchlen = $endpos - $startpos;

    if ($DEBUG && 0) {
      print(STDERR '  '.$B.$U.'[@ pos '.$startpos.':'.($endpos-1).' ('.$matchlen.' chars)]: '.
            $R.'chunk: '.format_chunk(substr($block, $startpos, $matchlen), 120).':'.$X.NL);
      foreach my $k (keys %+) {
        my $v = $+{$k};
        next if (is_empty($v));
        print(STDERR '  '.$K.'| '.$Y.$k.$K.' ('.length($v),' chars) = '.format_chunk($v, 120).$K.$X.NL);
      }
    }

    my %common_info = ( );

    foreach my $k (keys %+) {
      my $v = remove_leading_trailing_space($+{$k});
      next if (is_empty($v));
      $$k = $v;
      # Don't include composite lists since they won't be accurate when we're using one record per declaration:
      if (($k ne 'field_decl_list') && ($k ne 'typedef_decl_list')) { $common_info{$k} = $v; }
    }

    $common_info{memberid} = $memberid;
    $common_info{startpos} = $startpos;
    $common_info{endpos} = $startpos + $matchlen;
    $common_info{chunksize} = $matchlen;
    $common_info{access_spec} = $current_access_spec;
    my $type_attributes = $common_info{type_attributes} // '';
    my $is_const_field = ($type_attributes =~ /const/oamsx) ? 1 : 0;
    my $is_static_field = ($type_attributes =~ /static/oamsx) ? 1 : 0;

    $common_info{is_const_field} = $is_const_field;
    $common_info{is_static_field} = $is_static_field;

    #remove_leading_trailing_space_on_hash_values(\%common_info);

    my $argument_list = $common_info{argument_list};

    if (defined($field_decl_list)) {
      if ($DEBUG) {
        print(STDERR $U.$C.'Field: '.
              $Y.'type.attrs'.$K.'='.$G.format_quoted($common_info{type_attributes}).$K.', '.
              $Y.'type.spec'.$K.'='.$G.format_quoted($common_info{type_specifier}).$K.', '.
              $Y.'type.ptr_or_ref'.$K.'='.$G.format_quoted($common_info{type_ptr_or_ref}).$K.', '.
              $Y.'field.decl'.$K.'='.format_chunk($field_decl_list, 120).NL);
      }

      my $field_decl_list_pos = 0;

      my $startbit = 0;

      my $prev_was_bitfield = 0;
      my $decls_in_this_chunk = 0;
      my $bitfield_index = 0;
      my $bitfield_contained_in_raw_field = '';

      while ($field_decl_list =~ /$field_decl_re/oamsgcx) {
        my $field_name = $+{field_name};
        my $bitwidth = $+{bitwidth};
        my $array_size = $+{array_size};
        my $init_value = $+{init_value};
        my $field_decl_rest = $+{field_decl_rest};
        my $is_bitfield = ((defined($bitwidth) && ($bitwidth > 0)) ? 1 : 0);
        my $is_padding = (length($field_name) == 0) ? 1 : 0;
        my $endbit = ($is_bitfield) ? ($startbit + $bitwidth - 1) : 0;

        if ($is_padding) { $field_name = "__padding_$fieldid"; }
        if ($bitfield_index == 0) { $bitfield_contained_in_raw_field = 'rawdata_'.$field_name; }

        my %field_info = ();

        foreach my $k (keys %common_info) { $field_info{$k} = $common_info{$k}; }

        foreach my $k (keys %+) {
          my $v = remove_leading_trailing_space($+{$k});
          if (is_filled($v)) { $field_info{$k} = $v; }
        }

        # Insert dynamically calculated properties:
        $field_info{field_name} = $field_name;
        $field_info{is_bitfield} = $is_bitfield;
        if ($is_bitfield) {
          $field_info{startbit} = $startbit;
          $field_info{endbit} = $endbit;
          $field_info{bitfield_index} = $bitfield_index;
          $field_info{bitfield_contained_in_raw_field} = $bitfield_contained_in_raw_field;
        }
        $field_info{is_padding} = $is_padding;
        $field_info{word_index} = ($is_const_field || $is_static_field) ? -1 : $word_index;
        $field_info{fieldid} = $fieldid;

        push @fields, { %field_info };

        if ($DEBUG) {
          print(STDERR '     '.$B.'[@ pos '.$field_decl_list_pos.' in field_decl_list]: '.
              format_chunk(substr($field_decl_list, $field_decl_list_pos, (pos($field_decl_list) - $field_decl_list_pos)), 120).$K.NL);

          foreach my $k (keys %field_info) {
            my $v = $field_info{$k};
            if (!defined($v)) { $v = '<undef>'; }
            print(STDERR '     '.$K.'- '.$Y.$K.'- '.$Y.$k.$K.' = '.format_chunk($v, 120).$K.NL);
          }
        }

        $field_decl_list_pos = pos($field_decl_list);

        if ($is_bitfield) {
          $bitfield_index++;
          $startbit += $bitwidth;
        }

        if (!($is_bitfield || $is_const_field || $is_static_field)) { $word_index++; }

        $fieldid++;
        $prev_was_bitfield = $is_bitfield;

        #if ($field_name eq 'c') {
        #print(STDERR $C.'REMAINDER'.$K.' = '.format_chunk(substr($block, pos($block)), 120).$X.NL);
        #}
      }
      if ($prev_was_bitfield) { $word_index++; }
    } elsif (defined($function_chunk)) {
      if ($DEBUG) {
        print(STDERR '  '.$U.$B.'@ pos '.$startpos.': '.$C.'parsing function '.
              format_chunk($function_chunk, 120).':'.$X.NL);

        foreach my $k (keys %common_info) {
          my $v = $common_info{$k};
          if (!defined($v)) { $v = '<undef>'; }
          print(STDERR '     '.$K.'- '.$Y.$k.$K.' = '.format_chunk($v, 120).$X.NL);
        }
      }

      my @arg_list = ();
      if (defined($argument_list)) {
        if ($DEBUG) {
          print(STDERR '     '.$Y.'argument_list'.$K.' = '.format_chunk($argument_list).$X.NL);
        }

        while ($argument_list =~ /$function_decl_argument_list_item_re/oamsgcx) {
          # type_attributes type_specifier arg_name default_arg_value variadic_arg void_arg

          my %arg_decl = ();
          foreach my $k (keys %+) {
            my $v = remove_leading_trailing_space($+{$k});
            if (is_filled($v)) { $arg_decl{$k} = $v; }
          }

          push @arg_list, { %arg_decl };
        }
      }

      if ($DEBUG) {
        print(STDERR '     '.$Y.'argument_list for '.$common_info{function_name}.' has '.(scalar(@arg_list) // 'undef').' function arguments'.NL);
      }

      $common_info{argument_count} = scalar(@arg_list);
      $common_info{arguments} = \@arg_list;
      $common_info{funcid} = $funcid++;
      push @functions, { %common_info };
    } elsif (defined($access_spec)) {
      $current_access_spec = $access_spec;
      if ($DEBUG) { print(STDERR $C.'access_spec_chunk:'.$B.' access specifier changed to '.$G.$current_access_spec.$X.NL); }
    } elsif (defined($enum_list)) {
      if ($DEBUG) { print(STDERR '  '.$U.$C.'enum_list:'.$UX.' '.format_chunk($enum_list, 120).$X.NL); }
      push @enums, { %common_info };
    } elsif (defined($typedef_decl_list)) {
      if ($DEBUG) { print(STDERR '  '.$U.$C.'typedef_decl_list:'.$UX.' '.format_chunk($typedef_decl_list, 120).$X.NL); }

      while ($typedef_decl_list =~ /$typedef_decl_re/oamsgcx) {
        my %typedef_info = ();

        foreach my $k (keys %common_info) { $typedef_info{$k} = $common_info{$k}; }

        foreach my $k (keys %+) {
          my $v = $+{$k};
          if (is_filled($v)) { 
            $typedef_info{$k} = $v;
          }
        }
        push @typedefs, { %typedef_info };
      }
    } else {
      print(STDERR "Unknown chunk type within struct $structname @ pos $startpos: ".format_chunk($block, 120));
      foreach my $k (keys %common_info) {
        my $v = $common_info{$k};
        if (!defined($v)) { $v = '<undef>'; }
        print(STDERR '     '.$K.dot_in_circle.' '.$Y.$k.$K.' = '.format_chunk($v, 120).$X.NL);
      }
      die();
    }
    $startpos = pos($block);

    $memberid++;
  }

  $ending_pos_in_block = pos($block);
  if ($DEBUG) { print(STDERR '  '.$B.'ending_pos_in_block = '.$ending_pos_in_block.' vs block length '.$blocklen.$X.NL); }
  
  if (!finished($block)) {
    warn_no_stack_trace('Unable to parse entire definition of '.$G.$struct_class_union.' '.$structname.$R.':');
    print(STDERR $K.'Parsed '.$G.pos($block).$K.' out of '.$G.length($block).$K.' characters; accepted vs rejected parts:'.$X.NL.
            $G.' '.checkmark.' '.$X.format_chunk($block, -120, 1, $G, $C).NL.
              $R.' '.x_symbol.' '.$X.format_chunk($block, -120, 1, $R, $M).NL);
    foreach $k (keys %+) {
      print(STDERR '  key '.$k.' => value '.format_quoted($+{$k}).NL);
    }
    die('Failed to parse input source code');
  }

  my $prev_word_index = -1;

  for (my $i = 0; $i < scalar(@fields); $i++) {
    my $f = \%{$fields[$i]};
    my $field_name = $f->{field_name};
    $word_index = $f->{word_index};
    if ($f->{is_bitfield}) {
      $fields[$i]->{first_bitfield_in_word} = ($word_index != $prev_word_index) ? 1 : 0;
      my $next_word_index = ($i < (scalar(@fields)-1)) ? $fields[$i+1]->{word_index} : ($word_index+1);
      if ($word_index != $next_word_index) { $fields[$i]->{last_bitfield_in_word} = 1; }
    }
    $prev_word_index = $word_index;
  }

  if ($DEBUG && 0) {
    print(STDERR $K.('-' x 120).$X.NL);
    print(STDERR $Y.$U.'$struct_class_union $structname'.$UX.$K.':'.$X.NL.NL);

    print(STDERR $C.$U.'fields:'.$X.NL);
    print_recursively(0, [@fields]);
    print(STDERR NL);

    print(STDERR $C.$U.'functions:'.$X.NL);
    print_recursively(0, [@functions]);
    print(STDERR NL);

    print(STDERR $C.$U.'typedefs:'.$X.NL);
    print_recursively(0, [@typedefs]);
    print(STDERR NL);

    print(STDERR $C.$U.'enums:'.$X.NL);
    print_recursively(0, [@enums]);
    print(STDERR NL);
  }

  return (\@fields, \@functions, \@typedefs, \@enums, \@nested_structs);
}

sub print_parsed_struct_fields($$+) {
  my ($struct_union_class, $structname, $fields) = @_;

  $raw_data_type_word_index = 0;
  $count = scalar(@{$fields});
  print(STDERR $Y.'Fields in '.$U.$M.'$struct_union_class '.$C.$structname.': '.$B.'('.$count.' fields)'.$X.NL);

  printf(STDERR $B.$U.'fid  @   pos  #b  bN : b0  word  flags      ptrf  datatype                       name                    '.$X.NL);

  foreach my $f (@{$fields}) {
    foreach my $k (@all_capture_group_names) { $$k = ''; }
    $startbit = 0; $endbit = 0; $bitwidth = 0;

    my %fieldinfo = %{$f};

    $fieldid = 0; $startpos = 0;

    foreach my $k (sort keys %fieldinfo) {
      my $v = $fieldinfo{$k};
      $$k = $v;

      if ($DEBUG && 0) {
        my $vstr = $v // $R."<undef>".$X."";
        print(STDERR '     '.$K.'- '.$Y.$k.$K.' = '.format_chunk($vstr, 120, 1).$K.NL);
      }
    }

    my $datatype_info =
      ($word_index == $raw_data_type_word_index) ? $R." $type_specifier (raw)" :
        ($type_ptr_or_ref ne '') ? $C." $type_specifier (ptr)" : $Y." $type_specifier";

    if (defined($type_attributes)) {
      $type_attributes_abbrev =
        (($type_attributes =~ /\bconstexpr\b/) ? 'C ' : '  ') .
        (($type_attributes =~ /\bconst\b/) ?     'c ' : '  ') .
        (($type_attributes =~ /\bstatic\b/) ?    's ' : '  ') .
        (($type_attributes =~ /\bvolatile\b/) ?  'v ' : '  ') .
        (($type_attributes =~ /\bmutable\b/) ?   'm ' : '  ');
    }

    printf(STDERR $X.'  '.$B.'%2d  @ %4d'.$X.'  %2d  %2d : %2d  %4d  '.$M.'%-10s '.$R.'%4s  '.$Y.'%-30s '.$G.'%-40s '.NL,
           $fieldid, $startpos, $bitwidth, $endbit, $startbit, $word_index, $type_attributes_abbrev,
           (($is_bitfield) 
            ? ('b '.($first_bitfield_in_word ? '{' : ' ').($last_bitfield_in_word ? '}' : ' ')) 
            : $type_ptr_or_ref), 
           $type_specifier, ($is_padding ? ($K.'<padding>'.$G) : $field_name));
  }

  print(STDERR $Y.'Fields in '.$M.$struct_union_class.' '.$C.$structname.$X.' '.$K.'{'.$X.NL);
  foreach my $f (@{$fields}) {
    foreach my $k (@all_capture_group_names) { $$k = ''; }
    $startbit = 0; $endbit = 0; $bitwidth = 0;

    foreach my $k (keys %{$f}) { $$k = $f->{$k}; }

    print(STDERR '  '.$C.$field_name.$X.$K.' = {'.NL);
    foreach my $k (keys %{$f}) {
      my $v = $f->{$k};
      print(STDERR '    '.$Y.$k.$K.' = '.format_chunk($v, 120, 1).$K.';'.$X.NL);
    }
    print(STDERR '  '.$K.'};'.$X.NL.NL);
  }
  print(STDERR $K.'};'.$X.NL);
}

sub print_parsed_struct_function($$+) {
  my ($struct_union_class, $structname, $funcinfo) = @_;

  foreach my $k (@all_capture_group_names) { $$k = ''; }
  foreach my $k (keys %{$funcinfo}) { my $v = $funcinfo->{$k}; $$k = $v; }

  print(STDERR '  '.$C.$function_name.$X.$K.' = {'.NL);
  foreach my $k (sort keys %{$funcinfo}) {
    my $v = $funcinfo->{$k};
    print(STDERR '    '.$Y.$k.$K.' = ');

    if ($k eq 'arguments') {
      my $count = scalar(@{$v});
      print(STDERR $C.$count.' arguments'.$K.' = {'.$X.NL);
      for (my $i = 0; $i < $count; $i++) {
        my %arg = %{$v->[$i]};
        print(STDERR '      '.$K.'['.$M.'arg #'.$i.$K.'] = '.$X.NL);
        foreach my $argk (keys %arg) {
          $argdata = $arg{$argk};
          print(STDERR "        ".$K.$Y.$argk.$K.' = ['.$G.$argdata.$K.']'.$X.';'.NL);
        }
        print(STDERR '      '.$K.'}'.$X.NL);
      }
      print(STDERR '    '.$K.'}'.$X.NL);
    } else {
      print(STDERR format_chunk($v, 120, 1).$K.';'.$X.NL);
    }
  }

  print(STDERR '    '.$R.$U.'Reconstructed:'.$X.NL);
  print(STDERR '    '.$G.reconstruct_member_function($struct_union_class, $structname, $funcinfo).$X.NL);

  print(STDERR "  ".$K."};".$X.NL.NL);
}

sub print_parsed_struct_functions($$+) {
  my ($struct_union_class, $structname, $functions) = @_;


  print(STDERR $Y.'Functions in '.$M.$struct_union_class.' '.$C.$structname.$X.' '.$K.'{'.NL);
  foreach my $f (@{$functions}) {
    print_parsed_struct_function($struct_union_class, $structname, $f);
  }
  print(STDERR $K."};".$X.NL);
}

sub reconstruct_member_function($$+) {
  my ($struct_union_class, $structname, $funcinfo) = @_;

  foreach my $k (@all_capture_group_names) { $$k = ''; }
  foreach my $k (keys %{$funcinfo}) { my $v = $funcinfo->{$k}; $$k = $v; }

  my $out = '';

  if (defined($function_template_spec)) { $out .= $function_template_spec.' '; }
  if (defined($function_attributes)) { $out .= $function_attributes.' '; }
  if (defined($return_type)) { $out .= $return_type.' '; }
  $out .= $function_name.' (';

  my $args = $funcinfo->{arguments};
  my $argcount = scalar(@{$args});
  for (my $i = 0; $i < $argcount; $i++) {
    my $arg = $args->[$i];
    $out .= ', ' if ($i > 0);
    $out .=
      ($arg->{type_attributes} // '') . ' ' .
      ($arg->{type_specifier} // '') . ' ' .
      ($arg->{arg_name} // '') . ($arg->{variadic_arg} // '') . ' ';
    if (exists($arg->{default_arg_value})) { $out .= ' = ' . $arg->{default_arg_value}; }
  }
  $out .= ' ) ' . ($trailing_function_attributes // '');

  $out .= ' : ' . $constructor_initializer_list if (is_filled($constructor_initializer_list));
  $out .= ' = ' . $default_or_delete_or_purevirt_suffix if (is_filled($default_or_delete_or_purevirt_suffix));

  if (defined($function_body)) {
    $out .= '{ ' . $function_body . ' } ';
  } else {
    $out .= ' ; ';
  }
  $out .= NL;

  return $out;
}

sub reconstruct_member_functions($$+) {
  my ($struct_union_class, $structname, $functions) = @_;


  foreach my $f (@{$functions}) {
    reconstruct_member_function($struct_union_class, $structname, $f);
  }
}

sub print_parsed_struct_typedefs($$+) {
  my ($struct_union_class, $structname, $typedefs) = @_;

  $raw_data_type_word_index = 0;

  print(STDERR $Y.'Typedefs in '.$M.'$struct_union_class '.$C.$structname.$X.' '.$K.'{'.NL);
  foreach my $t (@{$typedefs}) {
    foreach my $k (@all_capture_group_names) { $$k = ''; }
    $startbit = 0; $endbit = 0; $bitwidth = 0;

    my $typedef_new_type_name = $typedefinfo{typedef_new_type_name};
    foreach my $k (keys %{$t}) {
      my $v = $t->{$k};
      $$k = $v;
    }

    print(STDERR "  ".$C.$typedef_new_type_name.$K.' = {'.NL);
    foreach my $k (sort keys %{$t}) {
      my $v = $t->{$k};
      print(STDERR '    '.$Y.$k.$K.' = '.format_chunk($v, 120, 1).$K.";".$X.NL);
    }
    print(STDERR "  ".$K."};".$X.NL.NL);
  }
  print(STDERR $K."};".$X.NL);
}

sub print_parsed_struct_enums($$+) {
  my ($struct_union_class, $structname, $enums) = @_;

  $raw_data_type_word_index = 0;

  print(STDERR $Y.'Enums in '.$M.$struct_union_class.' '.$C.$structname.$X.' '.$K.'{'.NL);
  foreach my $e (@{$enums}) {
    foreach my $k (@all_capture_group_names) { $$k = ''; }
    $startbit = 0; $endbit = 0; $bitwidth = 0;

    foreach my $k (keys %{$e}) {
      my $v = $e->{$k};
      $$k = $v;
    }

    if (!length($enum_name)) { $enum_name = $K.'<anonymous>'.$X; }
    print(STDERR '  '.$C.$enum_name.$X.$K.' = {'.NL);
    foreach my $k (sort keys %{$e}) {
      my $v = $e->{$k};
      print(STDERR '    '.$Y.$k.$K.' = '.format_chunk($v, 120, 1).$K.";".$X.NL);
    }
    print(STDERR "  ".$K.'};'.$X.NL.NL);
  }
  print(STDERR $K.'};'.$X.NL);
}

1;
