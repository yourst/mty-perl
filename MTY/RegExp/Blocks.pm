#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::RegExp::Blocks
#
# Regular Expression Tools
#
# Copyright 2002 - 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::RegExp::Blocks;

use integer; use warnings; use Exporter qw(import);

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($angle_brackets_re $braces_re
     $comma_delimited_list_item_with_parenthesized_sublists_re
     $comma_delimited_with_nested_parens_braces_brackets_quotes_re
     $inside_angle_brackets_re $inside_braces_re $inside_parens_re
     $inside_square_brackets_re $key_equals_or_colon_value_comma_re
     $nested_parens_braces_brackets_quoted_re $parens_re $square_brackets_re);

use MTY::RegExp::Define;
use MTY::RegExp::Strings;

our $parens_re = compile_regexp(generate_balanced_char_pair_re('(', ')'),
  'parens', 'Balanced parentheses (...) with optional nesting',
  \('1' => 'entire matched block including balanced parentheses'));

our $inside_parens_re = compile_regexp(
  generate_inside_of_balanced_char_pair_re('(', ')'),
  'inside_of_parens', 
  'Inside of balanced parentheses (...) with optional nested parentheses '.
  'while properly handling (i.e. ignoring) any quoted strings or characters '.
  'which contain (non-syntactic) literal parentheses');

our $braces_re = compile_regexp(generate_balanced_char_pair_re('{', '}'),
  'braces', 'Balanced braces {...} with optional nesting',
  \('1' => 'entire matched block including balanced braces'));

our $inside_braces_re = compile_regexp(
  generate_inside_of_balanced_char_pair_re('{', '}'),
 'inside_of_braces', 
  'Inside of balanced braces {...} with optional nested braces while properly '.
  'handling (i.e. ignoring) any quoted strings or characters which contain '.
  '(non-syntactic) literal braces');

our $square_brackets_re = compile_regexp(generate_balanced_char_pair_re('[', ']'),
  'square_brackets', 'Balanced square brackets [...] with optional nesting',
  \('1' => 'entire matched block including balanced square brackets'));

our $inside_square_brackets_re = compile_regexp(
  generate_inside_of_balanced_char_pair_re('[', ']'),
  'inside_of_square_brackets',
  'Inside of balanced square brackets [...] with optional nested square '.
  'brackets while properly handling (i.e. ignoring) any quoted strings or '.
  'characters which contain (non-syntactic) literal square brackets');

our $angle_brackets_re = compile_regexp(generate_balanced_char_pair_re('<', '>'),
  'angle_brackets', 'Balanced angle brackets <...> with optional nesting',
   \('1' => 'entire matched block including balanced angle brackets'));

our $inside_angle_brackets_re = compile_regexp(
  generate_inside_of_balanced_char_pair_re('<', '>'),
  'inside_of_angle_brackets',
  'Inside of balanced angle brackets <...> with optional nested angle '.
  'brackets while properly handling (i.e. ignoring) any quoted strings or '.
  'characters which contain (non-syntactic) literal angle brackets, and '.
  'also ignoring relevant operators (<, >, <=, >=, <<, >>, <<=, >>=)');

our $nested_parens_braces_brackets_quoted_re = compile_regexp(
  qr{(?>
  (
    (?> \{ (?> (?> [^\{\}]++) | (?-1))*+ \}) |
    (?> \[ (?> (?> [^\[\]]++) | (?-1))*+ \]) |
    (?> \( (?> (?> [^\(\)]++) | (?-1))*+ \)) |
    " (?> (?> [^\"\\] | \\ .){0,4096}+ ") |
    ' (?> (?> [^\'\\] | \\ .){0,4096}+ ')
  ))}oamsx, 'nested_parens_braces_brackets_quoted');

our $comma_delimited_with_nested_parens_braces_brackets_quotes_re = compile_regexp(
  qr{(?> \s*+)
      ((?> 
        [^\,\(\)\{\}\[\]\'\"] | 
        $nested_parens_braces_brackets_quoted_re
      )++)
      (?> \,|\Z)
     }oamsx, 'comma_delimited_with_nested_parens_braces_brackets_quotes',
  'Element of a comma delimited list, optionally including quoted strings
   or sub-blocks delimited by properly balanced parentheses, braces or square 
   brackets. These sub-blocks or strings may contain nested commas or any of
   the aforementioned balanced delimiters. Leading whitespace is automatically
   removed, but trailing whitespace before the comma is retained.');

#
# One argument in a comma delimited list of arguments,
# optionally including properly balanced nested parentheses,
# each set of which may optionally contain internal commas
# which will not disrupt the parsing of the outermost list:
#
our $comma_delimited_list_item_with_parenthesized_sublists_re = compile_regexp(
  qr{\G
    ( (?> [^\(\)\,] | $parens_re)++)
    (?: , | \Z)
  }oamsx,
  'comma_delimited_list_item_with_parenthesized_sublists', 
  'One argument in a comma delimited list of arguments, optionally including '.
  'properly balanced nested parentheses, each set of which may optionally '.
  'contain internal commas which will not disrupt the parsing of the '.
  'outermost list. Also ignores parentheses and commas within quotes.',
   \('1' => 'one list item, without trailing comma (if present)'));

our $key_equals_or_colon_value_comma_re = compile_regexp(
  qr{\s*+ ([^\=\:\,]++) \s*+ 
     (?> 
       [\=\:] \s*+ 
       (?| 
         (?> $quoted_string_re) | 
         (?> ([^\,]++))
       )? \s*+
     )?
     ,?
   }oamsx, 'key_equals_or_colon_value_comma',
   'Key and value pair in the form:  key=value  or  key:value '.
   '(with optional padding spaces around each of these tokens), '.
   'and terminated by either a comma (,) for a list, or the end '.
   'of the input string');

