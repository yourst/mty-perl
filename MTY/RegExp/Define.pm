#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::RegExp::Define
#
# Regular Expression Common Definition Functions
#
# Copyright 2002 - 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::RegExp::Define;

use integer; use warnings; use Exporter qw(import);
use MTY::Common::Common;

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($always_fail_re %compiled_regexp_capture_groups
     %compiled_regexp_descriptions %compiled_regexps @compiled_regexp_names
     ENHANCED_REGEXP_DEFAULTS RE_DEF_BACKTICK_LITERALS RE_DEF_GROUPS_ATOMIC
     RE_DEF_GROUPS_NON_CAP RE_DEF_QUANT_POSSESS RE_DEF_UNDERSCORE_IS_SPACE
     compile_regexp compile_regexp_ext compile_regexp_list_of_alternatives
     generate_balanced_char_pair_re generate_inside_of_balanced_char_pair_re
     generate_regexp_to_match_any_string_in_list make_regexp_non_capturing
     regexps_declared_in_package);

#
# Pre-compile common yet complicated regexps:
#
our %compiled_regexps = ();
our %compiled_regexp_descriptions = ();
our %compiled_regexp_capture_groups = ();
our @compiled_regexp_names;

my $compiled_regexp_count = 0;

sub compile_regexp($;$$+) {
  my ($regexp_ref, $name, $description, $capture_groups) = @_;

  $name = $name // ('regexp'.$compiled_regexp_count);
  $compiled_regexps{$name} = $regexp_ref;
  push @compiled_regexp_names,$name;
  $compiled_regexp_descriptions{$name} = $description // '';
  $compiled_regexp_capture_groups{$name} = $capture_groups if (defined($capture_groups));
  $compiled_regexp_count++;
  return ${$regexp_ref};
}

#
# Enhancements and simplifications to Perl regexp syntax
# (many inspired by Perl 6's improvements and proposals):
#
# `...`        => \Q...\E    # quoted literal without clutter of \Q and \E
# ( ... )      => (?: ... )  # groups are non-capturing by default
# (?* ...)     => (...)      # (to override non-cap default): automatically numbered capture group
#
# +*, **, ?*   => =, *, ?    # greedy instead of possessive quantifiers
# _            => \s++       # one or more whitespace characters
# _*           => \s*+       # zero or more whitespace characters
#
# Optional extensions:
# (?+ ...)     => (?{...})   # append to capture group
#
# 
#
# Notes:
#
# - (...) groups are non-capturing by default; (?*...) captures into $1/$2/$3, ...
#
# - All quantifiers ('+', '*', '?' and {min,max}) are possessive by default,
#   to make it easier to define deterministic non-backtracking regexps.
#

# my $regexp_ext_syntax_re = 
#   qr{(?|
#       (?> \` ((?: [^\`] | \\ \`)*+) \` ) |  # `...`        => \Q...\E    # quoted literal without clutter of \Q and \E
#       (?> \( \* ($inside_parens_re) \) ) |  # ( ... )      => (?: ... )  # groups are non-capturing by default
#       (?> \( ($inside_parens_re) \) ) |     # (?* ...)     => (...)     # automatically numbered capture group
#       (?> (?<! \\) ([\_\~]) )                # _  or  ~     => \s++  or  \s*+   # (one or more, zero or more) whitespace characters, respectively
#     )
#   }oamsx;

my $regexp_ext_syntax_backtick_literals_re = 
   qr{(?> \` ((?: [^\`] | \\ \`)*+) \` )}oamsx;  # `...`        => \Q...\E    # quoted literal without clutter of \Q and \E

my $regexp_ext_syntax_groups_non_cap = 
  qr{(?> \( (?! [\?\*]))}oamsx;

my $regexp_ext_syntax_groups_cap_override =
  qr{(?> \( \? \*)}oamsx;

my $regexp_ext_syntax_groups_atomic =
  qr{(?> \( \? \:)}oamsx;

#my $regexp_ext_syntax_groups_atomic =
#  qr{(?> \( \? \:)}oamsx;

#       (?> \( \* ($inside_parens_re) \) ) |  # ( ... )      => (?: ... )  # groups are non-capturing by default
#       (?> \( ($inside_parens_re) \) ) |     # (?* ...)     => (...)     # automatically numbered capture group
#       (?> (?<! \\) ([\_\~]) )                # _  or  ~     => \s++  or  \s*+   # (one or more, zero or more) whitespace characters, respectively
#     )
#   }oamsx;

use constant enumbits (
  'RE_DEF_BACKTICK_LITERALS',   # `...` => \Q...\E
  'RE_DEF_UNDERSCORE_IS_SPACE', # _ => \s++, _* => \s*+
  'RE_DEF_GROUPS_NON_CAP',      # (...) => (?: ...)
  'RE_DEF_GROUPS_ATOMIC',       # (...) => (?> ...)
  'RE_DEF_QUANT_POSSESS',       # * + ? => *+ ++ ?+
);

use constant {
  ENHANCED_REGEXP_DEFAULTS => 
    RE_DEF_BACKTICK_LITERALS | RE_DEF_UNDERSCORE_IS_SPACE | 
    RE_DEF_GROUPS_NON_CAP | RE_DEF_GROUPS_ATOMIC | 
    RE_DEF_QUANT_POSSESS
};

sub compile_regexp_ext($;$$$) {
  my ($regexp, $name, $description, $flags) = @_;
  $name //= ('regexp'.$compiled_regexp_count);

  #$regexp =~ s/$regexp_backticks_to_Q_E_pair_re/quotemeta($1)/oamsxge;
  #$regexp =~ s/$regexp_braces_to_paren_q_c_re/(?:$1)/oamsxg;
  #$regexp =~ s/$regexp_lt_num_a_b_gt_to_braces_re/{$1}/oamsxg;

  $compiled_regexps{$name} = \$regexp;
  $compiled_regexp_descriptions{$name} = $description // '';
  $compiled_regexp_count++;
  return $regexp;
}

# For more on these functions, see: https://metacpan.org/pod/Regexp::Common
# (Note: as of Perl 5.012's recursion extensions, Regexp::Common is no longer 
# required, since we can do balanced matching of ()/{}/[]/<> natively now).

# For more on these functions, see: https://metacpan.org/pod/Text::Balanced
# This may also be useful in the future (but not in our current version):
#use Text::Balanced qw (extract_delimited extract_bracketed extract_quotelike extract_codeblock extract_variable extract_tagged extract_multiple gen_delimited_pat gen_extract_tagged);

sub generate_balanced_char_pair_re($$) {
  my $left = '\\'.$_[0];
  my $right = '\\'.$_[1];

  return (qr/
  (?>
    ($left                     # Start of block marker '(' must be here so recursion will find it
      (?>
        (?> [^$left$right]++) |    # anything other than (...), or:
        (?-1)               # recurse to containing (i.e. top level) capture group
      )*+      
    $right)                     # End of block marker ')'
  )/amsx);  
}

sub generate_inside_of_balanced_char_pair_re($$) {
  my $left = '\\'.$_[0];
  my $right = '\\'.$_[1];

  return (qr/
  (?> 
    [^$left$right] | 
    (
      $left                      # Start of block marker '(' must be here so recursion will find it
      (?>
        (?> [^$left$right]++) | # anything other than (...), or:
        (?-1)                   # recurse to containing (i.e. top level) capture group
      )*+      
      $right
    )                     # End of block marker ')' 
  )*+
  /amsx);  
}

#
# Change any capture groups (named or numbered) in the specified regexp
# into non-capturing structural groups, which may allow faster matching.
# This may be useful for providing both a capturing version of a regexp 
# and an equivalent matching-only version without rewriting the regexp.
#
my $regexp_cap_group_start_re = qr{
  (?<! \\) \(
  (?>
    (?: \? ['<] \w++ ['>]) | # named group (?'name') or (?<name>)
    (?! [\?\*]) # numbered group, not another group type nor a control clause
  )}oamsx;

sub make_regexp_non_capturing($) {
  # my ($re, $mods) = (is_regexp $_[0]) ? regexp_pattern($_[0]) : ($_[0], '');
  $re =~ s{$regexp_cap_group_start_re}{(?>}oamsxg;
  return qr{$re};
}

our $always_fail_re = compile_regexp(qr{(?!)}oax, 'always_fail',
  'Regular expression which never matches anything and always fails '.
  '(this may seem useless, but it can be used as a placeholder when '.
  'user specified parameters only known at runtime prevent all possible '.
  'matches, yet some regexp is still required in cases where the code '.
  'cannot easily just skip attempting to match the regexp.');

sub generate_regexp_to_match_any_string_in_list(+) {
  my ($listref) = @_;
  if (!@$listref) { return $always_fail_re; }
  my $re = join('|', map { quotemeta($_) } sort_by_descending_length_then_alphabetical($listref));
  return $re;
}

sub compile_regexp_list_of_alternatives(+;$$$$+) {
  my ($regexp_list, $prefix, $toplevel_label, $name, $description, $capture_groups) = @_;

  $name //= ('regexp'.$compiled_regexp_count);
  $prefix //= '';

  my $topre = $prefix.
    (defined($toplevel_label) 
       ? ((length($toplevel_label) == 0) 
            ? '('       # (numbered group $1)
            : ('(?\''.$toplevel_label.'\''))
       : '(?:');  # non-capturing group

  while (my ($i, $re) = each @$regexp_list) {
    $topre .= '|' if ($i > 0);
    # set $REGMARK = $i if alternative $i was captured
    $topre .= '(?>'.$re.'(*:'.$i.'))';
  }

  $topre .= ')';
  return compile_regexp(\$topre, $name, $description, $capture_groups);
}

sub regexps_declared_in_package(;$) {
  my ($package) = @_;
  ($package) //= caller;
  my $stash = $package.'::';
  my @regexps = grep { $_ =~ /_re$/oax } keys %{$stash};
  return @regexps;
}

1;

