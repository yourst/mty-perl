#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::RegExp::Define
#
# Regular Expression Common Definition Functions
#
# Copyright 2002 - 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::RegExp::Define;

use integer; use warnings; use Exporter qw(import);
#pragma end_of_includes

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(compile_regexp $always_fail_re %compiled_regexps __escape_metachars
     @compiled_regexp_names make_regexp_non_capturing
     generate_same_char_pair_re %compiled_regexp_descriptions
     generate_balanced_char_pair_re %compiled_regexp_capture_groups
     __escape_metachars_if_unescaped generate_inside_same_char_pair_re
     generate_inside_of_balanced_char_pair_re);

#
# Pre-compile common yet complicated regexps:
#
our %compiled_regexps = ();
our %compiled_regexp_descriptions = ();
our %compiled_regexp_capture_groups = ();
our @compiled_regexp_names;

my $compiled_regexp_count = 0;

sub __escape_metachars { map { quotemeta } @_; }
sub __escape_metachars_if_unescaped { map { (ord == 92) ? $_ : quotemeta } @_; }

sub compile_regexp($;$$+) {
  my ($regexp_ref, $name, $description, $capture_groups) = @_;

  $name = $name // ('regexp'.$compiled_regexp_count);
  $compiled_regexps{$name} = $regexp_ref;
  push @compiled_regexp_names,$name;
  $compiled_regexp_descriptions{$name} = $description // '';
  $compiled_regexp_capture_groups{$name} = $capture_groups if (defined($capture_groups));
  $compiled_regexp_count++;
  return ${$regexp_ref};
}

sub generate_same_char_pair_re($) {
  my ($c) = &__escape_metachars_if_unescaped;

  return qr{(?> $c ((?> [^$c\\]++ | \\ .)*+) $c)}oamsx;
}

sub generate_inside_same_char_pair_re($) {
  my ($c) = &__escape_metachars_if_unescaped;

  return qr{(?> (?> [^$c\\]++ | \\ .)*+)}oamsx;
}

sub generate_balanced_char_pair_re($$) {
  my ($left, $right) = &__escape_metachars_if_unescaped;

  return (qr{
  (?>
    ($left                     # Start of block marker '(' must be here so recursion will find it
      (?>
        (?> [^$left$right]++) |    # anything other than (...), or:
        (?-1)               # recurse to containing (i.e. top level) capture group
      )*+      
      $right)                     # End of block marker ')'
  ) 
  }amsx);  
}

sub generate_inside_of_balanced_char_pair_re($$) {
  my ($left, $right) = &__escape_metachars_if_unescaped;

  my $nested = generate_balanced_char_pair_re($left, $right);
  return (qr{(?> $nested | [^$right])*+}amsx);  
}

#
# Change any capture groups (named or numbered) in the specified regexp
# into non-capturing structural groups, which may allow faster matching.
# This may be useful for providing both a capturing version of a regexp 
# and an equivalent matching-only version without rewriting the regexp.
#
my $regexp_cap_group_start_re = qr{
  (?<! \\) \(
  (?>
    (?: \? ['<] \w++ ['>]) | # named group (?'name') or (?<name>)
    (?! [\?\*]) # numbered group, not another group type nor a control clause
  )}oamsx;

sub make_regexp_non_capturing($) {
  # my ($re, $mods) = (is_regexp $_[0]) ? regexp_pattern($_[0]) : ($_[0], '');
  $re =~ s{$regexp_cap_group_start_re}{(?:}oamsxg;
  return qr{$re};
}

our $always_fail_re = compile_regexp(qr{(?!)}oax, 'always_fail',
  'Regular expression which never matches anything and always fails '.
  '(this may seem useless, but it can be used as a placeholder when '.
  'user specified parameters only known at runtime prevent all possible '.
  'matches, yet some regexp is still required in cases where the code '.
  'cannot easily just skip attempting to match the regexp.');

1;

__END__


#
# Enhancements and simplifications to Perl regexp syntax
# (many inspired by Perl 6's improvements and proposals):
#
# `...`        => \Q...\E    # quoted literal without clutter of \Q and \E
# ( ... )      => (?: ... )  # groups are non-capturing by default
# (?* ...)     => (...)      # (to override non-cap default): automatically numbered capture group
#
# +*, **, ?*   => =, *, ?    # greedy instead of possessive quantifiers
# _            => \s++       # one or more whitespace characters
# _*           => \s*+       # zero or more whitespace characters
#
# Optional extensions:
# (?+ ...)     => (?{...})   # append to capture group
#
# 
#
# Notes:
#
# - (...) groups are non-capturing by default; (?*...) captures into $1/$2/$3, ...
#
# - All quantifiers ('+', '*', '?' and {min,max}) are possessive by default,
#   to make it easier to define deterministic non-backtracking regexps.
#

# my $regexp_ext_syntax_re = 
#   qr{(?|
#       (?> \` ((?: [^\`] | \\ \`)*+) \` ) |  # `...`        => \Q...\E    # quoted literal without clutter of \Q and \E
#       (?> \( \* ($inside_parens_re) \) ) |  # ( ... )      => (?: ... )  # groups are non-capturing by default
#       (?> \( ($inside_parens_re) \) ) |     # (?* ...)     => (...)     # automatically numbered capture group
#       (?> (?<! \\) ([\_\~]) )                # _  or  ~     => \s++  or  \s*+   # (one or more, zero or more) whitespace characters, respectively
#     )
#   }oamsx;

my $regexp_ignore_ext_syntax_within_re =
  qr{(?>
       (?> 
         (?> $regexp_comment_re) |
         (?> $regexp_literal_string_re) | 
         (?> $regexp_bracketed_char_set_nocap_re)
       )
       \K
     )}oamsx;

my $regexp_ext_syntax_backtick_literals_re = 
   qr{(?> (?! \\) \K \` ((?: [^\`] | \\ \`)*+) \` )}oamsx;

my $regexp_ext_syntax_groups_non_cap_re = 
  qr{\K \( (?! [\?\*]))}oamsx;

my $regexp_ext_syntax_groups_cap_override_re =
  qr{\K \( \? \*)}oamsx;

my $regexp_ext_syntax_groups_atomic_re = 
  qr{\K \( \? \:)}oamsx;

my $regexp_ext_syntax_groups_non_atomic_override_re = 
  qr{(?> (?! \\) \K \( \? \%)}oamsx;

my $regexp_ext_syntax_re = 
  qr{(?>
       (?> 
         (?> $regexp_comment_re) |
         (?> $regexp_literal_string_re) | 
         (?> $regexp_bracketed_char_set_nocap_re) |
         (?> \\ .)
       )
       \K (*:IGNORE)
     ) |
     (?> \` ((?: [^\`] | \\ \`)*+) \` (*:``)) |
     (?> \(
       (?>
         (?! [\?\*] (*:NON_CAP)) |
         (?! 
     
  }oamsx;


#my $regexp_ext_syntax_groups_atomic =
#  qr{(?> \( \? \:)}oamsx;

#       (?> \( \* ($inside_parens_re) \) ) |  # ( ... )      => (?: ... )  # groups are non-capturing by default
#       (?> \( ($inside_parens_re) \) ) |     # (?* ...)     => (...)     # automatically numbered capture group
#       (?> (?<! \\) ([\_\~]) )                # _  or  ~     => \s++  or  \s*+   # (one or more, zero or more) whitespace characters, respectively
#     )
#   }oamsx;

use constant enumbits (
  RE_DEF_BACKTICK_FOR_LITERALS,          # `...` => \Q...\E
  RE_DEF_UNDERSCORE_FOR_OPTIONAL_SPACES, # _ => \s++, _* => \s*+
  RE_DEF_TILDE_FOR_REQUIRED_SPACES,      # ~ => \s*+, _+ => \s++
  RE_DEF_GROUPS_NON_CAP_BY_DEFAULT,      # (...) => (?: ...), override to cap-by-number with (?*...) => (...)
  RE_DEF_GROUPS_ATOMIC_BY_DEFAULT,       # (...) => (?> ...), override to backtrackable with (?%...) => (?:...)
  RE_DEF_POSSESSIVE_BY_DEFAULT,          # * => *+, + => ++, ? => ?+, override with ** => *, +* => +, ?* => ?
);

use constant {
  ENHANCED_REGEXP_DEFAULTS => 
    RE_DEF_BACKTICK_FOR_LITERALS | 
    RE_DEF_UNDERSCORE_FOR_OPTIONAL_SPACES | 
    RE_DEF_TILDE_FOR_REQUIRED_SPACES | 
    RE_DEF_GROUPS_NON_CAP_BY_DEFAULT | 
    RE_DEF_GROUPS_ATOMIC_BY_DEFAULT | 
    RE_DEF_POSSESSIVE_BY_DEFAULT
};

sub compile_regexp_ext($;$$$) {
  my ($regexp, $name, $description, $flags) = @_;
  $name //= ('regexp'.$compiled_regexp_count);

  #$regexp =~ s/$regexp_backticks_to_Q_E_pair_re/quotemeta($1)/oamsxge;
  #$regexp =~ s/$regexp_braces_to_paren_q_c_re/(?:$1)/oamsxg;
  #$regexp =~ s/$regexp_lt_num_a_b_gt_to_braces_re/{$1}/oamsxg;

  $compiled_regexps{$name} = \$regexp;
  $compiled_regexp_descriptions{$name} = $description // '';
  $compiled_regexp_count++;
  return $regexp;
}
