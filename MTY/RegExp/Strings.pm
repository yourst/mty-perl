#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::RegExp::Strings
#
# Regular Expression Tools
#
# Copyright 2002 - 2014 Matt T. Yourst <yourst@yourst.com>
#

package MTY::RegExp::Strings;

use integer; use warnings; use Exporter::Lite;

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($boolean_words_re $double_quoted_string_re $identifier_re
     $inside_double_quoted_re $inside_quoted_re
     $inside_single_quoted_string_nocap_re $leading_spaces_re $line_re
     $lower_case_identifier_re $null_terminated_string_re $printable_chars_re
     $quote_type_and_text_re $quoted_literal_nocap_re $quoted_nocap_re
     $quoted_re $raw_delimited_string_re $remove_leading_trailing_space_re
     $simple_quoted_re $single_quoted_character_re $single_quoted_string_re
     $split_by_char_classes_re $tab_field_re $title_case_identifier_re
     $trailing_spaces_re $unicode_and_non_ascii_chars_re
     $upper_case_identifier_re $utf8_re);

use MTY::RegExp::Define;
#pragma end_of_includes

our $line_re = compile_regexp(qr{^(\N*+)\n}oamsx, 
  'Line of text terminated by a newline');

our $tab_field_re = compile_regexp(qr{([^\t]*+)\t}oamsx, 
  'Field of text terminated by a tab');

our $null_terminated_string_re = compile_regexp(qr{([^\x00]*+)\x00}oamsx, 
  'null_terminated_string',
  'String of text terminated by a null terminator');

our $leading_spaces_re = compile_regexp(qr{^[\ \t]*+}oamsx, 'leading_spaces');
our $trailing_spaces_re = compile_regexp(qr{[\ \t]*+$}oamsx, 'trailing_spaces');

#
# Alternative regexps for removing leading and trailing whitespace:
#
#   m/\A \s* (.*?) \s* \Z/oamsxg      or:      s/^\s+ | \s+$/oamsxg
#   (sets $1)                                  (replaces original)
#
#                                     or:      s/^\s+//oamsx;
#                                              s/\s+$/oamsx/;
#                                              (even more efficient)
#
our $remove_leading_trailing_space_re = compile_regexp(
  qr{\A \s* (.*?) \s* \Z}oamsx, 
  'remove_leading_trailing_space', 
  'Remove whitespace (i.e. spaces, tabs and newlines too) '.
  'before the first non-whitespace character, and after the '.
  'last non-whitespace character',
  ['1' => 'text excluding any leading and/or trailing whitespace']);

our $quoted_nocap_re = compile_regexp(qr{
  " (?> (?> [^\"\\] | \\ .)*+ ") |
  ' (?> (?> [^\'\\] | \\ .)*+ ')
  }oamsx, 'quoted_nocap');

our $inside_quoted_re = compile_regexp(qr{
  (?|
    (?: " (?> ((?> [^\"\\] | \\ .)*+) ")) |
    (?: ' (?> ((?> [^\'\\] | \\ .)*+) ')))
  }oamsx, 'inside_quoted_re');

our $simple_quoted_re = compile_regexp(
  qr{(?> " (?> [^\"]*+ "))
     }oamsx, 'simple_quoted');

our $double_quoted_string_re = compile_regexp(
  qr{(?'char_encoding' L | u8 | u | U)? 
     (?'quote_type' \") 
     (?'string' (?> [^\"\\] | \\.)*+) \"
  }oamsx, 'double_quoted_string',
  'Match double quote delimited string ("...") with optional '.
  'embedded escaped double quote characters or literal single quotes',
  \('string' => 'text between quotes',
    'quote_type' => 'type of quotation marks: single (\') or double (")',
    'char_encoding' => '(optional) character encoding: '.
                       'L = 16 bit (wchar_t), u8 = UTF-8, u = UTF-16, '.
                       'U = UTF-32'));

our $inside_double_quoted_re = compile_regexp(
  qr{(?> [^\"\\] | \\.)*+}oamsx,
  'inside_double_quoted',
  'Match text already inside a double quoted string (not including the '.
  'enclosing quotes themselves). Properly handles escaped double quotes '.
  'by returning a literal double quote; embedded single quotes are included '.
  'just like any other character. Use "($inside_double_quoted_string)" to '.
  'actually capture the character string between the start and end quotes.');

#
# C++11 has *finally* added Perl-style string literals
# where you can choose your own starting and ending
# delimiters that don't conflict with any characters in
# the string, thus making escaped characters unnecessary:
#
# (optional L|u8|u|U prefix) R "delimiter( raw_characters )delimiter"
#                              ^^^^^^^^^^^                ^^^^^^^^^^^
#
our $raw_delimited_string_re = compile_regexp(
  qr{(?'char_encoding' L | u8 | u | U)? 
     R \" 
     (?'quote_type' [^\s\(\)\\]*+) \(
     (?'string' .*?)
     \) \g{-2} \" 
  }oamsx, 'raw_delimited_string',
  'Match C++11 style raw string bounded by user specified delimiters '.
  'of the form:     R"(???      and closing with:       ???)',
  \('string' => 'text between quotes',
    'quote_type' => 'the user defined delimiter(s) between the R" and the (',
    'char_encoding' => '(optional) character encoding: '.
                       'L = 16-bit wchar_t, u8 = UTF-8, u = UTF-16, U = UTF-32'));

our $single_quoted_string_re = compile_regexp(
  qr{(?'char_encoding' L | u8 | u | U)? 
     (?'quote_type' \') 
     (?'string' (?> [^\'\\] | \\ .)*+) \'
  }oamsx,
  'single_quoted_string',
  'Match single quote delimited (\'...\') string with optional '.
  'embedded escaped single quote characters or literal double quotes',
  \('string' => 'text between quotes',
    'quotetype' => 'type of quotation marks: single (\') or double (")',
    'char_encoding' => '(optional) character encoding: '.
                       'L = 16 bit (wchar_t), u8 = UTF-8, u = UTF-16, '.
                       'U = UTF-32'));

our $inside_single_quoted_string_nocap_re = compile_regexp(
  qr{(?> [^\'\\] | \\.)*+}oamsx,
  'inside_single_quoted_string',
  'Match text already inside a single quoted string (not including the '.
  'enclosing quotes themselves). Properly handles escaped single quotes '.
  'by returning a literal single quote; embedded double quotes are included '.
  'just like any other character. Use "($inside_double_quoted_string)" to '.
  'actually capture the character string between the start and end quotes.');

our $single_quoted_character_re = compile_regexp(
  qr{'(?'char'
        (?: \\ [\'\"\?\\0abfnrtv]) |
        (?: \\ [nxu] [0-9A-Fa-f]{2,4}) |
        [^'\\])'
    }oamsx, 'single_quoted_character',
  'Match single quote delimited (\'...\') single character '.
  'or a backslash escaped character or an octal/hex/unicode '.
  'escaped character code',
  \('string' => 'text between quotes'));

our $quoted_re = compile_regexp(
  qr{(?> (?'string_with_quotes' $double_quoted_string_re | $single_quoted_string_re | $raw_delimited_string_re))}oamsx, 
  'quoted', 'Match either a double quoted string (as in double_quoted_string_re) '.
  'or a single quoted character (as in single_quoted_character_re)',
  \('string' => 'text between double quotes',
    'char' => 'text between single quotes'));

our $quoted_literal_nocap_re = compile_regexp(
  qr{
  (?> [LUu]8?)?+
  (?>
    (?> \" (?> (?> [^\"\\] | \\.)*+ \")) |
    (?> \' (?> (?> [^\'\\] | \\.)*+ \')) |
    (?> R \" (?> 
      ([^\s\(\)\\]{0,256}+) \(
      (?> [^\)] | \) (?! \g{-1}))*+
      \) \g{-1} \"
    ))
  )}oamsx, 'quoted_literal_nocap');

our $quote_type_and_text_re = compile_regexp(
  qr{(?|
      (?> (") ((?> [^\"\\] | \\ .)*+) (")) |
      (?> (') ((?> [^\'\\] | \\ .)*+) ('))
     )}oamsx, 'quote_type_and_text');

our $identifier_re = compile_regexp(
  qr{\b [A-Za-z_] \w*+ \b}oamsx, 'identifier',
  'Identifier starting with a letter or _, optionally followed by '.
  'any number of letters, numbers, or _ symbols');

our $lower_case_identifier_re = compile_regexp(
  qr{\b [a-z_] [a-z0-9_]*+ \b}oamsx, 'lower_case_identifier',
  'Identifier with only lower case letters or digits, optionally separated '.
  'by _ symbols.');

our $upper_case_identifier_re = compile_regexp(
  qr{\b [A-Z_] [A-Z0-9_]*+ \b}oamsx, 'upper_case_identifier',
  'Identifier with only upper case letters or digits, optionally separated '.
  ' by _ symbols.');

our $title_case_identifier_re = compile_regexp(
  qr{\b [A-Z] [a-z] [A-Za-z0-9]*+ \b}oamsx, 'title_case_identifier',
  'Identifier of the form IdentifierWithOptionalNumbers123OrSequencesLikeABC');

our $unicode_and_non_ascii_chars_re = compile_regexp(
  qr{[^[:ascii:]]}oamsx, 'unicode_and_non_ascii_chars_re',
  'All characters outside the ASCII subset (the first 128 characters);'.NL.
  'matches both the ANSI extended area from 128-255 (accented letters,'.NL.
  'greek and math symbols, box drawing, etc) and more generally the '.NL.
  'entire non-ASCII Unicode space from 128 (0x80) to 65536 (0xffff).'.NL.
  'This regexp can be useful for filtering any Unicode characters from'.NL.
  'text (typically by replacing them with e.g. \'?\' symbols) before '.NL.
  'providing the data to consumers which do not support Unicode and/or UTF-8');

our $utf8_re = compile_regexp(
  qr{(?> 
        [\xD0-\xDF] [\x80-\xBF] |             # U+0080 - U+07FF:  (11 bits) 110xxxxx 10xxxxxx
        [\xE0-\xEF] [\x80-\xBF] [\x80-\x8F]   # U+0800 - U+FFFF:  (16 bits) 1110xxxx 10xxxxxx 10xxxxxx
      )}oaamsx, 'utf8_re',
  'UTF-8 byte sequence representing one 16-bit Unicode character. '.
  '(Technically UTF-8 is defined for code points up to 0x10FFFF, '.
  'but in practice there are few if any modern languages with code '.
  'points beyond the 16-bit limit of 0xFFFF, and the Perl and PCRE '.
  'regexp engines both use 16-bit characters internally (assuming '.
  'any input characters and/or regexp components actually require '.
  'the 16-bit engine instead of the much faster 8-bit engine).');

our $printable_chars_re = compile_regexp(
  qr{[[:print:]]++}oamsx, 'printable_chars');

our $split_by_char_classes_re = compile_regexp(
  qr{(?> [\x20-\x7F]+ (*:ASCII)) |
     (> [\x80-\xFF]+ (*:ASCII8BIT)) |
     (?> 
       \e [\[\]] 
       ((?: \d+ ;?)*) 
       ([A-Za-z\@\`])
       (*:ANSIESC)
     ) |
     (?> \e (*:ESC)) |
     (?> [\t\n\v\f\r] (*:TAB_NL_VT_FF_CR)) |
     (?> [\x00-\x08\x0E-\x1A\x1C-\x1F] (*:CONTROL)) |
     (?> .+ (*:UNICODE))
     }oamsx, 'split_by_char_classes');

our $boolean_words_re = compile_regexp(
  qr{
  [01] | 
  n(?:ot?)? | f(?:alse)? | o(?:ff|n) | disabled? | without | skip | e(?:xclude|nabled?) |
  y(?:es)? | t(?:rue)? | with | use
  }oax, 'boolean_words',
  'Words (in English) which are equivalent to the boolean values 0 or 1, e.g. '.
  '"0", "1", "true", "false", "yes", "no", "on", "off", "enabled", "disabled", etc. '.
  '(This regexp will match any words in the %boolean_words hash).');

1;
