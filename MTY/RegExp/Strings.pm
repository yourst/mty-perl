#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::RegExp::Strings
#
# Regular Expression Tools
#
# Copyright 2002 - 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::RegExp::Strings;

use integer; use warnings; use Exporter qw(import);

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($line_re $utf8_re $newline_re $null_byte_re $tab_field_re $identifier_re
     $boolean_words_re $inside_quoted_re $quoted_string_re $leading_spaces_re
     $newline_or_end_re $printable_chars_re $trailing_spaces_re
     $backslash_newline_re $quote_type_and_text_re $quoted_string_nocap_re
     $double_quoted_string_re $inside_double_quoted_re
     $inside_single_quoted_re $single_quoted_string_re
     $lower_case_identifier_re $split_by_char_classes_re
     $title_case_identifier_re $upper_case_identifier_re
     $null_terminated_string_re $unicode_and_non_ascii_chars_re
     $remove_leading_trailing_space_re join_backslash_newline_escaped_lines
     $line_with_optional_backslash_newlines_re);

use MTY::RegExp::Define;
#pragma end_of_includes

our $newline_re = compile_regexp(
  qr{\n}oamsx, 'newline',
  'Newline character ("\n", NL), \x0A (#10) on POSIX standard systems');

our $newline_or_end_re = compile_regexp(
  qr{(?> \n | \Z)}oamsx, 
  'newline_or_end',
  'Newline or the end of the input string (sets pos($input) = length($input)). '.
  'Useful when an input may or may not have its last line terminated by a newline.');

our $line_re = compile_regexp(
  qr{^(\N*+)\n}oamsx, 'line',
  'Line of text terminated by a newline');

our $tab_field_re = compile_regexp(
  qr{([^\t]*+)\t}oamsx, 'tab_field',
  'Field of text terminated by a tab');

our $null_byte_re = compile_regexp(
  qr{\x00}oamsx, 'null_byte',
  'Null terminator byte');

our $null_terminated_string_re = compile_regexp(
  qr{([^\x00]*+)\x00}oamsx, 'null_terminated_string',
  'String of text terminated by a null terminator');

our $leading_spaces_re = compile_regexp(
  qr{^[\ \t]*+}oamsx, 'leading_spaces');

our $trailing_spaces_re = compile_regexp(
  qr{[\ \t]*+$}oamsx, 'trailing_spaces');

#
# Alternative regexps for removing leading and trailing whitespace:
#
#   m/\A \s* (.*?) \s* \Z/oamsxg      or:      s/^\s+ | \s+$/oamsxg
#   (sets $1)                                  (replaces original)
#
#                                     or:      s/^\s+//oamsx;
#                                              s/\s+$/oamsx/;
#                                              (even more efficient)
#
our $remove_leading_trailing_space_re = compile_regexp(
  qr{\A \s* (.*?) \s* \Z}oamsx, 
  'remove_leading_trailing_space', 
  'Remove whitespace (i.e. spaces, tabs and newlines too) '.
  'before the first non-whitespace character, and after the '.
  'last non-whitespace character',
  ['1' => 'text excluding any leading and/or trailing whitespace']);

our $backslash_newline_re = compile_regexp(
  qr{(?<! \\) \\ \n}oamsx, 'backslash_newline',
  'Backslash ("\") followed by a newline character (\n), used to denote the '.
  'continuation of the current logical source line onto the next input line.'.
  'Will not match a double backslash (i.e. a literal backslash, not an escape).');

our $line_with_optional_backslash_newlines_re = compile_regexp(
  qr{((?> [^\n\\]++ | \\ .)*+) (?> \n | \Z)}oamsx,
  'line_with_optional_backslash_newlines',
  'Line of text terminated by a newline (\n) character, optionally including '.
  'a backslash followed by a newline (\\ \n) which continues the same logical '.
  'line, which this regexp captures into $1 (including any embededded \\ \n '.
  'sequences, which should be removed using '.
   '"<var> =~ s{$backslash_newline_re}{}oamsxg"');

sub join_backslash_newline_escaped_lines($) {
  return $_[0] =~ s{$backslash_newline_re}{}roamsxg;
}

our $inside_single_quoted_re = compile_regexp(
  qr{(?> [^\'\\]++ | \\ .)*+}oamsx,
  'inside_single_quoted',
  'Match text already inside a single quoted string (not including the '.
  'enclosing quotes themselves). Properly handles escaped single quotes '.
  'by returning a literal single quote; embedded double quotes are included '.
  'just like any other character. Use "($inside_single_quoted_re)" to '.
  'actually capture the character string between the start and end quotes.');

our $inside_double_quoted_re = compile_regexp(
  qr{(?> [^\"\\]++ | \\.)*+}oamsx,
  'inside_double_quoted',
  'Match text already inside a double quoted string (not including the '.
  'enclosing quotes themselves). Properly handles escaped double quotes '.
  'by returning a literal double quote; embedded single quotes are included '.
  'just like any other character. Use "($inside_double_quoted_re)" to '.
  'actually capture the character string between the start and end quotes.');

our $inside_quoted_re = compile_regexp(
  qr{
      (?> (?<= ") (?> [^\"\\]++ | \\ .)*+ (?= ")) |
      (?> (?<= ') (?> [^\'\\]++ | \\ .)*+ (?= '))
  }oamsx, 'inside_quoted', 
  'Text between a single or double quote and a corresponding closing quote. '.
  'Does not capture anything; surround usage with ($inside_quoted_re) to do this');

our $single_quoted_string_re = compile_regexp(
  qr{(?> ' ((?> [^\'\\]++ | \\ .)*+) ')}oamsx, 'single_quoted_string');

our $double_quoted_string_re = compile_regexp(
  qr{(?> " ((?> [^\"\\]++ | \\ .)*+) ")}oamsx, 'double_quoted_string');

our $quoted_string_re = compile_regexp(
  qr{(?|
      $single_quoted_string_re |
      $double_quoted_string_re
    )}oamsx, 'quoted_string',
    'Single or double quoted string');

our $quoted_string_nocap_re = compile_regexp(
  qr{
      (?> " (?> [^\"\\]++ | \\ .)*+ ") |
      (?> ' (?> [^\'\\]++ | \\ .)*+ ')
  }oamsx, 'quoted_string_nocap');

our $quote_type_and_text_re = compile_regexp(
  qr{(?|
      (?> (") ((?> [^\"\\]++ | \\ .)*+) (")) |
      (?> (') ((?> [^\'\\]++ | \\ .)*+) ('))
     )}oamsx, 'quote_type_and_text');

our $identifier_re = compile_regexp(
  qr{\b [A-Za-z_] \w*+ \b}oamsx, 'identifier',
  'Identifier starting with a letter or _, optionally followed by '.
  'any number of letters, numbers, or _ symbols');

our $lower_case_identifier_re = compile_regexp(
  qr{\b [a-z_] [a-z0-9_]*+ \b}oamsx, 'lower_case_identifier',
  'Identifier with only lower case letters or digits, optionally separated '.
  'by _ symbols.');

our $upper_case_identifier_re = compile_regexp(
  qr{\b [A-Z_] [A-Z0-9_]*+ \b}oamsx, 'upper_case_identifier',
  'Identifier with only upper case letters or digits, optionally separated '.
  ' by _ symbols.');

our $title_case_identifier_re = compile_regexp(
  qr{\b [A-Z] [a-z] [A-Za-z0-9]*+ \b}oamsx, 'title_case_identifier',
  'Identifier of the form IdentifierWithOptionalNumbers123OrSequencesLikeABC');

our $unicode_and_non_ascii_chars_re = compile_regexp(
  qr{[^[:ascii:]]}oamsx, 'unicode_and_non_ascii_chars_re',
  'All characters outside the ASCII subset (the first 128 characters); '.
  'matches both the ANSI extended area from 128-255 (accented letters, '.
  'greek and math symbols, box drawing, etc) and more generally the '.
  'entire non-ASCII Unicode space from 128 (0x80) to 65536 (0xffff). '.
  'This regexp can be useful for filtering any Unicode characters from '.
  'text (typically by replacing them with e.g. \'?\' symbols) before '.
  'providing the data to consumers which do not support Unicode and/or UTF-8');

our $utf8_re = compile_regexp(
  qr{(?> 
       (?> [\xC0-\xDF] [\x80-\xBF]) |             # U+0080 - U+07FF:  (11 bits) 110x.xxxx 10xx.xxxx
       (?> [\xE0-\xEF] [\x80-\xBF] [\x80-\xBF]) | # U+0800 - U+FFFF:  (16 bits) 1110.xxxx 10xx.xxxx 10xx.xxxx
       (?> [\xF0-\xF7] [\x80-\xBF] [\x80-\xBF] [\x80-\xBF]) | # U+10000 - U+1FFFFF:  (21 bits) 1111.0xxx 10xx.xxxx 10xx.xxxx 
       (?> [^[:ascii:]])
     )}oamsx, 'utf8_re',
  'UTF-8 byte sequence representing one 16-bit Unicode character. '.
  '(Technically UTF-8 is defined for code points up to 0x10FFFF, '.
  'but in practice there are few if any modern languages with code '.
  'points beyond the 16-bit limit of 0xFFFF, and the Perl and PCRE '.
  'regexp engines both use 16-bit characters internally (assuming '.
  'any input characters and/or regexp components actually require '.
  'the 16-bit engine instead of the much faster 8-bit engine).');

our $printable_chars_re = compile_regexp(
  qr{[[:print:]]++}oamsx, 'printable_chars');

our $split_by_char_classes_re = compile_regexp(
  qr{(?> [\x20-\x7F]+ (*:ASCII)) |
     (> [\x80-\xFF]+ (*:ASCII8BIT)) |
     (?> 
       \e [\[\]] 
       ((?: \d+ ;?)*) 
       ([A-Za-z\@\`])
       (*:ANSIESC)
     ) |
     (?> \e (*:ESC)) |
     (?> [\t\n\v\f\r] (*:TAB_NL_VT_FF_CR)) |
     (?> [\x00-\x08\x0E-\x1A\x1C-\x1F] (*:CONTROL)) |
     (?> .+ (*:UNICODE))
     }oamsx, 'split_by_char_classes');

our $boolean_words_re = compile_regexp(
  qr{
  [01\-\~\^] | 
  n(?:ot?)? | f(?:alse)? | o(?:ff|n) | disabled? | without | skip | e(?:xclude|nabled?) |
  y(?:es)? | t(?:rue)? | with | use
  }oax, 'boolean_words',
  'Words (in English) which are equivalent to the boolean values 0 or 1, e.g. '.
  '"0", "1", "-", "true", "false", "yes", "no", "on", "off", "enabled", "disabled", etc. '.
  '(This regexp will match any words in the %boolean_words hash).');

1;
