#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::RegExp::Networks
#
# Common Regular Expressions for Network Addresses, URLs, etc.
#
# Copyright 2002 - 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::RegExp::Networks;

use integer; use warnings; use Exporter qw(import);

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($url_re $ipaddr_re $macaddr_re $href_tag_re $ipaddr_with_prefix_re);

use MTY::RegExp::Define;
use MTY::RegExp::Blocks;
use MTY::RegExp::Strings;
use MTY::RegExp::Numeric;
use MTY::RegExp::FilesAndPaths;
#pragma end_of_includes

our $ipaddr_re = compile_regexp(
  qr{(?: (?: $unsigned_byte_in_decimal_re \.){3}) $unsigned_byte_in_decimal_re}oamsx,
  'ipaddr',
  'IPv4 address in dotted decimal notation with optional '.
  'netmask length (e.g. 1.2.3.4 or 1.2.3.4/16)');

our $ipaddr_with_prefix_re = compile_regexp(
  qr{(?'ip' $ipaddr_re)(?'prefix' (?: \/ \d{1,2})?)}oamsx,
  'ipaddr_with_prefix',
  'IPv4 address in dotted decimal notation with optional '.
  'CIDR notation network prefix length (e.g. 1.2.3.4/16);'.
  'captures into "ipaddr" and "prefix"');

#use Regexp::Common qw(net);
#our $ipv6addr_re = compile_regexp(
#  qr/$RE{net}{IPv6}/oamsx,
#  'ipv6addr',
#  'IPv6 address in colon delimited hexidecimal form with '.
#  'zero filled groups of digits optionally omitted');

our $macaddr_re = compile_regexp(
  qr{(?: (?: [0-9a-fA-F]{2} \:){5}) [0-9a-fA-F]{2}}oamsx,
  'macaddr',
  'Ethernet MAC address (48 bit) as six pairs of hex digits '.
  'separated by ":" characters (e.g. 1a:2b:3c:4d:5f)');

our $url_re = compile_regexp(
  qr{(?:^
     (?'protocol' \w+) :// 
     (?'server' [^/]+) 
     (?'directory' / (?: [^/]+ /)*)
     (?: (?'filename' [^\/\?\&]+))?
     (?: \? (?'arguments' .*))?
         # technically this is the following regexp,
         # but only for HTTP, so we'll just put it here
         # as a comment for optional use only if desired:
         # (?: \w+ = [^&]+ (?: $|&))*)    # i.e. var = value & ...
     $)}oamsx, 'url_re',
  'Uniform Resource Locator (URL) for HTTP, FTP, file:///, etc. '.
  'with each part parsed into its own named capture group',
  \('protocol' => 'network protocol (http, ftp, file, etc)',
    'server' => 'server host name and optional port number, '.
                'e.g. www.example.com:1234',
    'directory' => 'all directories/subdirectories in the path',
    'filename' => 'filename (e.g. xyz.html or a script like abc.cgi); '.
                  'note that the final subdirectory name may appear '.
                  'in the <filename> field if it lacks a final "/", '.
                  'since without the final slash, this regexp won\'t '.
                  'have a clue whether the name is a file or a directory.',
    'arguments' => 'if the filename is invoked as a server side script, '.
                   'a "?" will immediately follow the filename, before '.
                   'the script\'s argument list in the following form: '.           
                   'name1=value1&name2=value2 & name3 = value3 & ...'
   ));

our $href_tag_re = compile_regexp(
  qr{\<a \s++ href \s*+ = "($inside_double_quoted_re)" \s*+ \>}oamsx,
  'href_tag', 'HTML or XML tag of the form: <a href="..."> where the referenced '.
    'URL will be captured in $1.');

1;
