#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::RegExp::Numeric
#
# Regular expressions for numeric literals: integers and floating point
# in decimal, hex, octal or binary, plus UUIDs, RGB hex triplets and
# other miscellaneous representations of common numerical types
#
# Copyright 2002 - 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::RegExp::Numeric;

use integer; use warnings; use Exporter qw(import);

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($uuid_re $integer_re $hex_digit_re parse_integer $fp_literal_re
     $hex_literal_re $octal_digit_re $binary_digit_re $bool_literal_re
     $decimal_digit_re $integer_nocap_re $octal_literal_re $binary_literal_re
     $decimal_literal_re $numeric_literal_re $rgb_hex_triplet_re
     parse_rgb_hex_triplet $numeric_literal_nocap_re
     $unsigned_byte_in_decimal_re $unsigned_decimal_number_nocap_re
     $integer_sign_and_digits_with_radix_re);

use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Common::Strings;
use MTY::RegExp::Define;
use MTY::RegExp::Blocks;
#pragma end_of_includes

our $binary_digit_re = compile_regexp(qr{[0-1]}oax, 'binary_digit');
our $octal_digit_re = compile_regexp(qr{[0-7]}oax, 'octal_digit');
our $decimal_digit_re = compile_regexp(qr{[0-9]}oax, 'decimal_digit');
our $hex_digit_re = compile_regexp(qr{[0-9A-Fa-f]}oax, 'hex_digit');

our $bool_literal_re = compile_regexp(qr{\b (?: true | false) \b}oax, 'bool');

our $binary_literal_re = compile_regexp(
  qr{0[Bb] (?'binary_literal' [01']+)
     (?'int_literal_suffix' [ULul]*) \b
    }oamsx, 'binary_literal',
     'Binary literal as in C/C++, i.e. 0b11011101. '.
     'Optionally may include type suffix (U,L,UL,LL,ULL)');

our $octal_literal_re = compile_regexp(
  qr{0 (?'octal_literal' [0-7']+) 
     (?'int_literal_suffix' [ULul]*) \b
  }oamsx, 'octal_literal',
  'Octal literal as in C/C++, i.e. 07654321. '.
  'Optionally may include type suffix (U,L,UL,LL,ULL)');

our $decimal_literal_re = compile_regexp(
  qr{(?'decimal_literal' 0 | (?: [+-]? [1-9] [0-9']*)) 
     (?'int_literal_suffix' [ULul]*) \b
    }oamsx, 'decimal_literal',
    'Decimal literal as in C/C++, i.e. 12345678. '.
    'Cannot start with a leading 0 (to distinguish it from octal) '.
    'unless the entire number is only 0. '.
    'Optionally may include type suffix (U,L,UL,LL,ULL)');

our $unsigned_decimal_number_nocap_re = compile_regexp(
  qr{\A[0-9]++\Z}oamsx, 'unsigned_decimal_number_nocap');

our $hex_literal_re = compile_regexp(
  qr{0[Xx] 
     (?'hex_literal' [0-9A-Fa-f']+) 
     (?'int_literal_suffix' [ULul]*) \b
    }oax, 'hex_literal',
    'Hexadecimal literal as in C/C++, i.e. 0x123456789abcdef. '.
    'Optionally may include type suffix (U,L,UL,LL,ULL)');

our $fp_literal_re = compile_regexp(
  qr{
  (?'fp_literal'
    (?'fp_literal_sign' [+-])?
    (?'fp_literal_mantissa' (?: [0-9]* \.)? [0-9]+)
    (?: [eE] (?'fp_literal_exponent' [-+]? [0-9]+))?
  )
  (?'fp_literal_suffix' [FfLl])?
  }oax, 'fp_literal',
  'Floating point literal');

our $numeric_literal_re = compile_regexp(
  qr{
  (?:
    (?'decimal_literal' [+-]? [1-9] [0-9']*+) |
    (?:
      0 
      (?>
        (?! [0-9A-Fa-f']) |
        [Xx] (?'hex_literal' [0-9A-Fa-f']++) |
        [Bb] (?'binary_literal' [01']++) |
        (?'octal_literal' [0-7']++)
      )
    ) |
    (?'fp_literal'
      (?'fp_literal_sign' [+-])?
      (?'fp_literal_mantissa' (?: [0-9]* \.)? [0-9]+)
      (?: [eE] (?'fp_literal_exponent' [-+]? [0-9]+))?
    )
  )
  (?'numeric_literal_suffix' [UuLlFf]{0,3})
  }oax, 'literal',
  'C/C++ numeric literal: 0, decimal, hex, binary, octal '.
  'or floating point, with optional suffix (U/UL/ULL/L/LL/f/F)');

our $numeric_literal_nocap_re = compile_regexp(
  qr{
  (?>
    (?>
      [\-\+]?
      (?>
        (?> [0-9]{1,308}+ (?= [eE] [+-]? [0-9])) |
        (?> \. [0-9]{1,308}+) |
        (?> [0-9]{1,308}+ \. [0-9]{0,308}+)
      )
      (?> [eE] [-+]?+ [0-9]{1,4}+)?
    ) |
    (?> [-+]? [1-9] [0-9']{0,20}+) |
    (?> 0
      (?>
        [Xx] [0-9A-Fa-f']{1,17}+ |
        [Bb] [01']{1,65}+ |
        [0-7']{1,25}+
      )?
    )
  )
  [UuLlFf]{0,3}
  }oax, 'numeric_literal_nocap',
  'C/C++ numeric literal: 0, decimal, hex, binary, octal '.
  'or floating point, with optional suffix (U/UL/ULL/L/LL)');

our $integer_re = compile_regexp(
  qr{\G
  ([\-\+]?)
  (?|
    (?> ([1-9] [0-9']{0,40}+ (*MARK:d))) |
    (?> 0
      (?|
        [Xx] ([0-9A-Fa-f']{1,34}+ (*MARK:x)) |
        [Bb] ([01']{1,130}+ (*MARK:b)) |
        ([0-7']{1,50}+ (*MARK:o)) |
        (?<= 0 (*MARK:z))
      )
    )
  )
  }oax, 'integer',
  'Integer in decimal, hex, binary or octal format with '.
  'optional + or - and optional 0x/0b/0 radix prefix.'.
  'Captures into $1 = +/- sign, $2 = digits, and sets '.
  '$REGMARK = d|x|b|o|z for radix (decimal, hex, binary, '.
  'octal, or zero, respectively)');

our $integer_nocap_re = compile_regexp(
  qr{\G
  [\-\+]?
  (?>
    [1-9] [0-9']{0,40}+ |
    (?> 0
      (?>
        [Xx] [0-9A-Fa-f']{1,34}+ |
        [Bb] [01']{1,130}+ |
        [0-7']{1,50}+
      )?
    )
  )
  }oax, 'integer_nocap',
  'Integer in decimal, hex, binary or octal format with '.
  'optional + or - and optional 0x/0b/0 radix prefix.');

our $integer_sign_and_digits_with_radix_re = compile_regexp(
  qr{\G
  ([\-\+]?)
  (
    [1-9] [0-9']{0,40}+ (*MARK:10) |
    (?> 0 (*MARK:0)
      (?>
        [Xx] [0-9A-Fa-f']{1,34}+ (*MARK:16) |
        [Bb] [01']{1,130}+ (*MARK:2) |
        [0-7']{1,50}+ (*MARK:8)
      )?
    )
  )
  }oax, 'integer_sign_and_digits_with_radix',
  'Integer in decimal, hex, binary or octal format with '.
  'optional + or - and optional 0x/0b/0 radix prefix. '.
  'Captures into $1 = sign and $2 = radix and digits, '.
  'and sets $REGMARK = 10|16|2|8|0 for the radix (decimal, '.
  'hex, binary,octal, or zero, respectively)');

our $unsigned_byte_in_decimal_re = compile_regexp(
  qr{(?<! \d) (?: (?: 2 (?: 5[0-5] | [0-4]\d)) | 1\d\d? | [2-9]\d | \d) (?! \d)}oax,
  'unsigned_byte_in_decimal', 
  'Unsigned byte as a decimal integer, '.
  'i.e. 0, 1, 2, ..., 254, 255');

sub parse_integer($) {
  local $REGMARK = undef;
  local $REGERROR = undef;
  if (!defined($_[0])) { return undef; }
  my ($sign, $digits) = ($_[0] =~ /$integer_sign_and_digits_with_radix_re/oax);
  my $radix = $REGMARK;
  if (!is_there($digits)) { return undef; }
  my $value = 
    ($radix == 0) ? 0 : 
    ($radix == 10) ? int($digits) :
    oct($digits);
  if ($sign eq '-') { $value = -$value; }
  return $value;
}

our $rgb_hex_triplet_re = compile_regexp(
  qr{\#? ([[:xdigit:]]{2}) ([[:xdigit:]]{2}) ([[:xdigit:]]{2})}oax,
  'rgb_hex_triplet');

sub parse_rgb_hex_triplet {
  if ($_[0] =~ $rgb_hex_triplet_re) {
    my @rgb = (hex($1), hex($2), hex($3));
    return @rgb;
  } else {
    return undef;
  }
}

our $uuid_re = compile_regexp(
  qr{(?: $hex_digit_re){8} -
      (?: $hex_digit_re){4} -
      (?: $hex_digit_re){4} -
      (?: $hex_digit_re){4} -
      (?: $hex_digit_re){12}
     }oamsx, 'uuid',
  'Universally Unique Identifier (UUID) with 128 bits in the standard '.
  'hex based printed format of xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx');

