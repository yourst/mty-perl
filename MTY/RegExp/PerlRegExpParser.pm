#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::RegExp::PerlRegExpParser
#
# Parser and Tokenizer for Perl Regular Expressions
#
# Copyright 2003-2014 Matt T. Yourst <yourst@yourst.com>
#

package MTY::RegExp::PerlRegExpParser;

use integer; use warnings; use Exporter::Lite;

nobundle:; our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($any_escaped_symbol_re $redundant_escape_re $regexp_alternation_or_re
     $regexp_anchor_re $regexp_any_char_re $regexp_backref_re
     $regexp_bracketed_char_set_re $regexp_cap_group_start_re
     $regexp_case_mod_re $regexp_comment_re $regexp_control_re
     $regexp_escaped_char_class_re $regexp_ext_group_start_re
     $regexp_group_end_re $regexp_literal_char_re $regexp_literal_string_re
     $regexp_numeric_literal_char_re $regexp_quantifier_labeled_re
     $regexp_quantifier_re $regexp_space_char_class_re $regexp_token_re
     $regexp_tokenizer_skip_whitespace %regexp_token_type_to_name
     @greedyness_names @regexp_tree_node_field_names INFINITE_QUANTIFIER
     RE_GREEDYNESS_GREEDY RE_GREEDYNESS_MINIMAL RE_GREEDYNESS_POSSESSIVE
     RE_TOKEN_ANCHOR RE_TOKEN_ANY_CHAR RE_TOKEN_BACKREF
     RE_TOKEN_BRACKETED_CHAR_SET RE_TOKEN_CAP_GROUP_START RE_TOKEN_CASE_MOD
     RE_TOKEN_COMMENT RE_TOKEN_CONTROL RE_TOKEN_ESCAPED_CHAR_CLASS
     RE_TOKEN_EXT_GROUP_START RE_TOKEN_GROUP_END RE_TOKEN_LITERAL
     RE_TOKEN_LITERAL_NUMERIC RE_TOKEN_LITERAL_STRING RE_TOKEN_OR
     RE_TOKEN_QUANTIFIER RE_TOKEN_REGEXP RE_TOKEN_SPACE_CHAR_CLASS
     RE_TOKEN_UNKNOWN RE_TOKEN_WHITESPACE RE_TREE_NODE_FIELDS
     RE_TREE_NODE_GREEDYNESS RE_TREE_NODE_GROUP_ID RE_TREE_NODE_MAX_QUANT
     RE_TREE_NODE_MIN_QUANT RE_TREE_NODE_POS RE_TREE_NODE_SUBNODES
     RE_TREE_NODE_TOKEN RE_TREE_NODE_TYPE check_for_regexp_parse_errors
     clean_up_and_optimize_regexp_parse_tree dump_regexp_parse_tree
     get_tokenized_regexp_metadata tokenize_regexp tokenize_regexp_to_tree
     tokenized_regexp_to_subtree tokenized_regexp_to_tree);

use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Common::Common qw(INT_MAX);

use MTY::Common::Strings;
use MTY::Filesystem::Files;
use MTY::RegExp::Define;
use MTY::RegExp::Tools;
use MTY::RegExp::Blocks;
use MTY::RegExp::Strings;
use MTY::RegExp::Numeric;
use MTY::RegExp::PerlSyntax;
use MTY::Display::Colorize;
use MTY::Display::PrintableSymbols;
use MTY::Display::PrintableSymbolTools;

use re qw(is_regexp regexp_pattern regmust regname regnames regnames_count);

use Data::Printer;
use Data::Printer { colored => 1, indent => 2, name => 'ref (loop)', deparse => 1, show_tied => 1, show_lvalue => 1, print_escapes => 1, output => 'stderr' };

#
# Perl 5.10+ Regular Expression grammar (assumes /x mode with whitespace ignored)
#

our $regexp_comment_re = compile_regexp(
  qr{\# [^\n]*+ \n}oamsx, 'regexp_comment');

our $regexp_any_char_re = compile_regexp(
  qr{\.}oamsx, 'regexp_any_char');

our $regexp_alternation_or_re = compile_regexp(
  qr{\|}oamsx, 'regexp_alternation_or');

our $regexp_escaped_char_class_re = compile_regexp(
  qr{\\ (?: 
    [dwDWSHVNRCX] | 
    [pP] (?:\w | \{ \w+ \})
    )}oamsx, 'regexp_escaped_char_class');

our $regexp_space_char_class_re = compile_regexp(
  qr{\\ (?: 
    [shvnrtlf\ \n\r\t\l\f\v] | 
    )}oamsx, 'regexp_space_char_class');

our $regexp_bracketed_char_set_re = compile_regexp(
  qr{\[ 
     (?: (?'invert_bracketed_char_set' \^))?
     (?'chars_in_brackets'
       (?: \])? # if ] is first char in list, it's always literal 
                # (since we can't have an empty list, i.e. []), 
       (?: \\ . || [^\]])+ # brace enclosed list with optional escaped '\]'
     )
     \]}oamsx, 'regexp_bracketed_char_set');

our $regexp_backref_re = compile_regexp(
  qr{\\ 
     (?: 
       [1-9] |
       g \-? [1-9] | 
       g \{ (?: \-? \d+ | \w+) \} |
       k (?: \' \w+ \' | \< \w+ \>)
     )}oamsx, 'regexp_backref');

our $regexp_literal_char_re = compile_regexp(
  qr{(?: 
       \w+ | # unescaped word characters
       (?: \\? [\~\`\!\@\%\&\-\=\:\;\"\'\<\>\,\/]) | # these may optionally be escaped
       # control char escape sequences (newlines, tabs, etc) + symbols which *must* be escaped:
       (?: \\ [ae\x0B\(\)\[\]\<\>\{\}\.\#\$\^\*\+\|\.\?\\])
     )+
    }oamsx, 'regexp_literal_char');

our $regexp_numeric_literal_char_re = compile_regexp(
  qr{[0-7]{3} |
     (?: o \{ [0-7]+ \}) |
     (?: x (?: (?: \{ [0-7A-Fa-f]+ \}) | [0-7A-Fa-f]{2})) |
     cx |
     (?: N \{ (?: (?: U \+ [0-7A-Fa-f]+) | \w+) \})
     }oamsx, 'regexp_numeric_literal_char');

our $regexp_literal_string_re = compile_regexp(
  qr{\\ \Q .*? \\ \E}oamsx, 'regexp_literal_string');

our $regexp_case_mod_re = compile_regexp(
  qr{\\ [luLU]}oamsx, 'regexp_case_mod');

our $regexp_anchor_re = compile_regexp(
  qr{[\$\^] | \\ [bBAZzGK]}oamsx, 'regexp_anchor');

our $regexp_quantifier_re = compile_regexp(
  qr{(?:
       [\*\+\?] |
       (?: \{ [0-9]+ (?: \, [0-9]+)? \})
     )
     [\?\+]?
     }oamsx, 'regexp_quantifier');

our $regexp_quantifier_labeled_re = compile_regexp(
  qr{(?:
       (?'short_count' [\*\+\?]) |
       (?: \{ (?'min_count' [0-9]+) (?: \, (?'max_count' [0-9]+))? \})
     )
     (?'greedy_minimal_nobacktrack' [\?\+]?)
    }oamsx, 'regexp_quantifier_labeled');
     
our $regexp_control_re = compile_regexp(
  qr{\( \* (?'control_action' \w*)
      (?: \: (?'control_arg' [^\)]+))? \)
     }oamsx, 'regexp_control_re');

our $regexp_cap_group_start_re = compile_regexp(
  qr{\(
     (?:
       (?: \? ['<] (?'name' \w+) ['>]) | # named group (?'name') or (?<name>)
       (?! [\?\*]) # anonymous numbered group (and not a control group either)
     )
    }oamsx, 'regexp_cap_group_start');

our $regexp_ext_group_start_re = compile_regexp(
  qr{\( \? (?:
     (?'group_type' [R\:\=\!\>\|]) |
     (?: (?'modifiers' \^? [adlupimsx\-]*) (?'group_type' \:)) |
     (?'group_type' (?: \< [\=\!])) |
     (?'group_type' [\#\{\(]) |
     (?'group_type' (?: \? \{ )) |
     (?'group_type' [\+\-]) (?'recursive_back_ref' [0-9]) |
     (?'group_type' \&) (?'named_back_ref' \w+)
   )}oamsx, 'regexp_ext_group_start');
     #++MTY TODO conditionals (?(cond)yes|no), (?(cond)yes)

our $regexp_group_end_re = compile_regexp(
  qr{\)}oamsx, 'regexp_group_end');

our $any_escaped_symbol_re = compile_regexp(
  qr{\\ (?= [\`\~\!\@\#\$\%\^\&\*\(\)\-\=\_\+\{\}\[\]\|\;\:\'\"\,\<\>\.\/\?])
     }oamsx, 'any_escaped_symbol');

our $redundant_escape_re = compile_regexp(
  qr{\\ ([\~\`\!\@\%\&\-\=\:\;\"\'\<\>\,\/\ \t\n\r\f\x0B\(\)\[\]\<\>\{\}\.\#\$\^\*\+\|\.\?])
     }oamsx, 'redundant_escape');

#my $reasm = Regexp::Assemble->new;
#my $assembled_regexp_token_re = $reasm->re;

use constant {
  RE_TOKEN_WHITESPACE           => 0,
  RE_TOKEN_COMMENT              => 1,
  RE_TOKEN_CAP_GROUP_START      => 2,
  RE_TOKEN_EXT_GROUP_START      => 3,
  RE_TOKEN_GROUP_END            => 4,
  RE_TOKEN_OR                   => 5,
  RE_TOKEN_LITERAL_STRING       => 6,
  RE_TOKEN_LITERAL              => 7,
  RE_TOKEN_LITERAL_NUMERIC      => 8,
  RE_TOKEN_ANY_CHAR             => 9,
  RE_TOKEN_ESCAPED_CHAR_CLASS   => 10,
  RE_TOKEN_SPACE_CHAR_CLASS     => 11,
  RE_TOKEN_BRACKETED_CHAR_SET   => 12,
  RE_TOKEN_QUANTIFIER           => 13,
  RE_TOKEN_ANCHOR               => 14,
  RE_TOKEN_BACKREF              => 15,
  RE_TOKEN_CONTROL              => 16,
  RE_TOKEN_CASE_MOD             => 17,
  RE_TOKEN_REGEXP               => 18,
  RE_TOKEN_UNKNOWN              => 19,
};

our %regexp_token_type_to_name = (
  RE_TOKEN_WHITESPACE, '(space)',
  RE_TOKEN_COMMENT, 'comment',
  RE_TOKEN_CAP_GROUP_START, 'capture',
  RE_TOKEN_EXT_GROUP_START, 'group',
  RE_TOKEN_GROUP_END, 'endgroup',
  RE_TOKEN_OR, 'or',
  RE_TOKEN_LITERAL_STRING, 'string',
  RE_TOKEN_LITERAL, 'literal',     
  RE_TOKEN_LITERAL_NUMERIC, 'numeric',
  RE_TOKEN_ANY_CHAR, 'any_char',
  RE_TOKEN_ESCAPED_CHAR_CLASS, 'charclass',
  RE_TOKEN_SPACE_CHAR_CLASS, 'space',
  RE_TOKEN_BRACKETED_CHAR_SET, 'charset',
  RE_TOKEN_QUANTIFIER,         'quantifier',
  RE_TOKEN_ANCHOR, 'anchor',
  RE_TOKEN_BACKREF, 'backref',
  RE_TOKEN_CONTROL, 'control',
  RE_TOKEN_CASE_MOD, 'casemod',
  RE_TOKEN_REGEXP, 'regexp',
  RE_TOKEN_UNKNOWN, 'UNKNOWN');

our $regexp_token_re = compile_regexp(qr{\G((?|
  (?> \s++ (*:0)) |
  (?> $regexp_comment_re (*:1)) |
  (?> $regexp_cap_group_start_re (*:2)) |
  (?> $regexp_ext_group_start_re (*:3)) |
  (?> $regexp_group_end_re (*:4)) |
  (?> $regexp_alternation_or_re (*:5)) |
  (?> $regexp_literal_string_re (*:6)) |
  (?> $regexp_literal_char_re (*:7)) |
  (?> $regexp_numeric_literal_char_re (*:8)) |
  (?> $regexp_any_char_re (*:9)) |
  (?> $regexp_escaped_char_class_re (*:10)) |
  (?> $regexp_space_char_class_re   (*:11)) |
  (?> $regexp_bracketed_char_set_re (*:12)) |
  (?> $regexp_quantifier_labeled_re (*:13)) |
  (?> $regexp_anchor_re (*:14)) |
  (?> $regexp_backref_re (*:15)) |
  (?> $regexp_control_re (*:16)) |
  (?> $regexp_case_mod_re (*:17))))
}oamsx, 'regexp_token', 
  'Match any perl regexp token and extract into $1 and named subgroups, '.
  'with $REGMARK set to one of the RE_TOKEN_xxx constants for the token type');

our $regexp_tokenizer_skip_whitespace = 0;

sub check_for_regexp_parse_errors($;$) {
  my ($re, $suppress_parse_error_message) = @_;
  # local (*re, *suppress_parse_error_message) = \ (@_);

  $suppress_parse_error_message //= 0;

  my $pos = pos($$re);
  my $len = length($$re);
  if (!(defined $pos)) { $pos = 0; }

  my $chars_left = $len - $pos;

  if ($chars_left == 0) { return 0; }

  if (!$suppress_parse_error_message) {
    print(STDERR "\n\n".$Y.$U.'WARNING:'.$X.$R.' check_for_regexp_parse_error: '.
          'stopped before end of input regexp pattern at offset '.$Y.$pos.$R.
          ' vs length '.$Y.$len.$R.' ('.$Y.$chars_left.$R.
          ' characters remaining)'.$X."\n");
    
    print(STDERR $Y.$U.'Regexp was:'.$X.' '.$G.$checkmark.' '.$K.$left_quote.$G.
          substr($$re, 0, $pos).$R.' '.$arrow_head.' '.$X.$R.
          substr($$re, $pos).$K.$right_quote.$X."\n");
  }

  return 1;
}

sub tokenize_regexp($;$$$) {
  my ($re, $modifiers, $suppress_parse_error_message, $include_whitespace) = @_;
  # local (*re, *modifiers, *suppress_parse_error_message, *include_whitespace) = \ (@_);

  $modifiers //= '';
  $suppress_parse_error_message //= 1;
  $include_whitespace //= 0;

  my $len = length($re);

  my $array = [ ];
  
  my $prev_type = RE_TOKEN_UNKNOWN;

  if (!(defined pos($re))) { pos($re) = 0; }

  local $REGMARK = undef;

  while ($re =~ /$regexp_token_re/oamsxgc) {
    my $match = $1;
    my $matchpos = $-[0];
    my $type = $REGMARK;

    next if (($type == RE_TOKEN_WHITESPACE) && (!$include_whitespace));
    my %subparts = ( );
    foreach $k (keys %+) { $subparts{$k} = $+{$k}; }

    my $typename = $regexp_token_type_to_name{$type} // 'unknown';
    $subparts{$typename} = $match;
    #print(STDERR 'type ['.$type.' => '.$typename.'] @ '.$matchpos.': "'.$match.'"'.NL);
    push @$array, [ $match, $type, $matchpos, length($match), \%subparts ];
    $prev_type = $type;
    $REGMARK = undef;
  }

  if (check_for_regexp_parse_errors(\$re, $suppress_parse_error_message)) {
    my %h = ();
    my $rest_of_re = substr($re, pos($re));
    my @a = ($rest_of_re, RE_TOKEN_UNKNOWN, pos($re), 
             length($re) - pos($re), \%h);
    push @{$array}, \@a;
  }

  return $array;
}

sub get_tokenized_regexp_metadata($$) {
  my ($re, $tokens) = @_;
  # local (*re, *tokens) = \ (@_);

  if (is_regexp_ref($re)) { $re = $$re; }

  my ($resrc, $modifiers) = regexp_pattern($re);
  my ($anchored, $floating) = regmust($re);

  my $structural_group_count = 0;
  my $capture_group_count = 0;
  my $named_capture_group_count = 0;
  my $numbered_capture_group_count = 0;
  
  foreach $rec (@$tokens) {
    my ($token, $type, $pos, $tokenlen, $subparts) = @$rec;
    $structural_group_count += ($type == RE_TOKEN_EXT_GROUP_START) ? 1 : 0;
    my $is_cap_group = ($type == RE_TOKEN_CAP_GROUP_START) ? 1 : 0;
    $capture_group_count += $is_cap_group;
    $named_capture_group_count += $is_cap_group && (exists $subparts->{name});
    $numbered_capture_group_count += $is_cap_group && (exists $subparts->{name});
  }

  my $metadata = {
    modifiers                 => $modifiers // '',
    characters                => length($resrc // $re),
    tokens                    => scalar(@$tokens),
    cap_groups                => $capture_group_count,
    structural_groups         => $structural_group_count,
    cap_groups                => $capture_group_count,
    named_cap_groups          => $named_capture_group_count,
    numbered_cap_groups       => $numbered_capture_group_count,
    anchored_string           => $anchored // '',
    floating_string           => $floating // ''
  };

  return $metadata;
}

use constant {
  RE_GREEDYNESS_GREEDY     => 0,  # no modifier character
  RE_GREEDYNESS_MINIMAL    => 1,  # '?' modifier: minimize match length
  RE_GREEDYNESS_POSSESSIVE => 2,  # '+' modifier: possessive a.k.a. no backtracking
};

our @greedyness_names = ('greedy', 'minimal', 'possessive');

use constant INFINITE_QUANTIFIER => INT_MAX;

# regexp tree node array fields
use constant {
  RE_TREE_NODE_TYPE       => 0,  # integer (RE_TOKEN_...)
  RE_TREE_NODE_TOKEN      => 1,  # text string
  RE_TREE_NODE_POS        => 2,  # integer
  RE_TREE_NODE_SUBNODES   => 3,  # ref to array of regexp tree nodes (only for RE_TOKEN_*_GROUP_START)
  RE_TREE_NODE_FIELDS     => 4,  # ref to hash of (regexp named captures => field values)
  RE_TREE_NODE_MIN_QUANT  => 5,  # integer: minimum quantity (1 if no quantifier was attached)
  RE_TREE_NODE_MAX_QUANT  => 6,  # integer: maximum quantity (1 if no quantifier was attached)
  RE_TREE_NODE_GREEDYNESS => 7,  # integer (RE_GREEDYNESS_...)
  RE_TREE_NODE_GROUP_ID   => 8,  # unique group ID number for anonymous capture groups
};

our @regexp_tree_node_field_names = (
  'type', 'token', 'pos', '@subnodes', '%fields',
  'min', 'max', 'greed', 'groupid');

noexport:; sub tokenized_regexp_to_subtree {
  my ($token_list, $token_index, $group, $group_id_counter_ref) = @_;
  # local (*token_list, *token_index, *group, *group_id_counter_ref) = \ (@_);

  my $group_type = (defined $group) ? $group->[RE_TREE_NODE_TYPE] : RE_TOKEN_UNKNOWN;
  my $prev_node = undef;
  my $node_list = [ ];
  my $or_alternatives_used = 0;
  my @or_alternative_group_start_indexes = ( 0 );

  while ($token_index < (scalar @$token_list)) {
    # print(STDERR 'token_list['.$token_index.'] = '.($token_list->[$token_index] // '<undef>').NL);

    my $rec = $token_list->[$token_index++];
    my ($token, $type, $pos, $token_length, $subparts) = @$rec;

    if ($type == RE_TOKEN_WHITESPACE) { next; }
    
    my $node = [
      $type, 
      $token, 
      $pos,
      [ ], # (subnodes)
      $subparts,
      1, # (min_quant)
      1, # (max_quant)
      RE_GREEDYNESS_GREEDY
    ];

    my $implicit_token = ($type == RE_TOKEN_GROUP_END) || ($type == RE_TOKEN_QUANTIFIER) || 
      ($type == RE_TOKEN_OR);

    push @$node_list, $node unless ($implicit_token);

    if (($type == RE_TOKEN_CAP_GROUP_START) || ($type == RE_TOKEN_EXT_GROUP_START)) {
      if ($type == RE_TOKEN_CAP_GROUP_START) { $group_id_counter++ }
      my $subnodes;
      ($subnodes, $token_index, $group_id_counter) = 
        tokenized_regexp_to_subtree($token_list, $token_index, $node, $group_id_counter);
      $node->[RE_TREE_NODE_SUBNODES] = $subnodes;
    } elsif ($type == RE_TOKEN_GROUP_END) {
      goto done;
    } elsif ($type == RE_TOKEN_OR) {
      $or_alternatives_used = 1;
      push @or_alternative_group_start_indexes,(scalar(@$node_list));
    } elsif ($type == RE_TOKEN_QUANTIFIER) {
      my $min_quant = $subparts->{min_count} // 1;
      my $max_quant = $subparts->{max_count} // undef;
      my $gmp = $subparts->{greedy_minimal_nobacktrack} // '';
      my $greedyness = 
        ($gmp eq '') ? RE_GREEDYNESS_GREEDY :
        ($gmp eq '?') ? RE_GREEDYNESS_MINIMAL :
        ($gmp eq '+') ? RE_GREEDYNESS_POSSESSIVE : undef;

      my $short_count = $subparts->{short_count};

      if (defined $short_count) {
        if ($short_count eq '*') {
          $min_quant = 0; $max_quant = INFINITE_QUANTIFIER;
        } elsif ($short_count eq '+') {
          $min_quant = 1; $max_quant = INFINITE_QUANTIFIER;
        } elsif ($short_count eq '?') {
          $min_quant = 0; $max_quant = 1;
        }
      }

      $prev_node->[RE_TREE_NODE_MIN_QUANT] = $min_quant;
      $prev_node->[RE_TREE_NODE_MAX_QUANT] = $max_quant;
      $prev_node->[RE_TREE_NODE_GREEDYNESS] = $greedyness;
    }

    $prev_node = $node;
  }
  done:

  #
  # Adjust a|b|c style RE_TOKEN_OR nodes to ensure all nodes associated
  # with each alternative are grouped into different subgroups:
  #
  if ($or_alternatives_used) {
    my $n = scalar(@or_alternative_group_start_indexes);

    my $new_node_list = [ ];

    my $top_level_or_node = [
      RE_TOKEN_OR,
      '(||', 
      ((defined $node_list->[0]) ? $node_list->[0]->[RE_TREE_NODE_POS] : ($inputpos // 0)),
      $new_node_list,
      \@empty_hash,
      1, # (min_quant)
      1, # (max_quant)
      RE_GREEDYNESS_GREEDY
    ];

    for (my $i = 0; $i < $n; $i++) {
      my $start = $or_alternative_group_start_indexes[$i];
      my $end = ($i < ($n-1)) ? $or_alternative_group_start_indexes[$i+1]-1 :
        scalar(@$node_list)-1;
      
      my $sublist = [ ];
      for (my $t = $start; $t <= $end; $t++) { 
        push @$sublist, $node_list->[$t];
      }

      my $first_token_in_sublist = ((scalar @$sublist) > 0) ? $sublist->[0] : undef;
      my $sublist_start_pos = (defined $first_token_in_sublist) ?
        $first_token_in_sublist->[RE_TREE_NODE_POS] : 0;

      my $or_alt_group_node = [
        RE_TOKEN_EXT_GROUP_START, 
        '(?:', 
        $sublist_start_pos,
        $sublist, # (subnodes)
        { },
        1, # (min_quant)
        1, # (max_quant)
        RE_GREEDYNESS_GREEDY
      ];

      push @$new_node_list, $or_alt_group_node;
    }

    $node_list = [ $top_level_or_node ]; #$new_node_list;
  }

  return ($node_list, $token_index, $group_id_counter);
}

sub tokenized_regexp_to_tree($;$) {
  my ($tokens, $modifiers) = @_;
  # local (*tokens, *modifiers) = \ (@_);

  $modifiers //= '';
  my $token_index = 0;
  my $group = undef;
  my $group_id_counter = 0;
  my $toplevel_node_list;

  ($toplevel_node_list, $token_index, $group, $group_id_counter) = 
    tokenized_regexp_to_subtree($tokens, $token_index, $group, $group_id_counter);

  my $root = [
    RE_TOKEN_REGEXP,
    'qr{',
    0,
    $toplevel_node_list,
    { },
    1,
    1,
    RE_GREEDYNESS_GREEDY,
    undef
  ];

  $root = clean_up_and_optimize_regexp_parse_tree($root);
  return $root;
}

sub tokenize_regexp_to_tree($) {
  # Convert the compiled regexp back into its tokenizable form,
  # and split off the modifiers at the same time:  
  my ($pattern, $modifiers) = get_regexp_pattern_and_modifiers($_[0]);
  my $tokens = tokenize_regexp($pattern);
  print(STDERR "# tokens = ".scalar(@$tokens).", mods $modifiers\n");

  my $tree = tokenized_regexp_to_tree($tokens, $modifiers);
  return $tree;
}

sub clean_up_and_optimize_regexp_parse_tree {
  my ($node, $level) = @_;
  # local (*node, *level) = \ (@_);

  $level //= 0;

  my ($type, $token, $pos, $subnodes, $subparts, $minquant, $maxquant, $greedyness) = @{$node};  
  $subnodes //= \@empty_list;

  my $n = scalar @$subnodes;

  if (($type == RE_TOKEN_EXT_GROUP_START) && ($token eq '(')) {
    if ($n == 0) {
      print(STDERR 'Remove empty group at pos '.$pos.' (token "'.$token.'")'.NL);
      # empty non-capturing group: we can safely delete it entirely
      return undef;
    } elsif ($n == 1) {
      # only one subnode: replace group with that subnode
      my $subnode = $subnodes->[0];
      die if (!defined $subnode);

      print(STDERR 'Collapse single subnode group at pos '.$pos.' (token "'.$token.'") '.
              'by replacing with subnode at pos '.$subnode->[RE_TREE_NODE_POS].' with token '.
                '"'.$subnode->[RE_TREE_NODE_TOKEN].'"'.NL);

      @{$node} = @{$subnode};
      return $node;
    }
  }

  my $new_subnode_list = [ ];
  for (my $i = 0; $i < $n; $i++) {
    my $subnode = $subnodes->[$i];
    my $replnode = clean_up_and_optimize_regexp_parse_tree($subnode, $level+1);
    next if (!defined $replnode);
    push @$new_subnode_list, $replnode;
  }

  $node->[RE_TREE_NODE_SUBNODES] = $new_subnode_list;
  return $node;
}

sub dump_regexp_parse_tree {
  my ($node, $out, $level) = @_;
  # local (*node, *out, *level) = \ (@_);

  
  $level //= 0;

  my ($type, $token, $inputpos, $subnodes, $fields, $min_quant, $max_quant, $greedyness, $groupid) = @{$node};

  #print(STDERR $G.$U.'[level '.$level.']: Node @ '.$node.' = '.p($node).NL);
  #print(STDERR 'level '.($level//'X').', type '.($type//'X').', token '.($token//'X').', pos '.($inputpos//'X').', desc '.(format_quoted($regexp_token_type_to_name{$type} // '???')).NL);

  ${$out} .= ('  ' x $level).$Y.$U.$regexp_token_type_to_name{$type}.$UX.$K.' = '.
    format_quoted($G.$token).$K.' @ '.$B.$inputpos;
  $min_quant //= 1; $max_quant //= 1;
  if (($min_quant != 1) || ($max_quant != 1)) {
    ${$out} .= $K.'; '.$R.'['.$M.($min_quant // x_symbol).$R.elipsis_three_dots.
      $M.($max_quant // infinity_sign).$R.']';
    if ($greedyness != RE_GREEDYNESS_GREEDY) { 
      ${$out} .= $K.';'.$B.(($greedyness == RE_GREEDYNESS_MINIMAL) ? 'minimal ('.$C.'?'.$B.')' : 
                              'possessive ('.$C.'+'.$B.')');
    }
  }

  my $n = scalar @{$subnodes};
  if ($n > 0) {
    ${$out} .= ('  ' x $level).$M.'; '.$U.$n.$UX.' subnodes:'.NL;

    foreach $subnode (@$subnodes) {
      dump_regexp_parse_tree($subnode, $out, $level + 1);
    }
  } else {
    ${$out} .= NL;
  }

  return $out;
}

1;
