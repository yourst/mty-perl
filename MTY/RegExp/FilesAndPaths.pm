#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::RegExp::FilesAndPaths
#
# Regular expressions related to files, file formats and paths,
# including file system paths, /proc pseudo-files, UUIDs, 
# 
#
# Copyright 2002 - 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::RegExp::FilesAndPaths;

use integer; use warnings; use Exporter qw(import);

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($wildcard_re $absolute_path_re $dot_or_dot_dot_re $path_component_re
     $path_separator_re $filesystem_path_re wildcards_to_regexp
     $filename_in_path_re $suffixes_in_path_re $directory_in_path_re
     expand_wildcard_braces $directories_in_path_re $last_path_component_re
     $final_suffix_in_path_re $basename_and_suffixes_re
     $directory_and_filename_re $suffixes_in_path_no_dot_re
     $strip_last_path_component_re $final_suffix_in_path_no_dot_re
     $filename_without_suffixes_in_path_re
     $filesystem_path_including_directory_re
     $filename_without_leading_directories_re
     $split_basename_suffixes_and_final_suffix_re
     $filesystem_dir_basename_suffixes_version_aware_re);

use MTY::RegExp::Define;
use MTY::RegExp::Blocks;
#pragma end_of_includes

#our $allowed_path_chars_re = compile_regexp(
#  \qr{[\w\s\.\~\`\!\@\#\$\%\^\&\*\(\)\_\-\+\=\{\}\[\]\|\:\;\'\"\<\,\.\>\?]}oax;

our $path_separator_re = compile_regexp(
  qr{/++}oamsx,
  'path_separator',
  'One or more instances of the path separator character (/); '.
  'useful for splitting paths into their component directories.');

our $path_component_re = compile_regexp(
  qr{((?> [^/]++))}oamsx,
  'path_component',
  'One component of a filesystem path (subdirectory or final filename) '.
  'comprising no slashes ("/") within it, but with one or more slashes '.
  'separating it from adjacent components. This regexp is preferable '.
  'to the simple qr{/} form for splitting paths, since the simple "/" '.
  'pattern will erroneously generate an extra result for any absolute '.
  'paths which begin with "/". Hence, this is best used as follows: '.
  'my @components = ($path =~ /$path_component_re/oamsxg);');

our $directories_in_path_re = compile_regexp(
  qr{\A /* (?> [^/]+ /+)*}oamsx,
  'directories_in_path',
  'Directory portion of POSIX-style filesystem path, optionally starting with '.
  'at least one forward slash (/) and consisting of one or more directory names, '.
  'each ending with at least one forward slash (/).');

our $filename_in_path_re = compile_regexp(
  qr{[^/]++ \Z}oamsx,
  'filename_in_path',
  'Filename (including optional suffix) portion of POSIX-style filesystem path, '.
  'which may include any character except a forward slash ("/")');

our $filename_without_leading_directories_re = compile_regexp(
  qr{\A [^/]++ /*+ \Z}oamsx,
  'filename_without_leading_directories',
  'Path containing only a filename without any directories, '.
  'or a single directory name with an optional trailing slash.');

our $last_path_component_re = compile_regexp(
  qr{(?> \A / \Z) | (?> [^/]++ /*+ \Z)}oamsx,
  'last_path_component',
  'Matches only the final component (filename or directory name with '.
  'optional trailing slash) in a path. Useful in substitutions to find '.
  'the directory containing a given filename. For files in the root '.
  'directory, this produces "/"; otherwise no trailing slash is included.');

our $strip_last_path_component_re = compile_regexp(
  qr{(?> \A / \K | /?) [^/]++ /*+ \Z}oamsx,
  'strip_last_path_component',
  'Matches only the final component (filename or directory name with '.
  'optional trailing slash) in a path. Useful in substitutions to find '.
  'the directory containing a given filename. For files in the root '.
  'directory, this produces "/"; otherwise no trailing slash is included.');

our $absolute_path_re = compile_regexp(
  qr{\A /}oamsx, 'absolute_path_re',
  'Absolute path starting from the root directory (/), which may still '.
  'contain symbolic links or relative references using "." or "..".');

our $dot_or_dot_dot_re = compile_regexp(
  qr{\A (\. \.?+) /*+ \Z}oamsx, 'dot_or_dot_dot',
  'Matches only "." or ".." (the current or parent directories) as the '.
  'entire specified string.');

our $filesystem_path_re = compile_regexp(
  qr{($directories_in_path_re)?
     ([^\/\.]++)? 
     (\. [^/]*+)?
    }oamsx, 'filesystem_path',
  'Filesystem path (POSIX style) split into three unnamed capture groups: '.
  '$1 = (optional) leading directory(s) separated by "/", with optional initial "/" '.
  '(in absolute paths starting from the root filesystem)'.
  '$2 = (required) portion of filename before the first dot (".")'.
  '$3 = (optional) remainder of filename (extension or suffix) after and including '.
  'the initial dot (".")');

our $filesystem_dir_basename_suffixes_version_aware_re = compile_regexp(
  qr{\A 
     ( # capture directory
       $directories_in_path_re
     )
     ( # capture basename
       (?:
         (?: 
           [^/\.]+
           (?: - \d+ 
             (?: \. \d+ [A-Za-z\_\+]*)+
           )+ 
         ) | 
         [^/\.]+ 
       )?
     )
     ( # capture suffixes
       (?: 
         \. [^/\.]*+
       )*+
     ) \Z
  }oamsx, 'filesystem_dir_basename_suffixes_version_aware_re',
  'Filesystem path (POSIX style) split into any leading directories (ending with a slash), '.
  'the base filename, and any suffixes following the ".". This regexp is aware of typical '.
  'version specifiers like e.g. "-1.2.3-4pre-5a-6c.suffix1.suffix2", and will include the '.
  'version(s) in the basename rather than as suffixes, e.g. ".2.3-pre4-5a-6c.suffix1.suffix2".');

our $directory_and_filename_re = compile_regexp(
  qr{(?| 
       (?> ($directories_in_path_re) ($filename_in_path_re)) |
       (?> (/*+) ($filename_in_path_re)) |
       (?> (/++) ())
     )
  }oamsx, 'directory_and_filename',
  'Filesystem path (POSIX style) split into two unnamed capture groups: '.
  '$1 = (optional) leading directory(s) separated by "/", with optional initial "/" '.
  '(in absolute paths starting from the root filesystem)'.
  '$2 = (required) filename after the final "/" (if any), including any and all '.
   'suffixes after and including any dots (".")');

our $filesystem_path_including_directory_re = compile_regexp(
  qr{\G (/? (?> [^/]++ /++)++ [^/\n]++ ) }oamsx, 'filesystem_path_including_directory',
  'Filesystem path (POSIX style) including at least one directory component '.
  'followed by a slash ("/") and then a filename without slashes. This regexp '.
  'will only match strings that are almost certainly filesystem paths, whereas '.
  'filesystem_path_re also matches arbitrary filenames without leading directories; '.
  'hence it is only useful for splitting paths into their components, whereas this '.
  'regexp is useful for identifying paths in the first place. This regexp does not '.
  'capture anything other than the whole matching path (in $1); it is solely inteded '.
  'for matching purposes, not parsing paths (use filesystem_path_re for that)');

#our $fully_qualified_filesystem_path_re = compile_regex(
#  \qr{( / (?> [^/]+ /)*? [^\/]+ )}}oax, 'fully_qualified_filesystem_path_re',
#  'Filesystem path (POSIX style) split into three unnamed capture groups: '

our $directory_in_path_re = compile_regexp(
  qr{\A (/? (?> [^/]+ /)*)}oamsx, 'directory_in_path',
  'Directory portion of filesystem path (POSIX style), with subdirectories'.
  'separated by "/", starting with an optional initial "/" (for absolute paths),'.
  'and ending with a final "/"');

our $filename_without_suffixes_in_path_re = compile_regexp(
  qr{([^/\.]*) (?: \. [^/]*)? \Z}oamsx, 'filename_without_suffixes_in_path',
  'Base of filename in filesystem path (POSIX style) without any suffixes (if present)'.
  'after the first ".", nor the "." itself (e.g. in /path/filename.a.b.c, filename is captured)');

our $basename_and_suffixes_re = compile_regexp(
  qr{([^\.]*+) ((?> \. [^/]*+)?) \Z}oamsx, 'basename_and_suffixes',
  'Splits the specified filename into its basename (the portion before the first ".", if present) '.
  'and any suffixes starting with the first ".".');

our $suffixes_in_path_re = compile_regexp(
  qr{(\. [^/]*+) \Z}oamsx, 'suffixes_in_path',
  'Suffix(s) (if any) including and after the first "." in the filename portion of a '.
  'filesystem path. All suffixes are included, if more than one is present '.
  '(e.g. in file.a.b.c, .a.b.c is captured)');

our $final_suffix_in_path_re = compile_regexp(
  qr{(\. [^\.\/]*+) \Z}oamsx, 'final_suffix_in_path',
  'Final suffix (if any) including and after the last "." in the filename portion of a '.
  'filesystem path (e.g. in "/x/y/z/file.a.b.c", ".c" is captured).');

our $suffixes_in_path_no_dot_re = compile_regexp(
  qr{\. ([^/]*+) \Z}oamsx, 'suffixes_in_path',
  'Suffix(s) (if any) after the first "." in the filename portion of a '.
  'filesystem path. All suffixes are included, if more than one is present '.
  '(e.g. in file.a.b.c, a.b.c is captured)');

our $final_suffix_in_path_no_dot_re = compile_regexp(
  qr{\. ([^\.\/]*+) \Z}oamsx, 'final_suffix_in_path',
  'Final suffix (if any) after the last "." in the filename portion of a '.
  'filesystem path (e.g. in "/x/y/z/file.a.b.c", "c" is captured).');

our $split_basename_suffixes_and_final_suffix_re = compile_regexp(
  qr{\A (?|
       (?> ((?> \. .*+)) () ()) |   # e.g. ".dotfile"
       (?> ((?> [^\.]++)) () ()) |
       (?:                          # e.g. basename  or  basename.ext  or  basename.ext1.extN
         ((?> [^\.]++))        # basename
         ((?> \. [^\.]*+)*?)    # .ext1.ext2
         ((?> \. [^\.]*+))     # .finalext
      )
    ) \Z
  }oamsx, 'split_basename_suffixes_and_final_suffix');

our $wildcard_re = compile_regexp(
  qr{([\*\?]) | 
     (?> \[ ((?> \\ . | [^\]])*+) \]) |
     (?> \{ ((?> (?> (?> \\ . | [^\,\}]*+) [\,\}])*+)*+)) }oamsx, 'wildcard',
  'Any POSIX style filename wildcards (*, ?, [A-Z...], {a,b,c})'.
  'Captures into $1 for single character wildcards "*" and "?",'.
  '$2 for bracketed character sets ([A-Z...]), or $3 for lists '.
  'of alternatives ({alt1,alt2,alt3}). Only one of these numbered '.
  'captures will be set after each match, thus allowing the wildcard '.
  'type to be easily determined.');

noexport:; sub expand_wildcard_braces($) {
  return $_[0]
    =~ s[ (?<! \\) \, ][|]roamsxg
    =~ s[ (?<! \\) \{ ][(?:]roamsxg
    =~ s[ (?<! \\) \} ][)]roamsxg;
}

sub wildcards_to_regexp($) {
  my $w = ($_[0] =~ s{\?}{.}roamsxg =~ s{\*}{.*}roamsxg
    =~ s{\[ ((?> \\ . | [^\]]++)) \]}{[$1]}roamsxg
    =~ s{($braces_re)}{expand_wildcard_braces($1)}roamsxge);
  return qr{\A$w\Z}ams;
}

1;

