#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::RegExp::FilesAndPaths
#
# Regular expressions related to files, file formats and paths,
# including file system paths, /proc pseudo-files, UUIDs, 
# 
#
# Copyright 2002 - 2014 Matt T. Yourst <yourst@yourst.com>
#

package MTY::RegExp::FilesAndPaths;

use integer; use warnings; use Exporter::Lite;

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($absolute_path_re $basename_and_suffixes_re $directories_in_path_re
     $directory_and_filename_re $directory_in_path_re $dot_or_dot_dot_re
     $filename_in_path_re $filename_without_leading_directories_re
     $filename_without_suffixes_in_path_re
     $filesystem_dir_basename_suffixes_version_aware_re
     $filesystem_path_including_directory_re $filesystem_path_re
     $strip_last_path_component_re $suffixes_in_path_re $wildcard_re);

use MTY::RegExp::Define;

#our $allowed_path_chars_re = compile_regexp(
#  \qr{[\w\s\.\~\`\!\@\#\$\%\^\&\*\(\)\_\-\+\=\{\}\[\]\|\:\;\'\"\<\,\.\>\?]}oax;

our $directories_in_path_re = compile_regexp(
  qr{\A /* (?> [^/]+ /+)*}oamsx,
  'directories_in_path',
  'Directory portion of POSIX-style filesystem path, optionally starting with '.
  'at least one forward slash (/) and consisting of one or more directory names, '.
  'each ending with at least one forward slash (/).');

our $filename_in_path_re = compile_regexp(
  qr{[^/]++ \Z}oamsx,
  'filename_in_path',
  'Filename (including optional suffix) portion of POSIX-style filesystem path, '.
  'which may include any character except a forward slash ("/")');

our $filename_without_leading_directories_re = compile_regexp(
  qr{\A [^/]++ /*+ \Z}oamsx,
  'filename_without_leading_directories',
  'Path containing only a filename without any directories, '.
  'or a single directory name with an optional trailing slash.');

our $strip_last_path_component_re = compile_regexp(
  qr{(?> \A / \K | /?) [^/]++ /*+ \Z}oamsx,
  'strip_last_path_component',
  'Matches only the final component (filename or directory name with '.
  'optional trailing slash) in a path. Useful in substitutions to find '.
  'the directory containing a given filename. For files in the root '.
  'directory, this produces "/"; otherwise no trailing slash is included.');

our $absolute_path_re = compile_regexp(
  qr{\A /}oamsx, 'absolute_path_re',
  'Absolute path starting from the root directory (/), which may still '.
  'contain symbolic links or relative references using "." or "..".');

our $dot_or_dot_dot_re = compile_regexp(
  qr{\A (\. \.?+) /*+ \Z}oamsx, 'dot_or_dot_dot',
  'Matches only "." or ".." (the current or parent directories) as the '.
  'entire specified string.');

our $filesystem_path_re = compile_regexp(
  qr{($directories_in_path_re)?
     ([^\/\.]++)? 
     (\. [^/]*+)?
    }oamsx, 'filesystem_path',
  'Filesystem path (POSIX style) split into three unnamed capture groups: '.NL.
  '$1 = (optional) leading directory(s) separated by "/", with optional initial "/" '.
  '(in absolute paths starting from the root filesystem)'.NL.
  '$2 = (required) portion of filename before the first dot (".")'.NL.
  '$3 = (optional) remainder of filename (extension or suffix) after and including '.
  'the initial dot (".")');

our $filesystem_dir_basename_suffixes_version_aware_re = compile_regexp(
  qr{\A 
     ( # capture directory
       $directories_in_path_re
     )
     ( # capture basename
       (?:
         (?: 
           [^/\.]+
           (?: - \d+ 
             (?: \. \d+ [A-Za-z\_\+]*)+
           )+ 
         ) | 
         [^/\.]+ 
       )?
     )
     ( # capture suffixes
       (?: 
         \. [^/\.]*+
       )*+
     ) \Z
  }oamsx, 'filesystem_dir_basename_suffixes_version_aware_re',
  'Filesystem path (POSIX style) split into any leading directories (ending with a slash), '.
  'the base filename, and any suffixes following the ".". This regexp is aware of typical '.
  'version specifiers like e.g. "-1.2.3-4pre-5a-6c.suffix1.suffix2", and will include the '.
  'version(s) in the basename rather than as suffixes, e.g. ".2.3-pre4-5a-6c.suffix1.suffix2".');

our $directory_and_filename_re = compile_regexp(
  qr{(?| 
       (?> ($directories_in_path_re) ($filename_in_path_re)) |
       (?> (/*+) ($filename_in_path_re)) |
       (?> (/++) ())
     )
  }oamsx, 'directory_and_filename',
  'Filesystem path (POSIX style) split into two unnamed capture groups: '.NL.
  '$1 = (optional) leading directory(s) separated by "/", with optional initial "/" '.
  '(in absolute paths starting from the root filesystem)'.NL.
  '$2 = (required) filename after the final "/" (if any), including any and all '.
   'suffixes after and including any dots (".")'.NL);

our $filesystem_path_including_directory_re = compile_regexp(
  qr{\G (/? (?> [^/]++ /++)++ [^/\n]++ ) }oamsx, 'filesystem_path_including_directory',
  'Filesystem path (POSIX style) including at least one directory component '.
  'followed by a slash ("/") and then a filename without slashes. This regexp '.
  'will only match strings that are almost certainly filesystem paths, whereas '.
  'filesystem_path_re also matches arbitrary filenames without leading directories; '.
  'hence it is only useful for splitting paths into their components, whereas this '.
  'regexp is useful for identifying paths in the first place. This regexp does not '.
  'capture anything other than the whole matching path (in $1); it is solely inteded '.
  'for matching purposes, not parsing paths (use filesystem_path_re for that)');

#our $fully_qualified_filesystem_path_re = compile_regex(
#  \qr{( / (?> [^/]+ /)*? [^\/]+ )}}oax, 'fully_qualified_filesystem_path_re',
#  'Filesystem path (POSIX style) split into three unnamed capture groups: '.NL.

our $directory_in_path_re = compile_regexp(
  qr{\A (/? (?> [^/]+ /)*)}oamsx, 'directory_in_path',
  'Directory portion of filesystem path (POSIX style), with subdirectories'.NL.
  'separated by "/", starting with an optional initial "/" (for absolute paths),'.NL.
  'and ending with a final "/"');

our $filename_without_suffixes_in_path_re = compile_regexp(
  qr{([^/\.]*) (?: \. [^/]*)? \Z}oamsx, 'filename_without_suffixes_in_path',
  'Base of filename in filesystem path (POSIX style) without any suffixes (if present)'.NL.
  'after the first ".", nor the "." itself (e.g. in /path/filename.a.b.c, filename is captured)');

our $basename_and_suffixes_re = compile_regexp(
  qr{([^\.]*+) ((?> \. [^/]*+)?) \Z}oamsx, 'basename_and_suffixes',
  'Splits the specified filename into its basename (the portion before the first ".", if present) '.
  'and any suffixes starting with the first ".".');

our $suffixes_in_path_re = compile_regexp(
  qr{(\. [^/]*) \Z}oamsx, 'suffixes_in_path',
  'Suffix(s) (if any) including and after the first "." in the filename portion of a '.NL.
  'filesystem path. All suffixes are included, if more than one is present '.NL.
  '(e.g. in file.a.b.c, .a.b.c is captured)');

our $wildcard_re = compile_regexp(
  qr{([\*\?]) | 
     ((?: \[ (?: \\ . | [^\]])* \])) |
     ((?: \{ (?: \\ . | [^\}])* \}))}oamsx, 'wildcard',
  'Any POSIX style filename wildcards (*, ?, [A-Z...], {a,b,c})'.NL.
  'Captures into $1 for single character wildcards "*" and "?",'.NL.
  '$2 for bracketed character sets ([A-Z...]), or $3 for lists '.NL.
  'of alternatives ({alt1,alt2,alt3}). Only one of these numbered '.NL.
  'captures will be set after each match, thus allowing the wildcard '.NL.
  'type to be easily determined.');

1;

