#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::ListDeps::Config
#
# Copyright 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::ListDeps::Config;
use integer; use warnings; use Exporter qw(import);

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($cache_file_name $debug $enable_warnings $find_recursive_deps
     $force_color $include_external_deps $listdeps_banner $output_format
     $project_dir $show_all_deps $show_all_files_found
     $show_deps_for_every_file_found $show_direct_deps $show_graphviz
     $show_inverse_deps $show_metadata_cache_status $show_supported_file_types
     $show_symbolic_deps $show_tree $strip_project_dir_from_output_filenames
     $verbose $wrap_long_lines %dir_aliases %output_format_to_formatting
     %path_prefixes %plugin_name_to_class %plugin_name_to_source_types
     %source_type_to_plugin %source_type_to_spec @dep_type_to_name @plugins
     ALL_DEPS COMPILER_PATH_PREFIX_COLOR DIRECT_DEPS EXTRA_PATH_PREFIX_COLOR_1
     EXTRA_PATH_PREFIX_COLOR_2 EXTRA_PATH_PREFIX_COLOR_3 INVERSE_DEPS
     PROJECT_PATH_PREFIX_COLOR STORED_METADATA_CACHE_FORMAT_VERSION
     SYMBOLIC_DEPS SYSTEM_PATH_PREFIX_COLOR determine_file_type
     format_filename_with_path_prefix parse_listdeps_command_line
     register_command_line_options register_file_type_plugin
     register_path_prefixes retrieve_all_cached_metadata
     show_supported_file_types store_all_cached_metadata);

use MTY::Common::Common;
use MTY::Common::Strings;
use MTY::Common::Hashes;
use MTY::Common::CommandLine;

use MTY::Filesystem::Files;
use MTY::Filesystem::FileStats;

use MTY::Display::Colorize;
use MTY::Display::ColorizeErrorsAndWarnings;
use MTY::Display::ColorCapabilityCheck;
use MTY::Display::ANSIColorREs;
use MTY::Display::TextInABox;
use MTY::Display::Tree;
use MTY::Display::PrintableSymbols;
use MTY::Display::PrintableSymbolTools;
use MTY::Display::DataStructures;

use MTY::RegExp::FilesAndPaths;
use MTY::RegExp::PrefixStrings;
use MTY::RegExp::Strings;

use MTY::System::POSIX;
use MTY::System::Misc;

use MTY::Filesystem::SearchableDirList;

use Storable qw(store retrieve store_fd fd_retrieve);

#-----------------------------------------------------------------------------#
# Command line options                                                        #
#-----------------------------------------------------------------------------#

our $show_symbolic_deps = 0;
our $show_direct_deps = 0;
our $show_all_deps = 0;
our $show_inverse_deps = 0;

our $show_all_files_found = 0;

our $find_recursive_deps = 0;
our $include_external_deps = 0;
our $show_deps_for_every_file_found = 0;

our $strip_project_dir_from_output_filenames = 1;
our $output_format = undef;
our $show_tree = 0;
our $show_graphviz = 0;
our $wrap_long_lines = undef;
our $force_color = 0;

our $cache_file_name = '/tmp/.lsdeps-cache-'.get_user_name();
our $show_metadata_cache_status = 0;

our $project_dir = undef;
our $enable_warnings = 0;
our $verbose = 0;
our $debug = 0;
our $show_supported_file_types = 0;

our %dir_aliases = ( );

use constant enum qw(SYMBOLIC_DEPS DIRECT_DEPS ALL_DEPS INVERSE_DEPS);
our @dep_type_to_name = qw(symdeps deps alldeps invdeps);

our %output_format_to_formatting = (
  tabdelim => '%T\t%S\t%D',
  makerules => '%S: %D',
  makedefs => '%T[%S] := %D',
);

my %command_line_options = (
  META_OPTION_NON_OPTIONS_REQUIRED, 1,
# META_OPTION_MUTUALLY_EXCLUSIVE_REQUIRED, [ qw(direct all inverse found) ],

  # Type of Dependencies to Include
  'symbolic' => [ \$show_symbolic_deps, 0, [ qw(s sym symdeps) ] ],
  'direct' => [ \$show_direct_deps, 0, [ 'd' ] ],
  'all' => [ \$show_all_deps, 0, [ qw(a all-deps) ] ],
  'inverse' => [ \$show_inverse_deps, 0, [ qw(i inv inv-deps reverse rev rev-deps) ] ],
  'found' => [ \$show_all_files_found, 0, [ qw(show-found-files all-files) ] ],

  # Scope of Dependencies to Include
  'recursive' => [ \$find_recursive_deps, 0, [ qw(r recurse follow) ] ],
  'external' => [ \$include_external_deps, 0, 'x' ],
  'complete' => [ \$show_deps_for_every_file_found, 0, [ qw(c show-every-file-found) ] ],

  # Output Format (mutually exclusive)
  'format' => [ \$output_format, OPTION_VALUE_REQUIRED, [ 'fmt' ], \%output_format_to_formatting ],
  'tabdelim' => [ \$output_format, 0, [ qw(machine-readable td) ], $output_format_to_formatting{tabdelim} ],
  'makerules' => [ \$output_format, 0, [ qw(m make makefile) ], $output_format_to_formatting{makerules} ],
  'makedefs' => [ \$output_format, 0, [ qw(md makevars) ], $output_format_to_formatting{makedefs} ],
  'tree' => [ \$show_tree, 0, [ ] ],
  'graphviz' => [ \$show_graphviz, 0, [ qw(depgraph graph) ] ],

  # Caching Options
  'cache' => [ \$metadata_cache_filename, OPTION_VALUE_REQUIRED, [ ] ],
  'nocache' => [ \$metadata_cache_filename, 0, [ ], '' ],
  'show-cache-status' => [ \$show_metadata_cache_status, 0, [ ] ],

  # Miscellaneous Options
  'projectdir' => [ \$project_dir, OPTION_VALUE_REQUIRED, [qw(p project proj projdir dir sourcedir)] ],
  'strip-project-dir' => [ \$strip_project_dir_from_output_filenames, 0, [ qw(strip-proj-dir projrel rel nodir) ] ],
  'dir-alias' => [ \%dir_aliases, OPTION_LIST, [ qw(da diralias) ] ],
  'list-types' => [ \$show_supported_file_types, 0, [ 'types' ] ],
  'force-color' => [ \$force_color ],
  'wrap-long-lines' => [ \$wrap_long_lines, OPTION_VALUE_REQUIRED, [ 'wrap' ] ],
  'nowarnings' => [ \$enable_warnings, OPTION_ASSIGN_BOOL, [ qw(nowarn w) ], 0, 1],
  'debug' => [ \$debug ],
);

our $listdeps_banner = print_banner(
  fg_color_rgb(64, 255, 180).'lsdeps',
  Y.'List dependencies required by C/C++, Perl, shell scripts, Makefiles and more', PURPLE);

my @command_line_option_descriptions = (
  [ OPTION_HELP_LITERAL ] => $listdeps_banner,

  [ OPTION_HELP_CATEGORY, C_2_3 ] => U.C.'Types'.UX.C_3_4.' of Dependencies to Include',
  'symbolic' => 'List original symbolic dependencies before resolving to filenames',
  'direct' => 'List only directly included dependencies',
  'all' => 'List all direct and indirect (recursive) dependencies',
  'inverse' => 'List inverse dependencies (the other files which depend on each file)',
  'found' => 'List the complete set of files located during recursive traversal',

  [ OPTION_HELP_CATEGORY, G_2_3 ] => U.G.'Scope'.UX.G_3_4.' of Dependencies to Include',
  'recursive' => 'Recursively find all dependencies of all included files (implied by -all and -found options)',
  'external' => 'Show external included files (i.e. those provided by the compiler in /usr/include, /usr/lib/perl5/5.x.x/, etc) in addition to included files within the target project',
  'complete' => 'Print dependencies for complete list of sources found recursively (instead of just those on the command line)',

  [ OPTION_HELP_CATEGORY, Y_2_3 ] => U.Y.'Format'.UX.Y_3_4.' of output (mutually exclusive)',
  'format' => 'Output format to use for printing specified dependency list types (%T = dep type, %S = source filename, %D = space separated list of dependencies)',
  'tabdelim' => 'Simple tab delimited format, e.g. '.M.'deptype'.R.'<tab>'.M.'source'.R.'<tab>'.M.'dep1 dep2 '.M_1_2.'...'.X,
  'makerules' => 'Makefile rules with target and prerequisites, e.g. '.M.'/path/to/source.ext: /dir1/dep1.h /dir2/dep2.h'.X,
  'makedefs' => 'Makefile variable definitions, e.g. '.M.'deps[/path/to/source.ext] := /dir1/dep1.h /dir2/dep2.h ...'.X,
  'tree' => 'Print a tree diagram of all recursive dependencies relative to each source',
  'graphviz' => 'Generate a GraphViz .dot format file of the dependency graph',

  [ OPTION_HELP_CATEGORY, M_2_3 ] => M.'Persistent Metadata Caching',
  'cache' => 'Filename for the persistent metadata cache (default is ".depscache" in the project directory)',
  'nocache' => 'Remove any existing metadata cache and do not create any cache file',
  'show-cache-status' => 'Show any files which were newer than the cached data or otherwise could not use the cache',

  [ OPTION_HELP_CATEGORY, M_2_3 ] => M.'Miscellaneous Options',
  'projectdir' => 'Project directory (to differentiate external vs internal dependencies; default is the current directory when invoked)',
  'strip-project-dir' => 'Remove the project directory path from any output filenames containing it',
  'list-types' => 'List all supported file types and their attributes and capabilities',
  'force-color' => 'Force printing output in color',
  'wrap-long-lines' => 'Wrap long lines to the specified number of columns (wrapped lines will end with a backslash)',
  'nowarnings' => 'Do not show any warning messages',
  'debug' => 'Print numerous debug messages',

  [ OPTION_HELP_CATEGORY, G_2_3, ALIGN_CENTER ] => G.'Options specific to each file type',
);

#-----------------------------------------------------------------------------#
# Source Type Plugin Registry:                                                #
#-----------------------------------------------------------------------------#

our @plugins = ( );
our %plugin_name_to_class = ( );
our %plugin_name_to_source_types = ( );
our %source_type_to_spec = ( );
our %source_type_to_plugin = ( );

my %suffix_to_source_type = ( );
my %interp_to_source_type = ( );
my %emacs_mode_to_source_type = ( );

#-----------------------------------------------------------------------------#
# Register a source file type handler plugin:                                 #
#-----------------------------------------------------------------------------#

export:; sub register_file_type_plugin($$+;+++&) {
  my ($plugin, $class, $source_types, 
      $plugin_command_line_options, $plugin_option_descriptions) = @_;

  push @plugins, $plugin;
  $plugin_name_to_class{$plugin} = $class;
  $plugin_name_to_source_types{$plugin} = $source_types;
  
  while (my ($type, $typespec) = each %$source_types) {
    my ($description, $flags, $suffixes, $interps, $emacs_modes, $tree_node_symbol) =
      getfields $typespec, qw(description flags suffixes interps emacs_modes tree_node_symbol);

    if (exists $source_type_to_spec{$type}) { 
      warning("Source type $type is already defined; not redefining to plugin $plugin");
      next;
    }

    $typespec->{type} = $type;
    $typespec->{plugin} = $class;
    $source_type_to_spec{$type} = $typespec;
    $source_type_to_plugin{$type} = $plugin;

    foreach my $suffix (@$suffixes) { $suffix_to_source_type{$suffix} = $typespec; }

    my @interps_to_add = map { (($_ =~ /$wildcard_re/oax) ? glob($_) : ($_)) } @$interps;
    foreach my $interp (@interps_to_add) { $interp_to_source_type{$interp} = $typespec; }

    foreach my $emacs_mode (@$emacs_modes) { $emacs_mode_to_source_type{$emacs_mode} = $typespec; }

    $typespec->{tree_node_symbol_cmd} = [ TREE_CMD_SYMBOL, G.$tree_node_symbol ];
    $typespec->{tree_node_symbol_dark_cmd} = [ TREE_CMD_SYMBOL, 
      G_1_2.scale_rgb_fg_in_string($tree_node_symbol, RATIO_1_2) ];
  }

  register_command_line_options($plugin_command_line_options, $plugin_option_descriptions, $plugin);

  return 1;
}

my $shebang_interp_and_args_re = 
  qr{\A \#\! \s*+ (\S++) \s*+ (\N*+) \n}oamsx;

my $emacs_mode_decl_re =  
  qr{^ \s*+
     (?> [\#\;] | \/ [\*\/]) 
     \N*?
     \-\*\- \s++ (\S++) \s++ \-\*\-}oamsx;

sub determine_file_type($$) {
  my ($code, $filename) = @_;
  my $typespec = undef;

  my $suffix = final_suffix_without_dot_of($filename) // '';
  my ($interp, $interp_args) = ($code =~ /$shebang_interp_and_args_re/oamsx);
  my ($emacs_mode) = ($code =~ /$emacs_mode_decl_re/oamsx);
  my @rets = ($suffix, $interp, $emacs_mode);

  # 
  # First use the #!/path/to/interpreter within the code as the most reliable
  # indication of which plugin can handle this file, since obviously a program
  # isn't going to contain e.g. "#!/usr/bin/perl" (the so-called "shebang"
  # header on its first line) unless it's an actual Perl program.
  #
  # Unfortunately this doesn't work for libraries like Perl modules, etc.,
  # which generally aren't executable and thus don't need a shebang.
  #
  # We also need to employ more sophisticated heuristics to identify statically
  # compiled sources like C/C++. This is especially important in the case of
  # like C/C++ *.h header files, since C and C++ use different sets of include
  # paths and search semantics, yet it's quite hard to distinguish C vs C++ 
  # code when the .h suffix is often used for both languages. 
  #
  # To handle situations like this, the appropriate plugin (which generally
  # needs to handle all of the closely related languages that a given file
  # could be written in, as determined initially by its suffix and a few
  # other generic tests below) will need to actually match the code against
  # various regexps for e.g. keywords found in only one of the languages,
  # although those keywords should ideally be mandatory in any properly 
  # structured source code so as to avoid ambiguities.
  #

  if (is_there($interp)) {
    $typespec = $interp_to_source_type{$interp};
    return ($typespec, @rets) if (defined $typespec);
  }

  #
  # If the source code contains an explicit '-*- emacs-mode-here -*-' specifier
  # for Emacs to use while editing it, use this as the next most reliable type,
  #

  if (is_there($emacs_mode)) {
    $typespec = $emacs_mode_to_source_type{$emacs_mode};
    return ($typespec, @rets) if (defined $typespec);
  }

  #
  # Use the filename suffix to find which plugin handles this file type:
  #

  if (is_there($suffix)) {
    $typespec = $suffix_to_source_type{$suffix};
    return ($typespec, @rets) if (defined $typespec);
  }

  warning('Cannot find any file type plugin to process the file "', $filename, '"');

  return;
}

#-----------------------------------------------------------------------------#
# Show a listing of all plugins and their supported source file types:        #
#-----------------------------------------------------------------------------#

export:; sub show_supported_file_types() {
  my $tree_root = [ [ C.U.'Supported File Types'.X ] ];

  foreach my $plugin (sort keys %plugin_name_to_source_types) {
    my $class = $plugin_name_to_class{$plugin};
    my $source_types = $plugin_name_to_source_types{$plugin};
    
    my $plugin_node = [ 
      [
        [ TREE_CMD_SYMBOL, G.p_in_circle ],
        G.$plugin.' '.G_2_3.'('.$class.')',
      ]
    ];
    push @$tree_root, $plugin_node;

    foreach my $type (sort keys %$source_types) {
      my $spec = $source_types->{$type};

      my $spec_node = [
        [
          [ TREE_CMD_SYMBOL, arrow_tri, arrow_open_tri ],
          C.$spec->{type}
        ],
        $spec->{description},
        format_source_flags($spec->{flags}),
        join(' ', @{$spec->{suffixes} // [ ]}),
        join(' ', @{$spec->{interps} // [ ]}),
        join(' ', @{$spec->{emacs_mode} // [ ]}),
      ];
      push @$plugin_node, $spec_node;
    }
  }

  print_tree($tree_root);
}

sub register_command_line_options(+;+$) {
  my ($plugin_command_line_options, $plugin_option_descriptions, $plugin) = @_;
  $plugin_option_descriptions //= [ ];
  my ($caller_package_without_prefixes) = (caller =~ /([^:]+)$/oax);
  $plugin //= $caller_package_without_prefixes;

  while (my ($option, $typespec) = each %$plugin_command_line_options) {
    if (exists $command_line_options{$option}) 
      { die('Plugin '.$plugin.' tried to override pre-existing command line option '.$option); }
    $command_line_options{$option} = $typespec;
  }

  if (defined $plugin) {
    push @command_line_option_descriptions, 
      [ OPTION_HELP_CATEGORY, G_2_3 ] => G_2_3.'Options for '.G.$plugin,
  }

  push @command_line_option_descriptions, @$plugin_option_descriptions;
}

use constant {
  PROJECT_PATH_PREFIX_COLOR  => fg_color_rgb(255,  160,  64),
  SYSTEM_PATH_PREFIX_COLOR   => fg_color_rgb(255,  64,  160),
  COMPILER_PATH_PREFIX_COLOR => fg_color_rgb(64,  160,  255),
  EXTRA_PATH_PREFIX_COLOR_1  => fg_color_rgb(180,  96,  255),
  EXTRA_PATH_PREFIX_COLOR_2  => fg_color_rgb(160, 224,   64),
  EXTRA_PATH_PREFIX_COLOR_3  => fg_color_rgb(64,  224,  160),
};

our %path_prefixes = ( );

my $path_prefixes_re = undef;

sub register_path_prefixes(+;@) {
  my ($prefixes) = @_;
  if (is_string $prefixes) { $prefixes = \@_; }
  elsif (is_hash_ref $prefixes) { $prefixes = [ %$prefixes ]; }

  pairmap {
    my $path = normalize_trailing_slash($a);
    if (!exists $path_prefixes{$path}) {
      my ($color_codes, $abbrev) = 
        separate_leading_ansi_console_escape_codes($b);

      my $color = (is_there $color_codes) ? $color_codes : SYSTEM_PATH_PREFIX_COLOR;
      my $dark = scale_rgb_fg(((is_there $color_codes) ? $color_codes : SYSTEM_PATH_PREFIX_COLOR), RATIO_2_3);

      $path_prefixes{$path} = 
        $dark.double_left_angle_bracket.
        $color.$b.$dark.double_right_angle_bracket.
        large_right_slash.X;
    }
  } @$prefixes;

  # Clear the regexp so it will be regenerated the next time we need to use it:
  $path_prefixes_re = undef;
}

sub format_filename_with_path_prefix($) {
  my ($filename) = @_;

  if (!defined $path_prefixes_re) {
    $path_prefixes_re //= prepare_prefix_string_subst_regexp((sort keys %path_prefixes));
  }
  return format_filesystem_path($filename, %path_prefixes, $path_prefixes_re);
}

noexport:; use constant {
  STORED_METADATA_CACHE_FORMAT_VERSION => 201502120001,
};

sub retrieve_all_cached_metadata() {
  my $cache_fd = sys_open($cache_file_name, O_RDONLY); 

  if (!defined $cache_fd) {
    # Cache file doesn't exist - this is usually normal the first time
    # after we enable the metadata cache, so just silently return undef.
    return undef;
  }

  my $cache_fd_stats = get_file_stats_of_fd($cache_fd);
  my $perms = $cache_fd_stats->[STAT_MODE];

  if ($perms & (PERM_GROUP_W | PERM_OTHER_W)) {
    warning('Cache file ', $cache_file_name, ' is writable by your group '.
            'and/or everyone; this is insecure and will invalidate the cache.');
    sys_close($cache_fd); # close the file handle and underlying fd
    return undef;
  }

  my $handle = IO::File->new_from_fd($cache_fd, 'r');

  my $cache = Storable::fd_retrieve($handle);

  if (!defined $cache) {
    warning("Cannot retrieve metadata from cache file '$filename'");
    return undef;
  }

  my ($version, $timestamp) = getfields $cache, qw(version timestamp);

  if ($version != STORED_METADATA_CACHE_FORMAT_VERSION) {
    warning("Cached metadata in '$filename' was from incompatible version $version ".
            "(this is version ".STORED_METADATA_CACHE_FORMAT_VERSION.")");
    return undef;
  }

  $handle = undef; # close the handle and the underlying file

  if (is_debug) { pp $cache; }

  return $cache;
}

sub store_all_cached_metadata(+) {
  my ($cache) = @_;

  return undef if (!defined $cache_file_name);

  if (is_debug) { pp $cache; }

  $cache->{version} = STORED_METADATA_CACHE_FORMAT_VERSION;
  $cache->{filename} = $filename;

  $cache->{config} = save_current_option_settings(%command_line_options, $command_line_option_values);

  my $timestamp = clock_gettime_nsec();
  $cache->{timestamp} = $timestamp;

  my $cache_fd = sys_open($cache_file_name, O_WRONLY|O_CREAT|O_TRUNC, 0600); 

  if (!defined $cache_fd) {
    warning('Cannot open cache file ', $cache_file_name, ' for writing (', $!, ')');
    $cache_file_name = undef;
    return undef;
  }

  my $handle = IO::File->new_from_fd($cache_fd, 'w');

  if (!Storable::store_fd($cache, $handle)) {
    warning("Cannot store metadata into cache file '$filename'");
    # Make sure we eliminate any possibly partially written file:
    $handle = undef; # close the file handle and the underlying stream
    sys_unlink($filename);
    return undef;
  }

  $handle = undef; # close the file handle and the underlying stream

  return $cache;
}

sub parse_listdeps_command_line() {
  my ($filenames, $invalid_option_indexes, $command_line_option_values) = 
    parse_and_check_command_line(%command_line_options, @ARGV, @command_line_option_descriptions);

  $filenames = [ map { (resolve_path($_) // '(missing):'.$_) } @$filenames ];

  if (!is_stdout_color_capable() && (!$force_color)) { $machine_readable = 1; }

  my $show_symbolic_direct_inverse_deps = 
    $show_symbolic_deps || $show_direct_deps || $show_inverse_deps;

  if (!($show_symbolic_direct_inverse_deps || $show_all_deps || $show_all_files_found)) 
    { $show_direct_deps = 1; }

  if (!((defined $output_format) || $show_tree || $show_graphviz)) 
    { $output_format = $output_format_to_formatting{makerules}; }

  if ($show_all_deps || $show_all_files_found) { $find_recursive_deps = 1; }
  if ($find_recursive_deps && (!$show_symbolic_direct_inverse_deps)) { $show_all_deps = 1; }

  $project_dir //= longest_common_path_prefix($filenames);
  $project_dir = normalize_trailing_slash($project_dir);

  if (stdout_is_terminal()) 
    { $wrap_long_lines //= get_terminal_width_in_columns() - 2; }

  if (!length $metadata_cache_filename) { $metadata_cache_filename = undef; }

  register_path_prefixes(getcwd() => PROJECT_PATH_PREFIX_COLOR.'cwd');
  my %colored_dir_aliases = pairmap { $a => PROJECT_PATH_PREFIX_COLOR.$b } %dir_aliases;
  register_path_prefixes(%colored_dir_aliases);
  register_path_prefixes($project_dir => PROJECT_PATH_PREFIX_COLOR.'proj');

  return ($filenames, $invalid_option_indexes, $command_line_option_values);
}

1;
