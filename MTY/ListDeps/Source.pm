#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::ListDeps::Source: class representing a single source file
#
# Copyright 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::ListDeps::Source;

use integer; use warnings; use Exporter qw(import);

use MTY::Common::Common;
use MTY::Common::Strings;
use MTY::Filesystem::Files;
use MTY::Filesystem::FileStats;
use MTY::RegExp::Strings;
use MTY::Display::Colorize;
use MTY::Display::ColorizeErrorsAndWarnings;
use MTY::Display::PrintableSymbols;
use MTY::Display::Tree;
use MTY::Display::Table;
use MTY::Display::DataStructures;
use MTY::Display::TextInABox;
use MTY::System::POSIX;

use MTY::ListDeps::Config;
#pragma end_of_includes

preserve:; our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(SOURCE_FLAG_BINARY SOURCE_FLAG_COMPILABLE SOURCE_FLAG_INCLUDABLE 
     SOURCE_FLAG_INTERPRETED SOURCE_FLAG_NO_DEPS SOURCE_FLAG_PREPROCESSED 
     SOURCE_FLAG_PROGRAM SOURCE_FLAG_INVARIANT_SYMBOLIC_DEPS_TO_FILENAMES
     SOURCE_FLAG_CIRCULAR_DEPS_POSSIBLE 
     read_source_and_instantiate_by_type filename_to_source
     collect_deps_recursively update_all_inverse_deps resolve_all_recursive_deps 
     reconstruct_sources_after_retrieving_from_cache_file filename_of_source 
     prepare_to_store_sources_to_cache_file
     %filename_to_source @sources);

#-----------------------------------------------------------------------------#
# Important global hashes and arrays for all known sources:                   #
#-----------------------------------------------------------------------------#

our %filename_to_source;
our @sources;

#-----------------------------------------------------------------------------#
# Bitflags for the $spec->{flags} field of each source type spec:             #
#-----------------------------------------------------------------------------#

use constant enumbits (
  SOURCE_FLAG_NO_DEPS,                  # file inherently cannot depend on anything else (e.g. fully preprocessed source, etc)
  SOURCE_FLAG_BINARY,                   # source is a binary file format (e.g. executable or shared library) (0 = human readable text format)
  SOURCE_FLAG_COMPILABLE,               # source will be compiled into binary object (C, C++, Java) (0 = interpreted script that doesn't require pre-compilation)
  SOURCE_FLAG_INCLUDABLE,               # source will be compiled into binary object (C, C++, Java) (0 = interpreted script that doesn't require pre-compilation)
  SOURCE_FLAG_PREPROCESSED,             # source is already preprocessed to incorporate all included files
  SOURCE_FLAG_INTERPRETED,              # source is directly executable by an interpreter without separate compilation
  SOURCE_FLAG_PROGRAM,                  # source is for a main executable program (0 = for an include, library, package or module)
  SOURCE_FLAG_INVARIANT_SYMBOLIC_DEPS_TO_FILENAMES, # mapping of symbolic dependency names into filenames is invariant regardless of which source file includes them (Perl has this, but not with C++ "..." double quoted includes
  SOURCE_FLAG_CIRCULAR_DEPS_POSSIBLE,   # circular dependencies are possible, where A includes B, B includes A, but the includes are later in each file to avoid conflicts (C/C++ has this property)
);

our @source_flag_bit_to_name = 
  qw(nodeps binary compilable includable preprocessed interpreted program invariant circular);

sub format_source_flags($) {
  my ($flags) = @_;
  my $out = '';
  for my $i (0..31) {
    if (($flags >> $i) & 1) { $out .= ' ' if length($out); $out .= $source_flag_bit_to_name[$i]; }
  }
  return $out;
}

#
# Instantiate a new generic source object and fill in its common fields.
# This should be called by subclasses at the end of their own constructors,
# or at least once they know enough to provide all of the arguments below:
#
sub new($$$+++$$$$) :method {
  my ($class, $filename, $code, $type, $direct_symbolic_deps, $parent,
    $suffix, $interp, $emacs_mode, $pos_after_last_include) = @_;

  $direct_symbolic_deps //= [ ];
  @$direct_symbolic_deps = sort @$direct_symbolic_deps;

  my $timestamp = get_mtime_of_path($filename);

  if ((defined $pos_after_last_include) && ($pos_after_last_include <= (length $code))) {
    #
    # Search for the start of the next line after the last include statement,
    # since some source type plugins may provide a position that is not at
    # the start of a new line. Start one character before where the plugin
    # claims the include statement ends, in case the provided position was
    # exactly after the newline that terminated that statement (otherwise
    # we would skip an extra line).
    #

    pos($code) = max($pos_after_last_include - 1, 0);
    ($code =~ /$newline_or_end_re/oamsxgc); # set pos to after next NL or at the end
    $pos_after_last_include = pos($code);     
  }

  my $this = {
    filename => $filename,
    timestamp => $timestamp,
    code => $code,
    type => $type,
    suffix => $suffix,
    interp => $interp,
    emacs_mode => $emacs_mode,
    direct_symbolic_deps => $direct_symbolic_deps,
    excluded_external_deps => undef,
    nodeps => ((scalar @$direct_symbolic_deps) == 0) ? 1 : 0,
    direct_deps => undef,
    inverse_deps => undef,
    recursive_deps => undef,
    explicitly_listed => 0,
    pos_after_last_include => $pos_after_last_include,
  };

  return bless $this, $class;
};

#
# Return the actual source code contents of the file represented by this 
# Source instance, either by returning it if it was already read, or by
# reading it from the original file. Returns undef if the file cannot
# be found any longer.
#

sub get_contents(+) :method {
  my ($this) = @_;

  my $code = $this->{code};
  my $filename = $this->{filename};

  if (!defined $code) {
    $code = read_file($filename);
    if (!defined $code) 
      { warning("Cannot read file \"$filename\""); return undef; }
    $this->{code} = $code;
  }

  return $code;
}

#
# Translate the specified file offset into a line (in scalar context)
# or (line, column, offset_of_start_of_line) (in list context):
#
sub offset_to_line(+$) :method  {
  my ($this, $offset) = @_;

  my $code = $this->get_contents();
  my $line_offset_map = $this->{line_offset_map};

  if (!defined $line_offset_map) {
    $line_offset_map = create_line_offset_map($code);
    $this->{$line_offset_map} = $line_offset_map;
  }

  my ($line, $col) = find_line_containing_offset($code, $offset, $line_offset_map);

  return (wantarray ? ($line, $col, $start_offset) : $line);
}

#-----------------------------------------------------------------------------#
# Read each source file, determine which plugin can handle it, and parse it:  #
#-----------------------------------------------------------------------------#

export:; sub read_source_and_instantiate_by_type($;+$) {
  my ($filename, $parent, $override_type) = @_;

  my $fullpath = resolve_path($filename);

  if (!defined $fullpath) {
    warning("Cannot get full path name for file \"$filename\"".
          ((defined $parent) ? ' (included from "'.$parent->{filename}.'")' : '')); 
    return undef; 
  }

  $filename = $fullpath;

  my $source = $filename_to_source{$filename};
  if (defined $source) { return $source; }

  my $code = read_file($filename);

  if (!defined $code) 
    { warning("Cannot read file \"$filename\""); return undef; }

  if (defined $override_type) {
    if (!exists $source_type_to_spec{$override_type})
      { die('Invalid override source type "'.$override_type.'"'); }
    $override_type = $source_type_to_spec{$override_type};
  }

  my ($typespec, $suffix, $interp, $emacs_mode) = (defined $override_type) 
    ? ($override_type, final_suffix_without_dot_of($filename) // '', undef, undef)
    : determine_file_type($code, $filename);

  if (!defined $typespec) 
    { warning("Cannot determine file type of \"$filename\""); return undef; }

  my $plugin = $typespec->{plugin};

  $source = $plugin->new($filename, $code, $typespec, $parent, $suffix, $interp, $emacs_mode);

  if (!defined $source) { return undef; }

  $filename_to_source{$filename} = $source;
  push @sources, $source;

  return $source;
}

#
# Resolve a symbolic dependency into the actual filename
# this source file includes, imports, uses, requires,
# links to or otherwise depends upon. 
#
# The symbolic deps are found when the plugin subclass's 
# constructor parses the input source code, and are kept
# in the class's direct_symbolic_deps array.
#
# Subclasses should override this placeholder method with
# code that resolves the specified symbolic dependency,
# for instance by converting it into a partial file name
# and then searching the appropriate list of directories
# for the first directory that contains a matching file.
#
# For example, with C/C++ code, each included header
# (e.g. #include <my/header/name.h>) would be located
# in one of the directories specified by -Ixxx or 
# implicitly defined (e.g. /usr/include, etc).
#
# For languages like Perl, an imported package name
# (e.g. My::Package::Name) would be converted to a
# partial path stem (e.g. My/Package/Name.pm) and
# then each @INC directory would be checked for it.
#
# Similar approaches are generally appropriate for
# virtually every commonly used language which
# allows the inclusion or importing of other 
# packages; this basic algorithm also works well
# even for resolving dependencies on binaries
# like executables and shared libraries.
#
# It only becomes more difficult in cases where
# the dependency specified by a given source file
# does not directly imply any specific filename,
# but instead requires global knowledge of what
# is provided by every other relevant file in
# the project or even the whole system.
#
# For example, Linux kernel modules lack any
# explicit list of the other module names on
# which they depend (in contrast to shared
# libraries). To resolve their dependencies,
# the symbols exported by all known modules
# are identified, then each undefined symbol
# in each module is checked against this 
# global mapping of symbols to the modules
# which define them.
#
# The ListDeps framework is not presently
# designed to handle this style of dependency
# resolution, although it is possible to do
# so by ensuring lsdeps is first made aware 
# of every relevant module, so a global 
# index can be built before any calls to
# symbolic_dep_to_filename() are made.
#
# However, this precludes running lsdeps
# in the depth-first-search auto-discovery
# mode customarily used to find dependencies
# in most programming languages. As a result,
# if file types which require such global
# knowledge are being processed, the source
# type plugin may wish to require that lsdeps
# will only proceed if every possible module
# is listed on the lsdeps command line,
# rather than only listing the root modules
# to start from.
#

sub resolve_symbolic_dep_to_filename(+$) :method {
  my ($this, $symdep) = @_;
  die('Subclasses should override this method');
}

#
# Resolve the required filename for each symbolic dependency
# identified for this module (in the direct_symbolic_deps array) 
#

#
# Cache of previously resolved symbolic dependencies and their filenames:
#
# Subclasses should only use this cache if the result of the resolution
# is the same regardless of which module required the dependency (for
# instance, in C/C++ code, '#include "abc.h"' (with double quotes) does
# *not* have this property since the directory containing the source
# file which is including "abc.h" is first checked for a file named
# "abc.h", which obviously depends on the directory of that source file).
#
# Source types with these semantics should maintain their own private
# caches, e.g. separately for each directory.
#

noexport:; sub symbolic_dep_to_filename_cache_fill(+$$) {
  my ($cache, $symdep, $consumer) = @_;
  my $filename = $consumer->resolve_symbolic_dep_to_filename($symdep);
  return $filename;
}

our $symbolic_dep_to_filename_cache = MTY::Common::Cache->new(\&symbolic_dep_to_filename_cache_fill, 'symbolic_dep_to_filename');

sub filename_to_source($;$) {
  my ($source, $parent) = @_;

  return $source if (ref $source);

  $source = $filename_to_source{$source} // 
    read_source_and_instantiate_by_type($source, $parent);

  $_[0] = $source if (defined $source);
  return $source;
}

sub filename_of_source($) {
  my ($source) = @_;
  return ((ref $source) ? $source->{filename} : $source);
}

sub resolve_symbolic_deps_to_filenames(+) :method {
  my ($this) = @_;
  my $thisfile = $this->{filename};
  my $deplist = $this->{direct_deps};

  return $deplist if (defined $deplist);

  my $symdeps = $this->{direct_symbolic_deps};
  my $typespec = $this->{type};

  my %filedeps = ( );

  foreach my $symdep (@$symdeps) {
    my $filename = $symbolic_dep_to_filename_cache->get($symdep, $this);

    if (!defined $filename) {
      warning("Cannot resolve symbolic dependency \"$symdep\" into filename; ".
                "assuming \"$thisfile\" does not actually depend on it") if ($enable_warnings);
      next;
    }
    $filedeps{$filename} = 1;
  }

  $deplist = [ sort keys %filedeps ];
  $this->{direct_deps} = $deplist;
  return $deplist;
}

sub do_collect_deps_recursively(++;$$);
noexport:; sub do_collect_deps_recursively(++;$$) {
  my ($sources, $visited, $parent, $level) = @_;
  my $parent_filename = (defined $parent) ? $parent->{filename} : 'none';

  foreach my $source (@$sources) {
    $source = filename_to_source($source, $parent);
    next if (!defined $source);
    next if (exists $visited->{$source});
    $visited->{$source} = 1;
    my $direct_deps = $source->resolve_symbolic_deps_to_filenames();
    do_collect_deps_recursively($direct_deps, $visited, $source, $level+1);
  }
}

sub collect_deps_recursively(+) {
  my ($filenames) = @_;
  my $visited = { };
  #
  # Each filename in the array is converted in place into a class ref,
  # which is what we want when do_collect_deps_recursively calls itself
  # with the direct_deps field as the array, but this is *not* what we
  # want at the top level, since that is the original filenames array
  # in the main program that has to retain the filenames themselves.
  # This is why we allocate a new duplicate array below:
  #
  do_collect_deps_recursively([ @$filenames ], $visited, undef, 0);
}

#
# For each direct dependency D of source S, add a 
# inverse dependency backlink from D back to S.
#
sub update_inverse_deps(+) :method {
  my ($this) = @_;

  my $direct_deps = $this->{direct_deps};

  foreach my $dep (@$direct_deps) {
    $dep = filename_to_source($dep);
    my $invlist = $dep->{inverse_deps};
    if (!defined $invlist) { 
      $invlist = [ ]; 
      $dep->{inverse_deps} = $invlist;
    }
    push @$invlist, $this;
  }
}

sub update_all_inverse_deps() {
  foreach my $source (@sources) 
    { $source->update_inverse_deps(); }
}

sub __resolve_recursive_deps :method {
  my ($this, $recdeps, $visited) = @_;

  return if (exists $visited->{$this});
  $visited->{$this} = 1;
  
  my $direct_deps = $this->{direct_deps};

  foreach my $dep (@$direct_deps) {
    $dep = filename_to_source($dep);
    next if (exists $visited->{$dep});
    $dep->__resolve_recursive_deps($recdeps, $visited);
    push @$recdeps, $dep;
  }

  return $recdeps;
}

sub resolve_recursive_deps(+): method {
  my ($this) = @_;
  my $recursive_deps = [ ];
  my $visited = { };

  $this->__resolve_recursive_deps($recursive_deps, $visited, 0);
  $this->{recursive_deps} = $recursive_deps;
}

sub resolve_all_recursive_deps() {
  foreach my $source (@sources) 
    { $source->resolve_recursive_deps(); }
}

sub get_deps_by_type(+$) :method {
  my ($this, $deptype) = @_;
  return 
    ($deptype == DIRECT_DEPS) ? $this->{direct_deps} : 
    ($deptype == SYMBOLIC_DEPS) ? $this->{direct_symbolic_deps} :
    ($deptype == RECURSIVE_DEPS) ? $this->{recursive_deps} :
    ($deptype == INVERSE_DEPS) ? $this->{inverse_deps} : 
    $this->{direct_symbolic_deps};
}

my $pragma_end_of_includes_re = 
  qr{^ [\ \t]*+ \# pragma [\ \t]++ 
     (?> (?> end_of_ (?> headers | includes)) | hdrstop) 
     [\ \t]*+ \n}oamsx;

sub adjust_end_of_includes_pragma() :method {
  my ($this) = @_;

  my $filename = $this->{filename};
  my $code = $this->{code};
  my $pos_after_last_include = $this->{pos_after_last_include};

  if ((!defined $code) || (!defined $pos_after_last_include)) {
    warning($this->filename.': could not determine line of last include statement; skipping') if ($enable_warnings);
    return undef;
  }

  my $before = substr($code, 0, $pos_after_last_include);
  my $after = substr($code, $pos_after_last_include);
  $before =~ s{$pragma_end_of_includes_re}{}oamsxg;
  $after =~ s{$pragma_end_of_includes_re}{}oamsxg;

  return $before.'#pragma end_of_includes'.NL.$after;
}

noexport:; sub revert_dep_list_refs_to_filenames(+) {
  my ($deplist) = @_;
  return undef if (!defined $deplist);

  my $n = 0;

  foreach my $dep (@$deplist) { 
    next if (!is_object_ref $dep);
    $dep = $dep->{filename};
    $n++;
  }

  return (wantarray ? ($deplist, $n) : $deplist);
}

#
# Prepare to save this object to a Storable file.
# Specifically, the code field is freed (if it
# wasn't freed already), the type field's value
# is replaced with the name of the type rather
# than the original reference to its type spec
# (this avoids recursively storing the plugin's
# type hash, which we obviously know when we
# retrieve the object), and similar adjustments
# to disconnect any other data structures we
# will already have or can easily regenerate.
#
# Subclasses may have their own prepare_to_store
# method, but it must call the superclass method
# below before returning the object.
#
sub prepare_to_store(+) :method {
  my ($this) = @_;

  my $type = $this->{type};
  $type = $type->{type} if (is_hash_ref $type);

  setfields $this,
    type => $type,
    explicitly_listed => 0,
    recursive_deps => undef,
    inverse_deps => undef,
    code => undef,
    line_offset_map => undef;

  if (defined $this->{direct_deps}) 
    { revert_dep_list_refs_to_filenames($this->{direct_deps}); }

  return $this;
}

#
# The reconstruct_after_retrieve() method is called as each
# object is retrieved from the metadata cache file. It should
# first call the superclass reconstruct_after_retrieve() method
# below before doing anything else (and return undef if that
# method returned undef), then it should re-initialize any 
# fields which weren't persistently stored. If any error is
# detected that would make the metadata unusable, the method
# should return undef. This will cause the object to be
# reconstructed from scratch based on actually re-reading
# the source file.
#
sub reconstruct_after_retrieve(+) :method {
  my ($this) = @_;

  my $filename = $this->{filename};

  my $type = $this->{type};
  my $typespec = (is_string $type) ? $source_type_to_spec{$type} : $type;

  if (!defined $typespec) 
    { die("Cannot reconstruct object for '$filename': unknown file type '$type'"); }

  $this->{type} = $typespec;
  $type = $this->{type};

  my $stats = get_file_stats($filename);

  if (!defined $stats) { 
    warning("Cannot check status of '$filename' while loading cached metadata");
    return undef;
  }

  if ($stats->[STAT_MTIME_NS] > $this->{timestamp}) {
    warning('File ', $filename, ' was modified after metadata was cached ('.
            $stats->[STAT_MTIME_NS], ' > ', $this->{timestamp}, ')');
    return undef;
  }

  return $this;
}

sub prepare_to_store_sources_to_cache_file(;+) {
  my ($cache) = @_;
  $cache //= { };

  return $cache if ($disable_deps_cache);

  # if (is_debug) {
  #   foreach my $source (@sources) {
  #     printdebug{NL, print_folder_tab(R.U.'BEFORE prep for store:'.
  #       UX.Y.' '.$source->{filename}), $source, NL};
  #   }
  # }

  my $latest_source_timestamp = 0;

  my $source_metadata = [ ];

  my %processed_filenames = ( );

  foreach my $source (@sources) {
    my $filename = $source->{filename};
    die("! $filename") if (exists $processed_filenames{$filename});
    $processed_filenames{$filename} = $source;
    $metadata_to_store = $source->prepare_to_store($cache);
    set_max($latest_source_timestamp, $metadata_to_store->{timestamp});
    push @$source_metadata, $metadata_to_store;
  }

  $cache->{latest_source_timestamp} = $latest_source_timestamp;
  $cache->{sources} = $source_metadata;

  return $cache;
}

sub reconstruct_sources_after_retrieving_from_cache_file(+) {
  my ($cache) = @_;
  return undef if (!defined $cache);
  
  #
  # Make sure the filename to source mappings are in place
  # before we call each source's reconstruct_after_retrieve()
  # method in case it needs to look up anything by filename:
  #
  my @reconstructed_sources = ( );
  @sources = ( );
  %filename_to_source = ( );

  my $cached_sources = $cache->{sources};
  return undef if (!defined $cached_sources);

  foreach my $source (@$cached_sources) {
    #
    # Save this filename so we know what to re-read if
    # the reconstruct_after_retrieve() method returns
    # null result indicating we should reconstruct
    # the object from scratch:
    #
    my $filename = $source->{filename};
    $source = $source->reconstruct_after_retrieve();
    if (!defined $source) {
      warning("Metadata for $filename could not be retrieved ".
                "or was out of date; reconstructing from source...", NL);
      $source = read_source_and_instantiate_by_type($filename);
      if (!defined $source) {
        warning("Could not reconstruct metadata for $filename from source");
        next;
      }

      push @reconstructed_sources, $source;
    }
    
    push @sources, $source;
    $filename_to_source{$source->{filename}} = $source;
  }

  if ($show_inverse_deps) { update_all_inverse_deps(); }

  if ($find_recursive_deps) { resolve_all_recursive_deps(); }

  # if (is_debug) {
  #   foreach my $source (@sources) {
  #     printdebug{NL, print_folder_tab(G.U.'AFTER retrieve:'.UX.Y.' '.$source->{filename}), $source, NL};
  #   }
  # }

  return \@sources;
}

sub configure($++;+) :method {
  my ($plugin, $command_line_option_values, $filenames, $cache) = @_;

  if ((defined $cache) && (!$disable_deps_cache) && (exists $cache->{sources})) {
    reconstruct_sources_after_retrieving_from_cache_file($cache);
  }
}

# Subclasses should override this if necessary:
sub prepare_to_store_global_data_into_cache_file(++) :method {
  my ($this, $cache) = @_;
  return 1;
}

1;
