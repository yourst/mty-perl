#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::System::Misc
#
# Miscellaneous Linux and POSIX standard functionality
#
# Copyright 2003 - 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::System::Misc;

use integer; use warnings; use Exporter qw(import);

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(get_current_uid_gid_groups get_home_directory get_host_name
     get_terminal_char_dev_path get_user_info get_user_name
     is_user_member_of_group lookup_group_name_from_gid
     lookup_user_name_from_uid);

use MTY::System::POSIX;
use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Filesystem::Files;
use MTY::Common::Cache;
use MTY::Common::Strings;
use MTY::Filesystem::ProcFS;

my $terminal_char_dev_path = undef;

sub get_terminal_char_dev_path(;$) {
  my ($pid) = @_;

  # Just use ctermid(), now (finally!) provided by
  # the POSIX package:
  return POSIX::ctermid();

  if ((!defined $pid) && (defined $terminal_char_dev_path)) {
    # already queried and cached:
    return $terminal_char_dev_path;
  }

  my @stats = read_proc_array($pid // 'self', 'stat');
  die if (!@stats);

  my $devid = $stats[PROC_STAT_TTY];
  if (!$devid) { return undef; } # if we have no console
  my ($major, $minor) = split_major_minor_dev($devid);

  #
  # First try the symlinked char dev node in /dev/char
  # (but not all major and minor numbers are linked here;
  # typically only tty and ttyS devices are present):
  #
  my $devpath = '/dev/char/'.$major.':'.$minor;

  if (dev_node_matches_major_minor_type
        ($devpath, $major, $minor, FILE_TYPE_CHAR_DEV))
    { goto ok; }

  $devpath = '/dev/pts/'.$minor;

  if (dev_node_matches_major_minor_type
        ($devpath, $major, $minor, FILE_TYPE_CHAR_DEV))
    { goto ok; }

  $terminal_char_dev_path = '' if (!defined $pid);
  return undef;

ok:
  $devpath = realpath($devpath);
  $terminal_char_dev_path = $devpath if (!defined $pid);
  return $devpath;
}

my $uid_to_username_cache = MTY::Common::Cache->new
  (sub { return getpwuid($_[1]); }, 'uid_to_username_cache');

my $gid_to_groupname_cache = MTY::Common::Cache->new
  (sub { return getgrgid($_[1]); }, 'gid_to_groupname_cache');

#
# The names (or lack thereof) associated with UIDs and GIDs
# are cached in the %uid_to_username and %gid_to_groupname
# hashes to speed up the common case of repeatedly querying
# the same UID and GID (or a small set of unique UIDs/GIDs),
# since accessing the system's user database (/etc/passwd,
# /etc/group, LDAP, NIS, etc) may be significantly slower.
#
# The cache may contain undefined values for previously queried
# UIDs with names not listed in the user database, which is
# unusual but still allowed (at least on Linux).
#
# This can be detected by checking if the UID or GID is a valid
# key in the hash, yet its corresponding value is undefined;
# in this case we return that undefined value, rather than
# assuming it means we need to query the external user database
# repeatedly without finding a matching name.
#
# This situation typically arises when programs like tar, cp,
# rsync, etc. copy files from another system where those UIDs
# and/or GIDs were mapped to known user names and/or groups,
# yet the local machine only receives the numerical UIDs/GIDs
# and has no knowledge of the original names.
# 
# In this case, the UIDs and GIDs can either lack any name, or 
# may even refer to a totally unrelated name on the local system 
# (which can be a potential security problem - which is why most 
# tools won't set the local file's UID and/or GID unless it maps
# to a name, and/or they will look up the local UID and GID based 
# on the remote name, assuming the file format or network protocol
# includes names for the raw UIDs and GIDs). Unforuntately tar and
# several similar common utilities will still blindly set the UID
# and GID of each file to their numerical values in the archive.
#

sub lookup_user_name_from_uid {
  return $uid_to_username_cache->get(@_);
}

sub lookup_group_name_from_gid {
  return $gid_to_groupname_cache->get(@_);
}

my $current_user_name = undef;

sub get_user_name() {
  if (!defined $current_user_name) {
    $current_user_name = 
      POSIX::cuserid() // 
      $ENV{'USER'} // 
      lookup_user_name_from_uid(geteuid()) // 
      ('(uid='.$UID.')');
  }
  return $current_user_name;
}

my $user_euid = undef;
my $user_egid = undef;
my @user_groups;
my %user_is_member_of_group = ( );

sub get_current_uid_gid_groups() {
  if (!defined $user_euid) {
    $user_euid = geteuid();
    $user_egid = getegid();
    @user_groups = getgroups();

    foreach $gid (@user_groups) 
      { $user_is_member_of_group{$gid} = 1; }
  }

  return ($user_euid, $user_egid, \@groups);
}

INIT {
  $uid_to_username_cache->put(0 => 'root');
  get_current_uid_gid_groups();
};

sub is_user_member_of_group($) {
  my ($gid) = @_;
  return (exists $user_is_member_of_group{$gid}) ? 1 : 0;
}  

my $user_info = undef;

sub get_user_info() {
  if (!defined $user_info) {
    #
    # Note that get_user_info() returns the *effective* uid and gid,
    # not the original real uid and gid. This is important from a
    # security standpoint (especially for setuid or setgid callers).
    # 
    # It also controls the home directory this function returns 
    # (e.g. get_user_info() in "sudo <perl-program> ..." will 
    # return /home/root, not /home/<original-user-invoking-sudo>).
    # This may affect where the caller finds per-user configuration
    # files, since some users may prefer to always use their own
    # config files even if using sudo, rather than root's settings.
    # If this is desired, the caller will need to check this itself.
    #
    my $uid = geteuid();
    my $gid = getegid();

    #
    # These are the fallback values we only use if getpwuid()
    # below can't find the actual user info for our uid in
    # /etc/passwd, LDAP, nscd, or whatever the system uses.
    #
    $user_info = {
      uid => $uid,
      gid => $gid,
      user_name => 'uid-'.$uid,
      full_name => '',
      home_dir => '/home/'.$uid,
      shell => '/bin/sh'
    };

    my @fields = getpwuid($uid);

    if ((scalar @fields) > 0) {
      $user_info->{user_name} = $fields[0];
      $user_info->{full_name} = $fields[6];
      $user_info->{home_dir} = $fields[7],
      $user_info->{shell} = $fields[8];
    }
  }

  return $user_info;
}

#
# As noted for get_user_info(), this is the home directory
# of the current effective user ID, not the original real
# user ID (i.e. whomever ran sudo or su to execute the
# program calling this function). Specifically, this will
# return /home/root within a sudo session.
#
sub get_home_directory() {
  return get_user_info()->{home_dir};
}

my $current_host_name = undef;

my $fqdn_re = qr{^[\w\_\-]+ (\. [\w\_\-])*}oax;

sub get_host_name() {
  if (defined $current_host_name) { return $current_host_name; }

  my @candidates = (
    POSIX::2008::gethostname(),
    $ENV{'HOSTNAME'},
    read_file('/etc/HOSTNAME'));

  # try to find the fully qualified domain name if possible:
  my $best_so_far = undef;
  my $best_score_so_far = 0;

  foreach $n (@candidates) {
    $n = remove_leading_trailing_space_and_undef_if_empty($n);
    my $invalid_as_hostname = (is_empty($n)) || # can't be empty
      ($n =~ /[^\w\_\-\.]/oax) || # chars not permitted in DNS domains or host names
      ($n =~ /^localhost\.?/oaxi); # localhost isn't any more useful than empty
    if ($invalid_as_hostname) { $n = undef; next; }

    my @subdomains = split(/\./, $n);
    my $sdcount = scalar(@subdomains);
    my $tld = ($sdcount >= 3) ? $subdomains[$sdcount-1] : '';

    my $score = length($n) + (scalar(@subdomains) * 10) +
      (($tld =~ /^com|net|org|edu|mil|int|[a-z][a-z]$/oax) ? 1000 : 0) +
        (($tld =~ /^[\w\_\-]+/) ? 100 : 0) + 
          (($tld eq 'localdomain') ? -1100 : 0);
    if ($score >= $best_score_so_far) {
      $best_score_so_far = $score;
      $best_so_far = $n;
    }
  }

  # None of the candidates were acceptable: just use "unknown":
  # (We could try to use the machine's IP address if it has one,
  # but frankly something is probably majorly wrong if it doesn't
  # also have a hostname assigned in that case, so we just give up:
  
  $current_host_name = $best_so_far // 'unknown';
  return $current_host_name;
}

1;
