#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Display::Table
#
# Formatting of tables with automatically sized rows and columns
#
# Copyright 1997 - 2014 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Display::Table;

use integer; use warnings; use Exporter::Lite;

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(TRIM_TO_REMAINING_SPACE_ON_LINE UNLIMITED_WIDTH
     WRAP_TO_REMAINING_SPACE_ON_LINE adjust_max_col_width
     expand_fields_and_columns_in_line format_delimited_table format_table
     prep_to_format_table print_table test_format_table wrap_table_cells);

use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::RegExp::Define;
use MTY::RegExp::Strings;
use MTY::Display::ANSIColorREs;
use MTY::Display::Colorize;
use MTY::Common::Strings;
use MTY::System::POSIX qw(INT_MAX);

my $field_column_markup_re = 
  qr{\% \{ (field|column) (?> \= ([^\}]+))? \}}oax;

my $field_column_markup_nocap_re = 
  qr{\% \{ (?> field | column) [^\}]++ \}}oax;

noexport:; sub expand_fields_and_columns_in_line($;$) {
  my ($line, $field_columns) = @_;

  my $field_id_counter = 0;
  my @field_columns = ( );
  my $prev_field_rel_pos = 0;
  my $prev_markup_abs_end_pos = 0;

  while (my ($op, $id) = ($line =~ /$field_column_markup_re/oax)) {
    if ($op eq 'field') {
      $id //= $field_id_counter;
      $field_id_counter++;
      my $start = $-[0];
      my $end = $+[0];
      
      my $markup_length = $end - $start;
      my $prev_field_rel_pos = $-[0];

      $prev_markup_abs_end_pos = $+[0];

      if ($op eq 'field') { $field_id_counter++; }
    }
  }
}

#
# For each table cell that contains a text string longer than the
# specified maximum width W of its column, split the cell vertically
# into multiple cells, each containing at most W characters, properly
# wrapped at word boundaries. If multple cells in a given row must be
# split, the number of extra rows inserted will be the largest number
# of extra rows needed to split any column in that row; shorter cells
# will have blank cells added to the remaining rows in their columns.
#
# If the maximum width specified for a column is less than zero (W < 0), 
# the column will be truncated to a single line of (-W) printable
# characters instead of wrapping it across multiple lines.
#

use constant {
  UNLIMITED_WIDTH                 => 0,
  WRAP_TO_REMAINING_SPACE_ON_LINE => +(1 << 30),
  TRIM_TO_REMAINING_SPACE_ON_LINE => -(1 << 30),
};

noexport:; sub adjust_max_col_width($$$) {
  my ($w, $n, $remaining_width) = @_;
  $w //= 0;
  $remaining_width //= INT_MAX;
  
  $w = (($w == 0) ? INT_MAX :
    (($w == WRAP_TO_REMAINING_SPACE_ON_LINE) ||
     ($w == TRIM_TO_REMAINING_SPACE_ON_LINE)) ? $remaining_width :
     $w);

  my $trim_instead_of_wrap = 0;
  if ($w < 0) { $trim_instead_of_wrap = 1; $w = -$w; }
  $w = min($w, $n);
  return ($w, $n, $trim_instead_of_wrap);
}

noexport:; sub wrap_table_cells(++;+$$$$) {
  my ($table, $max_col_widths, $lengths, $first_line_prefix, $subsequent_line_prefix, $visible_width, $ignore_newlines) = @_;
  $first_line_prefix //= '';
  $subsequent_line_prefix //= '  ';
  $visible_width //= get_terminal_width_in_columns();
  $ignore_newlines //= 0;

  if (!defined $max_col_widths) { return $table; }

  my @out = ( );
  my @expanded_row_to_orig_row = ( );

  my $longest_in_column = $lengths->[(scalar @$lengths)-1];
  my $column_count = scalar @$longest_in_column;

  while (my ($r, $row) = each @$table) {
    my @new_rows_in_col = ( );

    if (!is_array_ref $row) {
      # Just output this row as a user defined string:
      push @out, $row;
      push @expanded_row_to_orig_row, $r;
      next;
    }
    
    my $max_split_row_count = 1;
    my $cols_in_row = scalar @$row;
    my $total_width_of_columns_so_far = 0;

    while (my ($c, $col) = each @$row) {
      my $remaining_width = max($visible_width - $total_width_of_columns_so_far, 0);
      my ($w, $n, $trim_instead_of_wrap) = adjust_max_col_width($max_col_widths->[$c], printed_length($col // ''), $remaining_width);
      
      my $new_rows = undef;

      if ($n > $w) {
        $new_rows = ($trim_instead_of_wrap) 
          ? [ map { truncate_printed_string($_, $w) } split(/\n/oamsx, $col) ]
          : [ wrap_long_lines($col, $w, ' ', $first_line_prefix, $subsequent_line_prefix) ];
      } else {
        $new_rows = [ $col ];
      }
      set_max($max_split_row_count, scalar(@$new_rows));
      $new_rows_in_col[$c] = $new_rows;
      $total_width_of_columns_so_far += $w;
    }

    if ($max_split_row_count > 1) {
      for (my $rs = 0; $rs < $max_split_row_count; $rs++) {
        push @out, [ map { ($_->[$rs]) // '' } @new_rows_in_col ];
        push @expanded_row_to_orig_row, $r;
        # The code above is faster than the following functionally equivalent code:
        #
        #   my $final_row = [ ];
        #   for (my $c = 0; $c < $cols_in_row; $c++)
        #     { $final_row->[$c] = ($new_rows_in_col[$c]->[$r]) // ''; }
        #   push @out, $final_row;
        #
      }
    } else {
      # No column required more than one row: just include ref to old row
      push @out, $row;
      push @expanded_row_to_orig_row, $r;
    }
  }

  return (\@out, \@expanded_row_to_orig_row);
}

#
# Print the specified array of arrays ($rows[...] = [column1, column2, ...])
# with properly aligned and padded columns so the longest string in each
# column will entirely fit within its respective printed column.
#
sub prep_to_format_table(+;++) {
  my ($rows, $max_col_widths, $clip_above_percentile) = @_;
  my $DEBUG = 0;

  $max_col_widths //= [ ];

  if (is_hash_ref($rows)) 
    { $rows = hash_to_array_of_pairs($rows); }

  my $row_count = scalar(@$rows);

  my @column_length_histograms = ( );

  my @longest_in_column = ( );
  my @lengths = ( );
  prealloc(@lengths, $row_count + 1);

  while (my ($r, $row) = each @$rows) {
    my @col_lengths_in_this_row = ( );

    if (!is_array_ref $row) {
      # Just output this row as a user defined string:
      $lengths[$r] = [ printed_length($row) ];
      next;
    }

    while (my ($c, $col) = each @$row) {
      my ($w, $n, $trim_instead_of_wrap) = adjust_max_col_width($max_col_widths->[$c], printed_length($col // ''), $remaining_width);

      push @col_lengths_in_this_row, $n;
      $longest_in_column[$c] //= 0;
      set_max($longest_in_column[$c], $n);

      if (defined $clip_above_percentile) {
        $column_length_histograms[$c] //= [ ];
        my $histo = $column_length_histograms[$c];

        $histo->[$n] = ($histo->[$n] // 0) + 1;
      }
    }

    $lengths[$r] = \@col_lengths_in_this_row;
  }

  if (defined $clip_above_percentile) {
    while (my ($c, $histo) = each @column_length_histograms) {
      no integer;
      my $count_at_percentile = int($row_count * ($clip_above_percentile / 100.0));
      use integer;
      $count_at_percentile = clipto($count_at_percentile, 0, $row_count);

      my $total_so_far = 0;
      my $clip_at_length = $longest_in_column[$c];
      
      L: while (my ($length, $count) = each @$histo) {
        $total_so_far += ($count // 0);
        if ($total_so_far >= $count_at_percentile) {
          $clip_at_length = $length;
          last L;
        }
      }

      if ($DEBUG) {
        printfd(STDERR, 'Column ', $c, ' length histogram:', NL);
        my $cumulative = 0;
        for (my $i = 0; $i < scalar @$histo; $i++) {
          my $v = $histo->[$i] // 0;
          $cumulative += $v;
          printfd(STDERR, '  '.padstring($i, -5).' => '.padstring($v, -5).' (cumulative '.padstring($cumulative, -5).')'.NL);
        }
        if ($clip_at_length != $longest_in_column[$c]) {
          printfd(STDERR, 'Column '.$c.': longest entry had '.$longest_in_column[$c].
                  ' chars, but clipped to '.$clip_at_length.' chars ('.
                  $clip_above_percentile.' percentile = cumulative count of '.
                  $count_at_percentile.' out of '.$row_count.')'.NL);
        }
      }

      $longest_in_column[$c] = $clip_at_length;
    }
  }

  $lengths[$row_count] = \@longest_in_column;

  if ($DEBUG) {
    printfd(STDERR, "Printed length map:".NL);
    foreach my $row (@lengths) {
      printfd(STDERR, '  ');
      foreach my $col (@$row) {
        printf(STDERR '%-4d ', $col // 0);
      }
      printfd(STDERR, NL);
    }
  }

  return \@lengths;
}

sub format_table(+;%) {
  my ($rows, %options) = @_;

  my ($colseps, $row_prefix, $row_suffix, $alignments,
      $clip_to_length, $lengths, $wrap_above_max_col_widths,
      $first_line_prefix, $subsequent_line_prefix,
      $clip_above_percentile, $return_matrix, 
      $return_lines, $fd) =
    @options{qw(colseps row_prefix row_suffix align clip_to_length
    lengths wrap_above_max_col_widths first_line_prefix
    subsequent_line_prefix clip_above_percentile return_matrix
    return_lines fd)};

  $colseps //= ($return_matrix ? '' : ' ');
  $row_prefix //= '';
  $row_suffix //= NL;
  my ($even_row_prefix, $odd_row_prefix) = 
    (is_array_ref($row_prefix) ? @$row_prefix : ($row_prefix, $row_prefix));

  my ($even_row_suffix, $odd_row_suffix) = 
    (is_array_ref($row_suffix) ? @$row_suffix : ($row_suffix, $row_suffix));

  $alignments //= ALIGN_LEFT;

  if (is_hash_ref($rows)) 
    { $rows = hash_to_array_of_pairs($rows); }

  if (!is_array_ref($colseps)) { $colseps = [ $colseps ]; }

  if (!is_array_ref($alignments)) { $alignments = [ $alignments ]; }

  my $expanded_row_to_orig_row = undef;

  if (defined $wrap_above_max_col_widths) { 
    my $need_recalc = 0;
    foreach my $max_col_width (@$wrap_above_max_col_widths) {
      $need_recalc |= (($max_col_width == WRAP_TO_REMAINING_SPACE_ON_LINE) ||
                       ($max_col_width == TRIM_TO_REMAINING_SPACE_ON_LINE));
    }

    $lengths //= prep_to_format_table($rows, $wrap_above_max_col_widths, $clip_above_percentile);
    ($rows, $expanded_row_to_orig_row) = wrap_table_cells($rows, $wrap_above_max_col_widths, $lengths,
                                                        $first_line_prefix, $subsequent_line_prefix);
  }

  $lengths = prep_to_format_table($rows, $wrap_above_max_col_widths, $clip_above_percentile);

  my $longest_in_column = $lengths->[(scalar @$lengths)-1];
  my $column_count = scalar @$longest_in_column;

  pad_array($alignments, $column_count);

  pad_array($colseps, $column_count);
  my @colsep_lengths = map { printed_length($_) } @$colseps;
  
  my @out = ( );

  my $row_prefix_length = max(printed_length($even_row_prefix), printed_length($odd_row_prefix));
  my $row_suffix_length = max(printed_length($even_row_suffix), printed_length($odd_row_suffix));

  while (my ($r, $row) = each @$rows) {
    my $rowout = [ ];
    my $origrow = (defined $expanded_row_to_orig_row) ? $expanded_row_to_orig_row->[$r] : $r;

    if (!is_array_ref $row) {
      # Just output this row as a user defined string:
      $out[$r] = $row;
      next;
    }

    my $max_col_in_row = (scalar @$row)-1;
    my $col_lengths_in_row = $lengths->[$r];

    my $row_length_in_chars = 0;
    if (!$return_matrix) {
      push @$rowout, (($origrow & 1) ? $odd_row_prefix : $even_row_prefix);
      $row_length_in_chars += $row_prefix_length;
    }

    while (my ($c, $col) = each @$row) {
      my $text = $col // '';
      my $len = $col_lengths_in_row->[$c] // 0;
      my $colout = '';

      if ($c < $max_col_in_row) {
        my $padlen = max($longest_in_column->[$c] - $len, 0);
        my $padding = ' ' x $padlen;
        my $alignment = $alignments->[$c];
        $colout .= 
          ($alignment == ALIGN_LEFT) ? ($text . $padding) :
          ($alignment == ALIGN_RIGHT) ? ($padding . $text) :
          die("Invalid alignment $alignment");
        $row_length_in_chars += $padlen;
      } else {
        #
        # Don't pad the last column, to avoid effectively double spacing every line
        # (due to the insertion of so many column width padding spaces that a single
        # column takes more characters than one line of the current terminal). This
        # typically occurs when a few rows have really long last columns (such as
        # variable length strings like filenames, etc., which traditionally appear 
        # in the last column).
        #
        $colout .= $text;
      }

      $row_length_in_chars += $len;

      if ((!$return_matrix) && ($c < $max_col_in_row)) {
        $colout .= $colseps->[$c];
        $row_length_in_chars += $colsep_lengths[$c];
      }

      push @$rowout, $colout;
    }

    if (!$return_matrix) {
      push @$rowout, (($origrow & 1) ? $odd_row_suffix : $even_row_suffix);
      $row_length_in_chars += $row_suffix_length;
    }

    # if ((defined $clip_to_length) && ($row_length_in_chars > $clip_to_length))
    #  { $rowout = truncate_printed_string($rowout, $clip_to_length); }

    $out[$r] = $rowout;
  }

  if ($return_matrix) { 
    return @out;
  } elsif ($return_lines) {
    return map { (is_array_ref($_)) ? join('', @$_) : $_ } @out;
  } else {
    my $outstr = join('', map { (is_array_ref($_) ? join('', @$_) : $_) } @out);
    if (defined $fd) { 
      printfd($fd, $outstr); return $outstr; 
    } else {
      return $outstr;
    }
  }
}

sub format_delimited_table(+$;%) {
  my ($rows, $delim, %options) = @_;
  return format_table([ map { [ split($delim, $_) ] } @$rows ], %options);
}

sub print_table($+;%) {
  my ($fd, $rows, %options) = @_;
  format_table($rows, (%options, fd => $fd));
}

sub test_format_table() {
  my @std_options = (colseps => ' | ', row_prefix => '<< ', row_suffix => ' >>'.NL, align => [ ALIGN_RIGHT, ALIGN_RIGHT, ALIGN_LEFT ]);

  my $tables_and_options = [
    [
      [
        NL.X.C.U.'First Category:'.X.NL.NL,
        ['first is a really long column which just goes on and on and on...',      'premier',             '1st'],
        ['2nd row, col 1',            'row deux. 2nd col',   'numero trois. column finale'],
        NL.X.C.U.'Second Category:'.X.NL.NL,
        ['third',                     'lucky three',       (join('', map { 'trois triple tres #'.$_.' is the lucky number, ' } 1..15))],
        ['fourth',                    'finale',              'four is more'],
      ],
      [ @std_options, wrap_above_max_col_widths => [ 50, 50, WRAP_TO_REMAINING_SPACE_ON_LINE ] ],
    ],
  ];

  my $other_tables = [
    [
      [
        ['first',        'premier',       '1st'],
        ['second',       'sorry sekond',  '2nd'],
        ['third',        'trois place',   '3'],
        ['fourth',       'finale',        'four is more'],
      ],
      [ @std_options ]
    ],
    [
      [
        ['first'.TAB.       'premier'.TAB.      '1st'],
        ['second'.TAB.      'sorry sekond'.TAB. '2nd'],
        ['third'.TAB.       'trois place'.TAB.  '3'],
        ['fourth'.TAB.      'finale'.TAB.       'four is more'],
      ],
      [ @std_options, colseps => TAB ]
    ],
  ];

#  use DDP; print(STDERR p $tables_and_options);
#  return;

  foreach my $table_and_options (@$tables_and_options) {
    my ($table, $options) = @{$table_and_options};
    prints(NL.NL."================ Table: =================".NL.NL);
    prints('@input = ['.NL);
    prints(join('', map { '  ["'.join('", "', @$_).'"],'.NL } @$table).NL);
    prints(']'.NL.NL);

    my @out_as_matrix = format_table($table, @$options, return_matrix => 1);

    prints('@output = ['.NL);
    prints(join('', map { (is_array_ref($_) ? '  ["'.join('", "', @$_).'"],'.NL : $_) } @out_as_matrix).NL);
    prints(']'.NL.NL);

    my $out = format_table($table, @$options);
    prints('$output = '.NL.$out.NL);

    last;
  }

  return;
}

1;
