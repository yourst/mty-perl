#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Display::Table
#
# Formatting of tables with automatically sized rows and columns
#
# Copyright 1997 - 2014 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Display::Table;

use integer; use warnings; use Exporter::Lite;

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(expand_fields_and_columns_in_line format_delimited_table format_table
     prep_to_format_table print_table test_format_table);

use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::RegExp::Define;
use MTY::RegExp::Strings;
use MTY::Display::ANSIColorREs;
use MTY::Common::Strings;

my $field_column_markup_re = 
  qr{\% \{ (field|column) (?> \= ([^\}]+))? \}}oax;

my $field_column_markup_nocap_re = 
  qr{\% \{ (?> field | column) [^\}]++ \}}oax;

noexport:; sub expand_fields_and_columns_in_line($;$) {
  my ($line, $field_columns) = @_;

  my $field_id_counter = 0;
  my @field_columns = ( );
  my $prev_field_rel_pos = 0;
  my $prev_markup_abs_end_pos = 0;

  while (my ($op, $id) = ($line =~ /$field_column_markup_re/oax)) {
    if ($op eq 'field') {
      $id //= $field_id_counter;
      $field_id_counter++;
      my $start = $-[0];
      my $end = $+[0];
      
      my $markup_length = $end - $start;
      #my $non_markup_length_so_far 
      my $prev_field_rel_pos = $-[0];

      $prev_markup_abs_end_pos = $+[0];

      if ($op eq 'field') { $field_id_counter++; }
    }
  }
}

#
# Print the specified array of arrays ($rows[...] = [column1, column2, ...])
# with properly aligned and padded columns so the longest string in each
# column will entirely fit within its respective printed column.
#
sub prep_to_format_table(+;$) {
  my ($rows, $clip_above_percentile) = @_;
  my $DEBUG = 0;

  if (is_hash_ref($rows)) 
    { $rows = hash_to_array_of_pairs($rows); }

  my $row_count = scalar(@$rows);

  my @column_length_histograms = ( );

  my @longest_in_column = ( );
  my @lengths = ( );
  prealloc(@lengths, $row_count + 1);

  while (my ($r, $row) = each @$rows) {
    my @col_lengths_in_row = ( );

    while (my ($c, $col) = each @$row) {
      my $n = printed_length($col // '');
      $col_lengths_in_row[$c] = $n;

      $longest_in_column[$c] //= 0;
      set_max($longest_in_column[$c], $n);

      if (defined $clip_above_percentile) {
        $column_length_histograms[$c] //= [ ];
        my $histo = $column_length_histograms[$c];

        $histo->[$n] = ($histo->[$n] // 0) + 1;
      }
    }

    $lengths[$r] = \@col_lengths_in_row;
  }

  if (defined $clip_above_percentile) {
    while (my ($c, $histo) = each @column_length_histograms) {
      no integer;
      my $count_at_percentile = int($row_count * ($clip_above_percentile / 100.0));
      use integer;
      $count_at_percentile = clipto($count_at_percentile, 0, $row_count);

      my $total_so_far = 0;
      my $clip_at_length = $longest_in_column[$c];
      
      L: while (my ($length, $count) = each @$histo) {
        $total_so_far += ($count // 0);
        if ($total_so_far >= $count_at_percentile) {
          $clip_at_length = $length;
          last L;
        }
      }

      if ($DEBUG) {
        print(STDERR 'Column '.$c.' length histogram:'.NL);
        my $cumulative = 0;
        for (my $i = 0; $i < scalar @$histo; $i++) {
          my $v = $histo->[$i] // 0;
          $cumulative += $v;
          print(STDERR '  '.padstring($i, -5).' => '.padstring($v, -5).' (cumulative '.padstring($cumulative, -5).')'.NL);
        }
        if ($clip_at_length != $longest_in_column[$c]) {
          print(STDERR 'Column '.$c.': longest entry had '.$longest_in_column[$c].
                  ' chars, but clipped to '.$clip_at_length.' chars ('.
                  $clip_above_percentile.' percentile = cumulative count of '.
                  $count_at_percentile.' out of '.$row_count.')'.NL);
        }
      }

      $longest_in_column[$c] = $clip_at_length;
    }
  }

  $lengths[$row_count] = \@longest_in_column;

  if ($DEBUG) {
    print(STDERR "Printed length map:".NL);
    foreach my $row (@lengths) {
      print(STDERR '  ');
      foreach my $col (@$row) {
        printf(STDERR '%-4d ', $col);
      }
      print(STDERR NL);
    }
  }

  return \@lengths;
}

sub format_table(+;%) {
  my ($rows, %options) = @_;
  my $colseps = $options{colseps} // ' ';
  my $row_prefix = $options{row_prefix} // '';
  my $row_suffix = $options{row_suffix} // NL;
  my $alignments = $options{align} // ALIGN_LEFT;
  my $clip_to_length = $options{clip_to_length};
  my $lengths = $options{lengths};
  my $fd = $options{fd};
  my $clip_above_percentile = $options{clip_above_percentile};

  if (is_hash_ref($rows)) 
    { $rows = hash_to_array_of_pairs($rows); }

  if (!is_array_ref($colseps)) { $colseps = [ $colseps ]; }
  if (!is_array_ref($alignments)) { $alignments = [ $alignments ]; }

  $lengths //= prep_to_format_table($rows, $clip_above_percentile);

  my $longest_in_column = $lengths->[(scalar @$lengths)-1];
  my $column_count = scalar @$longest_in_column;

  pad_array($alignments, $column_count);

  pad_array($colseps, $column_count);
  my @colsep_lengths = map { printed_length($_) } @$colseps;
  
  my @out = ( );

  my $row_prefix_length = printed_length($row_prefix);
  my $row_suffix_length = printed_length($row_suffix);

  while (my ($r, $row) = each @$rows) {
    my $rowout = '';

    my $col_count_in_row = scalar @$row;
    my $col_lengths_in_row = $lengths->[$r];

    my $row_length_in_chars = 0;
    $rowout .= $row_prefix;
    $row_length_in_chars += $row_prefix_length;

    while (my ($c, $col) = each @$row) {
      my $text = $col // '';
      my $len = $col_lengths_in_row->[$c] // 0;
      my $colout = '';

      if ($c < $col_count_in_row-1) {
        my $padlen = max($longest_in_column->[$c] - $len, 0);
        my $padding = ' ' x $padlen;
        my $alignment = $alignments->[$c];
        $colout .= 
          ($alignment == ALIGN_LEFT) ? ($text . $padding) :
          ($alignment == ALIGN_RIGHT) ? ($padding . $text) :
          die("Invalid alignment $alignment");
        $row_length_in_chars += $padlen;
      } else {
        # Don't pad the last column, to avoid effectively double spacing every line
        # just because a few rows have really long last columns (e.g. variable length
        # strings like filenames, etc., which traditionally appear in the last column).
        $colout .= $text;
      }

      $row_length_in_chars += $len;

      $colout .= $colseps->[$c];
      $row_length_in_chars += $colsep_lengths[$c];

      $rowout .= $colout;
    }

    $rowout .= $row_suffix;
    $row_length_in_chars += $row_suffix_length;

    # if ((defined $clip_to_length) && ($row_length_in_chars > $clip_to_length))
    #  { $rowout = truncate_printed_string($rowout, $clip_to_length); }

    $out[$r] = $rowout;
  }

  if (defined $fd) { print($fd join('', @out)); }

  return (wantarray ? @out : (defined wantarray) ? join('', @out) : ( ));
}

sub format_delimited_table(+$;@) {
  my ($rows, $delim, @options) = @_;
  return format_table([ map { [ split($delim, $_) ] } @$rows ], @options);
}

sub print_table($+;@) {
  my ($fd, $rows, @options) = @_;
  format_table($rows, (@options, fd => $fd));
}

sub test_format_table() {
  my $table = [
    ['first',        'premier',       '1st'],
    ['second',       'sorry sekond',  '2nd'],
    ['third',        'trois place',   '3'],
    ['fourth',       'finale',        'four is more'],
  ];

  my $out = format_table($table, colseps => ' | ', row_prefix => '<< ', row_suffix => ' >>'.NL, align => [ ALIGN_RIGHT, ALIGN_RIGHT, ALIGN_LEFT ]);
  print($out);

  my $tab_delim_array = [
    "first\tpremier\t1st",
    "second\tsorry sekond\t2nd",
    "third\ttrois place\t3",
    "fourth\tfinale\tfour is more",
  ];

  $out = format_delimited_table($tab_delim_array, "\t", colseps => ' | ', row_prefix => "<< ", row_suffix => ">>\n", align => [ ALIGN_LEFT, ALIGN_RIGHT, ALIGN_LEFT ]);
  print($out);
}

1;
