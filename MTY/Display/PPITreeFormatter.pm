#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Display::PPITreeFormatter
#
# Use PPI to dump the abstract syntax tree (AST) of Perl source code
#
# Copyright 2014 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Display::PPITreeFormatter;

use integer; use warnings; use Exporter::Lite;

nobundle:; our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($ppi_tree_formatter_simplify_output convert_ppi_subtree_to_printable_tree
     convert_ppi_tree_to_printable_tree dump_printable_tree flatten_ppi_tree
     print_ppi_tree process_ppi_tree_common);

our $ppi_tree_formatter_simplify_output = 1;

use DateTime;

use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Filesystem::Files;
use MTY::Common::Strings;
use MTY::Display::Colorize;
use MTY::Display::ColorizeErrorsAndWarnings;
use MTY::Display::PrintableSymbols;
use MTY::Display::PrintableSymbolTools;
use MTY::Display::TextInABox;
use MTY::Display::Tree;
use MTY::RegExp::Define;
use MTY::RegExp::Tools;
use MTY::RegExp::CxxParser;
use MTY::RegExp::CxxREs;
use MTY::RegExp::PerlRegExpParser;
use MTY::RegExp::PerlSyntax;
use MTY::RegExp::Blocks;
use MTY::RegExp::Strings;
use MTY::RegExp::Numeric;
use MTY::RegExp::Analyzer;

use PPI;
use PPI::Document;
use PPI::Dumper;

my $terminal_columns = 120;
INIT {
  $terminal_width = get_terminal_width_in_columns();
};

noexport:; sub process_ppi_tree_common($$$) {
  my ($node, $parent, $level) = @_;

  my $skip = 0;

	if ($node->isa('PPI::Token::Whitespace') || 
      $node->isa('PPI::Token::Comment')) { 
    return undef;
  }

  my $nodetype = ref($node) // 'undef';

  my $line = '?';
  my $column = '?';
  my $data = undef;
  
  # note: we must call PPI::Document::index_locations() first:
  my $loc = $node->location;
  if ($loc) { $line = $loc->[3]; $column = $loc->[2]; }

  if ($node->isa('PPI::Token')) {
    $data = $node->content // '';
  } elsif ($node->isa('PPI::Structure')) {
    my $start = ($node->start) ? $node->start->content : '';
    my $finish = ($node->finish) ? $node->finish->content : '';
    if ((length($start) + length($finish)) > 0)
      { $data = $start . ' ' . $finish; }
  }

  my $subnode_count = ($node->isa('PPI::Node')) ? scalar(@{$node->{children}}) : 0;

  my $subnodes = ($subnode_count > 0) ? $node->{children} : [ ];

  return ($nodetype, $data, $subnodes, $line, $column);
}

sub flatten_ppi_tree {
	my ($node, $out, $parent, $level) = @_;

  $out //= [ ]; $level //= 0;

  my ($nodetype, $data, $subnodes, $line, $column) = process_ppi_tree_common($node, $parent, $level);

  if (!(defined $nodetype)) { return undef; }

  my $subnode_count = scalar(@{$subnodes});
  my @fields = [ $nodetype, $data, $subnode_count, $level, $line, $column ];
  push @{$out},\@fields;

  foreach my $subnode (@${subnodes}) 
    { flatten_ppi_tree($subnode, $out, $node, $level+1); }

  return $out;
}

my $lineout = 0;

noexport:; sub convert_ppi_subtree_to_printable_tree {
	my ($node, $parent, $level, $rootnode, $filename) = @_;

  $level //= 0;

  my ($nodetype, $data, $subnodes, $line, $column) = process_ppi_tree_common($node, $parent, $level);

  if (!(defined $nodetype)) { return undef; }

  $nodetype = $nodetype 
    =~ s/^PPI:://roamsxg
    =~ s/::/ /roamsxg
    =~ s/^\s++//roamsxg
    =~ s/\s++$//roamsxg;

  $nodetype = lc($nodetype);

  $subnodes //= [ ];

  my $omit_quotes = 0;
  my $omit_equals = 0;

  my $text_color = $C;

  if ($nodetype =~ /^ token \s*+ (.+) $/oax) {
    my $token_type = $1;
    my $is_keyword = (exists $perl_keywords_and_built_in_functions{$data // ''});
    die unless (exists $perl_keywords_and_built_in_functions{'print'});

    my $is_operator = ($token_type =~ /operator/oax);
    my $is_symbol = ($token_type =~ /symbol/oax);
    my $is_word = ($token_type =~ /^word$/oax);

    my $color = 
      ($is_keyword || $is_operator) ? $M :
      ($is_symbol) ? $C :
      ($is_word) ? (($is_keyword) ? $M.$U : $C) :
      $Y;
    
    $omit_quotes |= $is_operator;
    $omit_equals |= $is_operator;
    if ($is_keyword) { $token_type = 'keyword'; }
    #$omit_quotes = ($token_type =~ /symbol|word$/oax) ? 1 : 0;
    $text_color = ($is_keyword|$is_operator) ? $M : 
      (($token_type =~ /symbol|^word$/oax) ? $C : $W);
    $nodetype = $color.$token_type.$X;

  } elsif ($nodetype =~ /^ statement \s*+ (.+) $/oax) {
    $nodetype = $G.(is_there($1) ? $1 : $nodetype);
    $omit_quotes = 1;
  } elsif ($nodetype =~ /^ structure \s*+ (.+) $/oax) {
    my $start = ($node->start) ? $node->start->content : '';
    my $finish = ($node->finish) ? $node->finish->content : '';

    $nodetype = $C.$start.' '.$U.(is_there($1) ? $1 : $nodetype).$UX.' '.$finish;
    $omit_quotes = 1;
    $omit_equals = 1;
    if ((length($start) + length($finish)) > 0) { $data = ''; }
  } elsif ($nodetype =~ /^ document /oax) {
    $nodetype = $C.$U.($filename // '(input file)').$UX;
    $omit_quotes = 1;
  } else {
    $nodetype = $M.$nodetype;
  }

  if (is_there($data) && (!$omit_quotes))
    { $data = format_quoted($text_color.special_chars_to_printable_symbols(substr($data, 0, 80), $text_color, $R)); }
  
  # this is automatically concatenated into a single string by print_tree():

  my $line_and_col_bg_color = 
    ((($lineout % 2) == 0) ? bg_color_rgb(32, 32, 32) : bg_color_rgb(20, 20, 20));

  my $special_line_and_col_bg_color = bg_color_rgb(64, 32, 48);

  my $line_prefix =
    fg_color_rgb(56, 96, 72).' '.down_arrow_tri.fg_color_rgb(84, 144, 108).padstring($line, -5);
  # fg_color_rgb(56, 96, 72).' '.down_arrow_tri.fg_color_rgb(112, 192, 144).padstring($line, -5).

  my $col_prefix =
    fg_color_rgb(56, 72, 96).' '.arrow_tri.fg_color_rgb(84, 108, 144).padstring($column, -3);
  # fg_color_rgb(56, 72, 96).' '.arrow_tri.fg_color_rgb(112, 144, 192).padstring($column, -3).

  my @info = (
    [ TREE_CMD_PREFIX, $line_and_col_bg_color.$line_prefix.$col_prefix.' '.$X ],
    $nodetype,
    (is_there($data) ? ($omit_equals ? ' ' : ($X.$K.' = '.$X)) : ''),
    $data // '',
    $X);

  $lineout++;

  my @printable_tree_node = (\@info);
  
  my $subnode_count = scalar @$subnodes;
  
  my $prev_printable_tree_node = undef;
    
  foreach my $subnode (@${subnodes}) {
    next if (!defined $subnode);
    my $r = convert_ppi_subtree_to_printable_tree($subnode, $node, $level+1, $lineout); 
    #
    # Simplify the output to make it more readable where this makes sense:
    # - a list of repeated pairs of (anything, operator, anything, operator, ...)
    # - multiple consecutive repeats of the same node type without subnodes
    #
    next if (!defined $r);

    my $subinfo = $r->[0];
    my $subtype = $subinfo->[1];
    my $subdata = $subinfo->[3];
    my $prev_printable_tree_node_info = (defined $prev_printable_tree_node) 
      ? $prev_printable_tree_node->[0] : undef;
    
    if ((defined $prev_printable_tree_node_info) && ($subtype =~ /operator/) && 
          ($subdata eq ',' || $subdata eq '=>' || $subdata eq '.') &&
            (scalar(@$r)) == 1) {
      # don't reprint the line and column info: use the first node's info
      splice(@{$subinfo}, 0, 5);
      push @{$prev_printable_tree_node_info},
        $M.'  '.dotted_vert_bar_4_dots.'  ',
        @{$subinfo};
      # don't repeat until we've accumulated the next operator and its operand:
      $prev_printable_tree_node_info->[1] = $special_line_and_col_bg_color;
      $prev_printable_tree_node = undef;
    } elsif ((defined $prev_printable_tree_node) && 
               ($subtype eq $prev_printable_tree_node_info->[0]) &&
               (scalar(@$prev_printable_tree_node) == 1) &&
               (scalar(@$r) == 1)) { 
      # don't reprint the line and column info: use the first node's info
      splice(@{$subinfo}, 0, 5);
      push @{$prev_printable_tree_node_info},
        $M.'  '.dotted_vert_bar_4_dots.'  ',
        $subinfo->[2];
      $prev_printable_tree_node_info->[1] = $special_line_and_col_bg_color;
    } else {
      push @printable_tree_node,$r;
      $prev_printable_tree_node = $r;
    }
  }

  return \@printable_tree_node;
}

sub convert_ppi_tree_to_printable_tree($;$$) {
  my ($rootnode, $filename, $simplify_output) = @_;


  $rootnode->index_locations();

  $lineout = 0;
  return convert_ppi_subtree_to_printable_tree
    ($rootnode, undef, 0, $rootnode, ($filename // '(input file)'), 
     ($simplify_output // $ppi_tree_formatter_simplify_output));
}

sub print_ppi_tree($;$$$@) {
  my $rootnode = shift;
  my $filename = shift // '(input file)';
  my $outfd = shift // STDOUT;
  my $simplify_output = shift // $ppi_tree_formatter_simplify_output;

  my $printable_tree = convert_ppi_tree_to_printable_tree
    ($rootnode, $filename, $simplify_output);

  print_tree($printable_tree, $outfd, @_);
}

noexport:; sub dump_printable_tree {
  my ($node, $level) = @_;

  $level //= 0;

  print('  ' x $level);

  my $is_array = ((ref $node) eq 'ARRAY');

  if ($is_array) {
    my $n = scalar(@$node);
    print($node->[0]);
    print($R.' (#'.($n-1).')') if ($n > 1);
    print($X.NL);
    for (my $i = 1; $i < $n; $i++) {
      my $subnode = $node->[$i];
      dump_printable_tree($subnode, $level+1);
    }
  } else {
    print(($node // '<undef>').NL);
  }
}

1;
