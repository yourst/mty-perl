#!/usr/bin/perl -w
# -*- cperl -*-
#
# Display data structures in text format (MTY::Display::DataStructures)
#
# Copyright 2003 - 2014 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Display::DataStructures;

use integer; use warnings; use Exporter::Lite;

nobundle:; our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(format_args format_data_structure_tree_node format_scalar format_struct
     format_var print_var);

use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Common::Strings;
use MTY::Display::PrintableSymbols;
use MTY::Display::PrintableSymbolTools;
use MTY::Display::ANSIColorREs;

use MTY::Display::Colorize;
use MTY::Display::TextInABox;
use MTY::Display::Tree;

use Scalar::Util qw(blessed isdual refaddr reftype tainted isweak isvstring looks_like_number openhandle);
use List::Util;
use Hash::Util;
use List::Util qw(reduce any all none notall first sum0 pairgrep pairfirst pairmap pairs pairkeys pairvalues); # qw(max min)
# use List::MoreUtils qw(firstidx lastidx insert_after insert_after_string indexes firstval lastval pairwise each_array each_arrayref natatime uniq minmax); # qw(true false apply before before_incl after after_incl part)
# use Hash::MoreUtils qw(slice slice_def slice_exists slice_grep hashsort safe_reverse);
# use String::Util qw(crunch hascontent nocontent trim ltrim rtrim define unquote no_space equndef neundef ords deords crunchlines);
#pragma end_of_includes

my %ref_type_to_color_and_sigil = (
  '' => $G.'$',
  'SCALAR' => $G.'$',
  'ARRAY' => $Y.'@',
  'HASH' => $C.'%',
  'REF' => $M.'\\',
  'CODE' => $R.'&',
  'Regexp' => $B.'qr/',
  'GLOB' => $W.'*',
  'IO' => $W.'*IO:',
);

noexport:; sub format_scalar($) {
  my ($v) = @_;

  return (!defined $v) ? $R.'<undef>'.$X :
    ($v eq '') ? $B.'<empty>'.$X :
    (is_numeric($v)) ? $v : 
      format_chunk($v);
  #format_chunk(strip_ansi_console_escape_codes($v));
}

sub format_var($+) {
  my ($name, $obj) = @_;

  my $reftype = ref $obj;
  my $isref = ((length $reftype) > 0) ? 1 : 0;
  if (($reftype eq 'GLOB') && (defined *$obj{IO})) { $reftype = 'IO'; }

  my $out = '';
  if (defined $name) {
    $out .= ($ref_type_to_color_and_sigil{$reftype} // $R.'<'.$reftype.'>').$name;
    if (isdual($obj)) { $out .= $B.' (dual-$/#)'.$K; }
    if (tainted($obj)) { $out .= $R.$U.' (TAINTED)'.$UX.$K; }
  }

  my $op = (defined $name) ? 
    ($isref ? $M.' '.long_bold_right_arrow.' ' : $B.' = ') : ' ';

  if (!$isref) {
    $out .= $op.format_scalar($obj);
  } elsif ($reftype eq 'SCALAR') {
    $out .= $op.format_scalar($$obj);
  } elsif ($reftype eq 'ARRAY') {
    $out .= $K.' (#'.$B.scalar(@$obj).$K.')'.$op.$K.'[';
    $out .= join($K.', ', map { format_scalar($_); } @$obj);
    $out .= $K.']';
  } elsif ($reftype eq 'HASH') {
    $out .= $K.' (#'.$B.scalar(keys %$obj).$K.')'.$op.$K.'{';
    my $i = 0;
    while (my ($key, $value) = each %$obj) {
      $out .= $K.', ' if ($i++ > 0);
      $out .= format_quoted($Y.$key).$B.' '.double_horiz_bars.arrow_tri.
        ' '.$K.format_scalar($value);
    }
    $out .= $K.'}';
  } elsif ($reftype eq 'REF') {
    $out .= $op.$M.'ref '.sprintf('0x%x', refaddr($$obj));
  } elsif ($reftype eq 'CODE') {
    $out .= $R.'sub '.$U.$name.$UX.$K.$op.$K.'{ ... }';
  } else {
    $out .= $K.$op.$X.$$obj;
  }

  $out .= $X;

  return $out;
}

sub print_var($+;$) {
  my ($name, $obj, $fd) = @_;

  $fd //= STDOUT;
  printfd($fd, format_var($name, $obj).NL);
  return $obj;
}

#1;

###END__

#my @typeid_to_format_type_func = ( 

sub format_data_structure_tree_node {
  my ($v, $objname) = @_;
  $objname //= '';
  
  my $label = [ ];
  my $node = [ $label ];
  
  my $type = typeof $v;
  
  if ($type == SCALAR) {
    my $isnum = is_numeric($v);
    my $isstr = is_string($v);

    push @$label,
      [ TREE_CMD_SYMBOL, $B.($isnum ? large_pound_sign : left_quote.right_quote) ],
      (!defined $v) ? $R.'<undef>'.$X :
      (!length($v)) ? $B.'<empty>'.$X :
      is_numeric($v) ? $v : 
      format_chunk($v);
  } elsif ($type == SCALAR_REF) {
    
  } elsif ($type == ARRAY_REF) {
    push @$label,
      [ TREE_CMD_SYMBOL, Y_2_3.'['.rgbfgY.'@'.Y_2_3.']' ];
    my $i = 0;
    foreach $elem (@$v) {
      my $elem_node = format_data_structure_tree_node($elem, '['.$i.']');
      push @$node, $elem_node;
      $i++;
    }

    #$out .= $K.' (#'.$B.sizeof($obj).$K.')'.$op.$K.'[';
    #$out .= join($K.', ', map { format_scalar($_); } @$obj);
    #$out .= $K.']';

  } elsif ($type == HASH_REF) {

  } elsif ($type == REF_REF) {
  } elsif ($type == REGEXP_REF) {

  } elsif ($type == CODE_REF) {

  }

  return $node;
  
}

sub format_struct {
  return tree_to_text(format_data_structure_tree_node(@_));
}

sub format_args {
  my ($package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext) = caller 1;

  return '['.$filename.':'.$line.']: '.$package.'::'.$subroutine.'('.join(', ', map { $_ // '<undef>' } @_).') [#'.(scalar @_).' args]';
}

1;
