#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Display::DataStructures
#
# Powerful tree based visual formatting of all Perl data 
# types arranged into arbitrarily complex data flow graphs
#
# Copyright 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Display::DataStructures;

use integer; use warnings; use Exporter qw(import);

use MTY::Common::Common;
use MTY::Common::Strings;
use MTY::Common::Hashes;
use MTY::Common::PrintDebug;
use MTY::Common::Symbols;
use MTY::RegExp::Strings;
use MTY::RegExp::Blocks;
use MTY::RegExp::PerlSyntax;
use MTY::Display::ANSIColorREs;
use MTY::Display::Colorize;
use MTY::Display::ColorizeErrorsAndWarnings;
use MTY::Display::PrintableSymbols;
use MTY::Display::PrintableSymbolTools;
use MTY::Display::StringFormats;
use MTY::Display::Tree;
use MTY::Display::Table;
use MTY::Display::TextInABox;
use MTY::Filesystem::Files;
use MTY::Filesystem::ProcFS;
use MTY::System::POSIX;

use re qw(is_regexp regexp_pattern regnames);
use Hash::Util qw(bucket_info bucket_stats bucket_array hashref_locked hidden_ref_keys legal_ref_keys hash_value hash_seed hash_traversal_mask);
#pragma end_of_includes

binmode STDOUT, ':utf8';
binmode STDERR, ':utf8';

preserve:; our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(format_data_as_tree format_data print_data pp);

#
# Default settings for Display::DataStructures package:
# These may be changed using e.g.:
#
#   use MTY::Display::DataStructures;
#   MTY::Display::DataStructures::default_xxx = 123;
#
# If the corresponding options are specified when the
# pp() functions or related functions are invoked, the
# caller's settings will take priority over these defaults.
#
our $default_show_addresses = 1;
our $default_strip_ansi_console_codes = 1;
our $default_strip_unicode = 0;
our $default_read_line_from_source_to_create_title = 1;
our $default_always_print_caller = 1;
our $default_show_hash_details = 1;
our $default_show_extensive_hash_details = 1;
our $default_max_depth = INT_MAX;
our $default_one_line_array_max_length = 12;
our $default_one_line_hash_max_length = 6;
our $default_max_string_length = 80;
our $default_max_subtree_items = undef;
our $default_include_folder_tab_with_title_before_tree = 1;

#
# Colors for numerous types of information:
#
use constant {
  light_bg_color => bg_color_rgb(32, 32, 32),
  visited_light_bg_color => bg_color_rgb(32, 32, 32),
  referenced_light_bg_color => bg_color_rgb(32, 64, 32),

  visited_index_color => ORANGE,
  visited_addr_color => fg_color_rgb(128, 192, 255),

  referenced_index_color    => fg_color_rgb(180, 255, 0),
  referenced_refcount_color => fg_color_rgb(192, 128, 255),
  referenced_addr_color => fg_color_rgb(128, 192, 255),

  visited_refcount_color => fg_color_rgb(255, 128, 192),

  normal_tree_branch_color => fg_color_rgb(96, 32, 128),
  ref_tree_branch_color => fg_color_rgb(236, 64, 112),

  at_sign_color => fg_color_rgb(128, 128, 128),
  referenced_at_sign_color => fg_color_rgb(192, 192, 192),

  undef_addr_color => fg_color_rgb(216, 180, 140),

  vert_separator => X.fg_color_rgb(64, 96, 192).long_narrow_vert_bar.' '.X,

  undef_color => fg_color_rgb(248, 96, 80),

  top_level_variable_name_color => fg_color_rgb(80, 255, 144),

  scalar_color => fg_color_rgb(255, 64, 160),
  string_color => fg_color_rgb(80, 192, 255),
  scalar_string_dual_color => fg_color_rgb(206, 158, 255),
  dual_color => fg_color_rgb(206, 158, 255),
  glob_color => fg_color_rgb(255, 128, 64),
  blessed_color => fg_color_rgb(180, 192, 255),

  ref_color => fg_color_rgb(236, 110, 140),
  array_color => fg_color_rgb(255, 255, 64),
  hash_color => fg_color_rgb(92, 220, 198),

  hash_arrow_color => fg_color_rgb(48, 216, 140),
};

use constant {
  dark_bg_color => scale_rgb_bg(light_bg_color, RATIO_2_3),
  visited_dark_bg_color => scale_rgb_bg(visited_light_bg_color, RATIO_2_3),
  referenced_dark_bg_color => scale_rgb_bg(referenced_light_bg_color, RATIO_3_4),

  normal_index_color => scale_rgb_fg(fg_color_rgb(160, 255, 0), 0.4),
  normal_addr_color => scale_rgb_fg(visited_addr_color, RATIO_3_4),

  # visited_at_sign_color => scale_rgb_fg(at_sign_color, RATIO_1_2),
  # visited_addr_color => scale_rgb_fg(normal_addr_color, RATIO_1_2),

  visited_tree_branch_color => scale_rgb_fg(normal_tree_branch_color, RATIO_3_4),

  referenced_index_medium_color => scale_rgb_fg(referenced_index_color, RATIO_2_3),
  referenced_index_dark_color => scale_rgb_fg(referenced_index_color, RATIO_1_2),

  referenced_refcount_medium_color => scale_rgb_fg(referenced_refcount_color, RATIO_3_4),
  referenced_refcount_dark_color   => scale_rgb_fg(referenced_refcount_color, RATIO_2_3),

  visited_refcount_medium_color => scale_rgb_fg(visited_refcount_color, RATIO_3_4),
  visited_refcount_dark_color   => scale_rgb_fg(visited_refcount_color, RATIO_2_3),

  top_level_variable_name_dark_color => scale_rgb_fg(top_level_variable_name_color, RATIO_2_3),

  scalar_dark_color => scale_rgb_fg(scalar_color, RATIO_2_3),
  string_dark_color => scale_rgb_fg(string_color, RATIO_2_3),
  scalar_string_dual_dark_color => scale_rgb_fg(scalar_string_dual_color, RATIO_2_3),
  dual_dark_color => scale_rgb_fg(dual_color, RATIO_2_3),
  glob_dark_color => scale_rgb_fg(glob_color, RATIO_2_3),
  ref_dark_color => scale_rgb_fg(ref_color, RATIO_2_3),
  array_dark_color => scale_rgb_fg(array_color, 0.55),
  hash_dark_color => scale_rgb_fg(hash_color, RATIO_1_2),
};

use constant {
  normal_index_color_and_symbol => normal_index_color.' '.' '.' ',
  visited_index_color_and_symbol => visited_index_color.' '.left_arrow_open_tri.' ',
  referenced_index_color_and_symbol => referenced_index_color.' '.arrow_tri.' ',

  # hash_arrow => hash_arrow_color.' '.dashed_horiz_bar_2_dashes.large_arrow_barbed.' ',
  hash_arrow => scale_rgb_fg(hash_arrow_color, RATIO_2_3).' '.heavy_dashed_horiz_bar_2_dashes.hash_arrow_color.arrow_barbed.nbsp, #' ',

  three_left_warning_brackets => 
    fg_color_rgb(128, 64, 0).bold_left_angle_bracket.
    fg_color_rgb(192, 96, 0).alt_bold_left_angle_bracket.
    fg_color_rgb(255, 128,0).extra_bold_left_angle_bracket,
  
  three_right_warning_brackets => 
    fg_color_rgb(255, 128,0).extra_bold_right_angle_bracket.
    fg_color_rgb(192, 96, 0).alt_bold_right_angle_bracket.
    fg_color_rgb(128, 64, 0).bold_right_angle_bracket
};

use constant {
  tree_branch_style => 'rounded',
};

noexport:; use constant enum (
  PREFIX_LABEL_SLOT_command,
  PREFIX_LABEL_SLOT_INDEX_COLOR_SYM,
  PREFIX_LABEL_SLOT_INDEX,
  PREFIX_LABEL_SLOT_REFCOUNT_COLOR,
  PREFIX_LABEL_SLOT_REFCOUNT,
  PREFIX_LABEL_SLOT_REFCOUNT_SYM,
  PREFIX_LABEL_SLOT_ADDR_COLOR_SYM,
  PREFIX_LABEL_SLOT_ADDR,
  PREFIX_LABEL_SLOT_ENDCAP,
);

use constant {
  referenced_refcount_color_and_symbol_before => \(' '.referenced_refcount_medium_color.counterclockwise_curved_arrow.' '.referenced_refcount_color.' '),
  referenced_refcount_symbol_after => \(referenced_refcount_dark_color.medium_x_lower.' '),

  visited_refcount_color_and_symbol_before => \(' '.visited_refcount_medium_color.counterclockwise_curved_arrow.' '.visited_refcount_color.' '),
  visited_refcount_symbol_after => \(visited_refcount_dark_color.medium_x_lower.' '),

  normal_addr_color_and_symbol => \(scale_rgb_fg(normal_addr_color, RATIO_1_2).' '.large_at_sign.' '.normal_addr_color),
  visited_addr_color_and_symbol => \(scale_rgb_fg(visited_addr_color, RATIO_1_2).' '.large_at_sign.' '.visited_addr_color),
  referenced_addr_color_and_symbol => \(scale_rgb_fg(referenced_addr_color, RATIO_1_2).' '.large_at_sign.' '.referenced_addr_color),

  null_address_label => fg_color_rgb(255,32,32).x_signed.' '.R.U.'null'.UX.X, # R.x_signed.' '.U.'null'.UX.X,
  prefix_label_endcap => \(X.K.vert_separator.X),
};


use constant {
  normal_background_color_even_odd_prefix_tree_cmd => [ 
    TREE_CMD_EVEN_ODD_PREFIX, 
    light_bg_color,
    dark_bg_color,
  ],

  visited_background_color_even_odd_prefix_tree_cmd => [
    TREE_CMD_EVEN_ODD_PREFIX, 
    visited_light_bg_color,
    visited_dark_bg_color,
  ],

  referenced_background_color_even_odd_prefix_tree_cmd => [
    TREE_CMD_EVEN_ODD_PREFIX, 
    referenced_light_bg_color,
    referenced_dark_bg_color,
  ],

  root_color_and_symbol_prefix_tree_cmd => [
    TREE_CMD_PREFIX, 
    # .LIGHTBLUE.' '.large_square_root_symbol.LIGHTBLUE_3_4,
    bg_color_rgb(16, 40, 92),
  ],

  visited_branch_color_tree_cmd => [
    TREE_CMD_SUB_BRANCH_COLOR, visited_tree_branch_color ],

  normal_branch_style_tree_cmd =>
    [ TREE_CMD_SUB_BRANCH_STYLE, tree_branch_style ],

  object_branch_style_tree_cmd => 
    [ TREE_CMD_SUB_BRANCH_STYLE, 'thick' ],

  visited_branch_style_tree_cmd =>
    [ TREE_CMD_SUB_BRANCH_STYLE, tree_branch_style ],

  visited_branch_dashed_tree_cmd =>
    [ TREE_CMD_BRANCH_DASHED, 1 ],

  ref_branch_style_tree_cmd => 
    [ TREE_CMD_SUB_BRANCH_STYLE, tree_branch_style ],

  vert_separator_prefix_tree_cmd =>
    [ TREE_CMD_PREFIX, vert_separator ],
};

use constant {
  duplicated_label_prefix => 
    (PURPLE.' '.double_left_angle_bracket.PURPLE.
    counterclockwise_curved_arrow.' '.PURPLE.
    'same as '.sharp_sign.SKYBLUE),

  duplicated_label_suffix => 
    (PURPLE.double_right_angle_bracket.' '),
};

use constant {
  scalar_type_tree_symbol => G.large_pound_sign,
  string_type_tree_symbol => C.large_dollar_sign,
  dual_type_tree_symbol => dual_color.yin_yang,
  # Character 0x252c is a box drawing join symbol that looks like a 'T':
  ref_type_tree_symbol => ref_color.chr(0x252c).large_arrow_barbed,
  array_type_tree_symbol => array_color.large_at_sign,
  hash_type_tree_symbol => hash_color.large_percent_sign,
  code_type_tree_symbol => W_3_4.large_ampersand_sign,
  regexp_type_tree_symbol => ORANGE.rx_symbol,
};

my @type_to_symbol = (
  undef_color.box_with_right_slash,  # UNDEF
  scalar_type_tree_symbol,  # SCALAR
  string_type_tree_symbol,  # STRING
  dual_type_tree_symbol.' ',  # DUAL
  ref_type_tree_symbol,  # REF_REF
  ref_type_tree_symbol,  # SCALAR_REF
  ref_type_tree_symbol,  # STRING_REF
  ref_type_tree_symbol,  # DUAL_REF
  array_type_tree_symbol,  # ARRAY_REF
  hash_type_tree_symbol,  # HASH_REF
  code_type_tree_symbol,  # CODE_REF
  regexp_type_tree_symbol.' ',  # REGEXP_REF
  blessed_color.star.' ',  # BLESSED_REF
  glob_color.eight_point_asterisk,  # GLOB_REF
  ORANGE.roman_numeral_l,  # LVALUE_REF
  B.deg_f,  # FORMAT_REF
  M.'IO',  # IO_REF
  G.roman_numeral_v,  # VSTRING_REF
);

my @type_to_symbol_tree_cmd = map { [ TREE_CMD_SYMBOL, $_ ] } @type_to_symbol;

my @type_to_visited_symbol_tree_cmd = map {
  [ TREE_CMD_SYMBOL, scale_rgb_fg_in_string($_->[1], RATIO_2_3) ];
} (@type_to_symbol_tree_cmd);

#
# These are the colors of the *sub-branches* of the specified type of node,
# so if the node has no sub-nodes, this color will never be used (as is the
# case with scalars, except for references).
#
my @type_to_branch_color_tree_cmd = map { [ TREE_CMD_SUB_BRANCH_COLOR, $_ ] } (
  ((undef) x 4), # UNDEF SCALAR STRING DUAL
  ref_dark_color, # REF_REF
  ((ref_dark_color) x 3), # SCALAR_REF STRING_REF DUAL_REF
  array_dark_color,  # ARRAY_REF
  scale_rgb_fg(hash_dark_color, RATIO_9_10),  # HASH_REF
  K_2_3,  # CODE_REF
  PINK_2_3.rx_symbol,  # REGEXP_REF
  W_2_3,  # BLESSED_REF
  glob_dark_color,  # GLOB_REF
  ORANGE_2_3,  # LVALUE_REF
  B_2_3,  # FORMAT_REF
  M_2_3,  # IO_REF
  G_2_3,  # VSTRING_REF
);

my @type_to_branch_style_tree_cmd = 
  map { (defined $_) ? [ TREE_CMD_SUB_BRANCH_STYLE, $_ ] : $_ } sparse_array(
    DUAL, 'double',
    HASH_REF, 'double',
    ARRAY_REF, 'rounded',
    CODE_REF, 'thick',
    GLOB_REF, 'thick',
    REGEXP_REF, 'rounded',
    SCALAR_REF, 'rounded',
    STRING_REF, 'rounded',
    DUAL_REF, 'rounded',
    REF_REF, 'rounded',
  );

my @type_to_visited_branch_color_tree_cmd = map { [ 
    TREE_CMD_BRANCH_COLOR, 
    scale_rgb_fg($_->[1] // normal_tree_branch_color, RATIO_1_2) 
  ] } (@type_to_branch_color_tree_cmd);

#
# These bitmasks go in the flags field of the context array:
#
noexport:; use constant enumbits (
  DDS_OPTION_SINGLE_LINE,
  DDS_OPTION_SHOW_ADDRESSES,
  DDS_OPTION_STRIP_ANSI_CONSOLE_STRINGS,
  DDS_OPTION_STRIP_UNICODE_STRINGS,
  DDS_OPTION_READ_SOURCE_TO_MAKE_TITLE_FOR_CALLER,
  DDS_OPTION_ALWAYS_PRINT_CALLER,
  DDS_OPTION_HASH_DETAILS,
  DDS_OPTION_EXTENSIVE_HASH_DETAILS,
);

noexport:; use constant {
  FORMAT_REF_PREFIX => '\\',
};

my %depth_warning_text_for_depth = ( );

#
# Prepare a pre-formatted pseudo node for cases where the
# recursion has exceeded the user defined depth limit (if
# this is specified). These warning message nodes are only
# generated once and then returned from a cache indexed
# by the depth in question.
#
sub get_exceeded_max_depth_warning($) {
  my ($max_depth) = @_;
        
  my $text = $depth_warning_text_for_depth->{$max_depth};
  return $text if (defined $text);

  $text = 
    three_left_warning_brackets.
    Y.' '.warning_sign.' '.U.
    'WARNING:'.UX.' '.
    R.'Excessive depth of '.ORANGE.$max_depth.' '.
    three_right_warning_brackets;

  $depth_warning_text_for_depth->{$max_depth} = $text;
  return $text;
}

#
# These are the elements in the @context array ref that's passed to each
# recursive invocation of format_xxx() handlers as well as format_anything().
#
# Each field listed below contains global data or references that remain
# constant throughout the recursion and thus would be wasteful to repeatedly
# push onto the stack.
#
# The visited, next_index, index_to_tree_node, index_ref_counts, etc. fields
# are references to the tracking arrays and hashes used to detect cycles and
# previously seen data references. Technically these structures *are* updated
# during recursion, although the references to them remain constant, except
# for the next_index field that's a normal integer which must be unique for
# all nodes in the data graph.
#
# The remaining fields correspond to the options external top-level callers
# can request to control the appearance of the output.
#
# Actual function call parameters are used for all other purposes where the
# values should be propagated down a branch, but parallel branches should use
# the original values passed by the caller earlier on the recursion stack.
#

noexport:; use constant enum 
  qw(visited next_index index_to_tree_node index_ref_counts
     highest_ref_count highest_address highest_level

     flags max_depth one_line_array_max_length one_line_hash_max_length
     max_string_length max_subtree_items);

my $quotes_required_re = qr{[\s\,\x00-\x1F\x7F-\xFF]}oamsx;

my $ansi_console_codes_placeholder = ORANGE.small_fancy_e.UX.C;

#
# Format strings with potentially unlimited lengths, by word wrapping
# them if appropriate, truncating them (with a "..." indication of this)
# to a caller specified length, replacing unprintable characters and
# control characters with alternative representations, and finally
# colorizing the formatted string and surrounding it with quotes and
# appending an indication of its length:
#
sub format_clipped_string($;$$$$$$) {
  my ($s, $max_length, $subst_control_chars, $show_quotes, $color, $sym_color, $quote_color) = @_;

  $max_length //= INT_MAX;
  $subst_control_chars //= 1;

  $show_quotes //= ($s =~ $quotes_required_re);
  $color //= C;
  $sym_color //= R;
  $quote_color //= scale_rgb_fg($color, 0.5);

  my $from_end = ($max_length < 0);
  $max_length = -$max_length if ($max_length < 0);

  my $orig_length = length($s);
  if ($orig_length > $max_length) {
    $s = substr($s, ($from_end) ?
               max(($orig_length - $max_length), 0) : 0,
               min($max_length, $orig_length));
  }

  my $esc_code_repl = small_fancy_e;
  $s =~ s{$ansi_console_escape_codes_re}{$esc_code_repl}oamsxg;

  if ($subst_control_chars)
    { $s = special_chars_to_printable_symbols($s, $color, $sym_color); }

  $s =~ s{$esc_code_repl}{$ansi_console_codes_placeholder}oamsxg;

  my $lq = ($show_quotes) ? $quote_color.left_quote : '';
  my $rq = ($show_quotes) ? $quote_color.right_quote : '';

  return $lq.$color.$s.$quote_color.
    (($orig_length > $max_length) ? elipsis_three_dots : '').$rq.X;
}

#
# Format the actual value of a scalar (number, string, dual or undef).
# This helper function is called from various places where scalars
# must be printed, either as part of a real node or for other reasons
# (e.g. to format the keys of hashes, which are always scalars):
#
sub format_scalar_as_text(+$;$$$) {
  my ($obj, $type, $max_string_length, $show_quotes, $condense_duals) = @_;
  $type //= UNDEF;
  $max_string_length //= INT_MAX;
  $condense_duals //= 0;

  my $readonly = is_read_only($_[0]);
  my $tainted = is_tainted($_[0]);

  my $scalar; my $string;
  ($scalar, $string) = split_dual($obj) if ($type == DUAL);

  my $text = 
    (($type == UNDEF) ? (undef_color.x_signed.' undef ') :
    ($type == SCALAR) ? (scalar_color.$obj) :
      ($type == STRING) ? format_clipped_string("$obj", $max_string_length, 1, $show_quotes, string_color, PURPLE, string_dark_color) :
    ($type == DUAL) ? (($condense_duals)
       ? (("$scalar" eq "$string") ? (scalar_string_dual_color.$scalar) :
         (scalar_color.$scalar.scalar_string_dual_color.large_right_slash.
         format_clipped_string($string, $max_string_length, 1, $show_quotes, string_color, PURPLE, string_dark_color))
       ) : (scalar_color.$scalar.scalar_string_dual_color.' '.large_right_slash.' '.
         format_clipped_string($string, $max_string_length, 1, $show_quotes, string_color, PURPLE, string_dark_color))
      ) :
      (R.'UNKNOWN('.reftype($obj).', typeid '.$type.')'));

  if ($readonly) { 
    $text = blend_and_scale_rgb_fg_in_string($text, [0, 0, 255], 1, RATIO_1_3).
      R_3_4.' '.o_with_skewed_slash.' '.B.'read only'.B_2_3; # three_vert_bars
  } elsif ($tainted) {
    $text = blend_and_scale_rgb_fg_in_string($text, [255, 128, 0], 1, RATIO_1_3).
      R_2_3.' ('.ORANGE.warning_sign.' '.U.'tainted'.UX.R_2_3.')';
  }

  return $text;
}

#
# Format any type of scalar value (numbers, strings, dual numeric/strings
# and undefined values) as a single node on one line:
#
sub format_scalar(+++$$) {
  my ($obj, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  push @$label, format_scalar_as_text($_[0], $type // undef, $context->[max_string_length], 1);
  return $node;
}

my @scalar_ref_type_names = (
  'undef', 'scalar', 'string', 'dual',
  'ref', 'scalar', 'string', 'dual',
);

#
# Format a reference to a scalar (or another reference) by recursing into
# a single sub-node representing whatever the reference points to:
#
sub format_scalar_ref(+++$$) {
  my ($ref, $node, $context, $level, $type) = @_;
  alias my $obj = ${$ref};
  my $label = $node->[0];

  push @$label, ref_dark_color.'ref to '.ref_color.'\\'.U.$scalar_ref_type_names[$type].UX;
  push @$node, format_anything(((is_glob $obj) ? \$obj : $obj), $node, $context, $level+1);
  return $node;
}

sub estimate_line_length_so_far(;$$) {
  my ($depth, $total_lines) = @_;
  # Use some typical worst case estimates if 
  # the caller doesn't know the exact values:
  $depth //= 5;
  $total_lines //= 1000;

  return 3 + decimal_digit_count($total_lines) + 2+1 + 
    3*$depth + 3;
}

#sub array_fits_on_one_line(+;$$) {
#  my ($array, $max_printed_length, $max_elems) = @_;
#  $max_printed_length //= $terminal_width - estimate_line_length_so_far(
#  return ((scalar @$array) < ($max_size // 0)) && (all { !ref } @$array));
# 
# }

#
# Format an entire array, recursively formatting
# each of its elements, annotated with their
# corresponding indices. Short arrays that meet
# various criteria are printed entirely on one
# line in a more compact format:
#
sub format_array(+++$$) {
  my ($array, $node, $context, $level, $type) = @_;

  my $label = $node->[0];
  my $n = scalar(@$array);
  $type = ($n > 0) ? typeof($array->[0]) : UNDEF;

  push @$label, array_color.U.'array'.UX.array_dark_color.wide_left_square_bracket.
    array_dark_color.'#'.array_color.$n.array_dark_color.wide_right_square_bracket.'=';

  my $show_on_one_line = ($context->[flags] & DDS_OPTION_SINGLE_LINE) || 
    (($n < ($context->[one_line_array_max_length] // 0)) && (all { !ref } @$array));
  my $show_as_qw = $show_on_one_line && ($n > 0) && (all { (defined $_) && ($_ =~ /\A $perl_identifier_re \Z/oamsx) } @$array);
  my $show_quotes = $show_on_one_line && ($n > 0) && (any { (!defined $_) || ($_ =~ /$quotes_required_re/oamsx) || (length > 40) || (!length) } @$array);

  if ($show_as_qw) {
    push @$label, C_3_4.' qw'.C_2_3.round_bold_left_paren.C.
      join(' ', @$array).C_2_3.round_bold_right_paren.X;
  } elsif ($show_on_one_line) {
    push @$label, array_dark_color.wide_left_square_bracket.X.
      join(K.', '.X, (map { format_scalar_as_text($_, typeof($_), $context->[max_string_length], $show_quotes, 1) } @$array)).
      array_dark_color.wide_right_square_bracket.X;
  } else {
    for my $i (0..$#{$array}) {
      my $formatted_key = array_dark_color.'['.array_color.$i.array_dark_color.']'.' '.wide_equals_sign.' ';
      alias my $elem = $array->[$i];
      push @$node, format_anything(((is_glob $elem) ? \$elem : $elem), $node, $context, $level+1, $formatted_key);
    }
  }

  return $node;
}

#
# Format an entire hash and recursively format 
# the values associated with each key. Small
# hashes that meet various criteria are printed
# entirely on one line in a more compact format:
#
sub format_hash(+++$$) {
  my ($hash, $node, $context, $level, $type) = @_;
  my $label = $node->[0];
  my $flags = $context->[flags];

  my $n = scalar keys %$hash;

  push @$label, hash_color.U.'hash'.UX.hash_dark_color.
    wide_left_brace.'#'.hash_color.$n.hash_dark_color.
    wide_right_brace.' = ';

  my $show_on_one_line = 
    ($n < ($context->[one_line_hash_max_length] // 0)) && 
    (all { !ref } (values %$hash)) &&
    (!($flags & DDS_OPTION_HASH_DETAILS));

  if ($show_on_one_line) {
    push @$label, hash_dark_color.wide_left_brace.X.
      join(K.', '.X, (pairmap {
        hash_color.$a.fg_color_rgb(255, 0, 0).hash_arrow_color.' '.arrow_barbed.' '.X.
          format_scalar_as_text($b, typeof($b), $context->[max_string_length], 1)
      } %$hash)).hash_dark_color.wide_right_brace.X;
  } else {
    my @keys = sort keys %$hash;
    my $longest_key_length = maxlength(@keys);
  
    my @hidden_keys;

    if ($flags & DDS_OPTION_HASH_DETAILS) {
      my $is_locked = hashref_locked($hash);
      my $traversal_order_mask = hash_traversal_mask($hash);
      @hidden_keys = hidden_ref_keys($hash);
      my ($key_count, $bucket_count, $used_bucket_count, @length_histo) = bucket_info($hash);

      my $dark = scale_rgb_fg(hash_color, RATIO_2_3);

      if (defined $key_count) {
        my $info = 
          $dark.'('.hash_color.($is_locked ? U.'locked'.UX.$dark.' hash with ' : '').
            hash_color.$key_count.$dark.' keys'.
            ((@hidden_keys) ? ' ('.hash_color.(scalar @hidden_keys).$dark.' hidden keys)' : '').' using '.
            hash_color.$used_bucket_count.$dark.' of '.
            hash_color.$bucket_count.$dark.' buckets)';
        
        push @$label, $info;
      }
    }
    
    foreach my $key (sort keys %$hash) {
      my $formatted_key = hash_dark_color.'{'.hash_color.$key.hash_dark_color.'}'.K_2_3.
        (bullet_small x ($longest_key_length - (length $key))).hash_arrow.X;
      alias my $elem = $hash->{$key};
      push @$node, format_anything(((is_glob $elem) ? \$elem : $elem), $node, $context, $level+1, $formatted_key);
    }

    foreach my $key (sort @hidden_keys) {
      my $formatted_key = hash_dark_color.'{'.hash_dark_color.$key.hash_dark_color.'}'.K_2_3.
        (bullet_small x ($longest_key_length - (length $key))).' '.hash_color.'(hidden locked key)'.X;
    }
  }

  return $node;
}

#
# Format a CODE reference to a subroutine, lambda, closure, coroutine
# or block passed to various iterators and similar functions. If the
# subroutine is a normal named function, print out its name and its
# prototype, along with the internal address of its compiled code 
# for debugging use:
#
sub format_code(+++$$) {
  my ($code, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  my $addr = hexstring(Scalar::Util::refaddr($code));
  my ($name, $package) = 
    code_ref_to_sub_function_name_and_package($code);
  $name //= ORANGE.'<anonymous>'.ORANGE_1_2.' @ '.ORANGE.'0x'.hexstring($addr).ORANGE_1_2.'>';
  $package //= '';

  my $show_addr = ($name eq '__ANON__') || ($name eq '<unknown>');
  my $proto = prototype($code);

  push @$label, ORANGE_3_4.'sub '.ORANGE.$package.'::'.$name;
  push @$label, ORANGE_1_2.'('.ORANGE.$proto.ORANGE_1_2.')' if (defined $proto);
  push @$label, ORANGE_2_3.' @ '.ORANGE.$addr if ($show_addr);
  push @$label, ORANGE_1_2.' '.bold_left_brace.' '.K.elipsis_three_dots.ORANGE_1_2.' '.bold_right_brace.X;

  return $node;
}

my $regexp_comment_re = qr{(?<! \\) \# \N*+ \n}oamsx;

#
# Colorize the tokens of a regular expression 
# according to the following simple rules:
# 
noexport:; sub colorize_regexp_text(+) {
  my ($re) = @_;

  my ($pattern, $modifiers) = ((is_regexp $re) ? regexp_pattern($re) : ("$re", ''));

  $pattern = $pattern
    =~ s{(\[[^\]]+\])}{$R$1$X}roamsxg
    =~ s{\\ (.)}{$K\\$M$1}roamsxg
    =~ s{(?= $regexp_comment_re)}{$K}roamsxg
    =~ s{((?<! \\) \( \? . | (?<! \\) \))}{$B$1$X}roamsxg
    =~ s{((?<! \\) \( (?! \?))}{$C$1$X}roamsxg
    =~ s{\\ (?! \w)}{$K\\$X}roamsxg
    =~ s{\|}{$R\|$X}roamsxg
    =~ s{\]}{$R]}roamsxg
    =~ s{((?<! \() [\+\*\?] | $braces_re)}{$Y$1$X}roamsxg;

  return ORANGE.'qr'.ORANGE_3_4.large_right_slash.X.$pattern.X.
    ORANGE_3_4.large_right_slash.ORANGE.$modifiers;
}

#
# Format compiled regular expressions with basic color coding
# of their tokens. (Much more detail in a more visually elegant
# form is available using the MTY::Regexp::Analyzer package).
#
sub format_regexp(+++$$) {
  my ($regexp, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  push @$label, ORANGE.U.'regexp'.UX.ORANGE_1_2.' = '; 

  my $text = colorize_regexp_text($regexp);
  push @$label, $text;

  return $node;
}

#
# This is not actually called, since blessed objects a.k.a. 
# instances of classes are handled by format_anything, then
# decomposed and formatted according to their underlying 
# primitive types. It is only included here for consistency;
# the formatting in this pseudo-function is the same as what
# is used in format_anything():
#
sub format_blessed(+++$$) {
  my ($obj, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  my $class = classof($obj);
  push @$label, C_3_4.'class '.C.U.$class.UX.C_3_4.' = ';

  return $node;
}

#
# Show each of the valid GLOB slots in a format similar to hashes,
# with the data types as keys and the references to the actual
# variables, subroutines or other symbols as the values. This
# function is important to the ability to nicely format package
# symbol table stashes, amongst other uses:
#
sub format_glob {
  my ($node, $context, $level, $type) = @_[1..$#_];
  my @slots = glob_to_pairs($_[0]);
  my $label = $node->[0];

  push @$label, glob_color.U.'GLOB'.UX.glob_dark_color.' with '.
    glob_color.(scalar(@slots) / 2).glob_dark_color.' slots';

  pairmap {
    alias my ($type, $dataref) = ($a, $b);
    my $formatted_key = glob_dark_color.double_left_angle_bracket.
      glob_color.lc($type).glob_dark_color.double_right_angle_bracket.K_1_3.
      (bullet_small x (10 - (length $type))).hash_arrow.X;
    push @$node, format_anything(
      $dataref, $node, $context, $level+1, $formatted_key);
  } @slots;

  return $node;
}

#
# LVALUE types are only produced by built-in functions like pos($str)
# and substr($str, ...) since the returned "values" will alter the
# original arguments if they're modified. Currently these LVALUE
# types are a black box and can't be printed in detail now (at least
# not without an XS module to access these internals).
#
# The LVALUE type is *NOT* used for subroutines with the :lvalue 
# attribute, since these just return an ordinary alias to the symbol
# that is to be writable by the caller.
#
sub format_lvalue(+++$$) {
  my ($lvalue, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  push @$label, ORANGE.U.'lvalue'.UX;

  return $node;
}

#
# Unfortunately formats are virtually opaque black boxes from
# the glob slot standpoint, so we can't do much with them here:
#
sub format_format(+++$$) {
  my ($format, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  push @$label, B.U.'format'.UX;

  return $node;
}

#
# For IO objects, try to show the native file descriptor number
# as returned by fileno() along with the actual path of the
# file (if it is a real file) represented by the IO object:
#
sub format_io_ref(+++$$) {
  my ($io, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  my $fd = fileno($io);
  my $filename = (defined $fd) ? path_of_open_fd($fd) : undef;

  my $text = M.U.'I/O'.UX;
  $text .= M_2_3.': fd '.M.$fd if (defined $fd);
  $text .= M_2_3.' '.M.large_arrow_barbed.M_2_3.' path '.M.$filename if (defined $filename);
  push @$label, $text;

  return $node;
}

#
# Show version strings using their default 'vX.XX.XXX...' format:
#
sub format_vstring(+++$$) {
  my ($vstring, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  push @$label, G.U.'vstring'.UX.G_1_2.' = '.G.$vstring;

  return $node;
}

#
# Dispatch jump table to functions which format each data type:
#
my @type_to_format_func = (
  \&format_scalar,  # UNDEF
  \&format_scalar,  # SCALAR
  \&format_scalar,  # STRING
  \&format_scalar,  # DUAL
  \&format_scalar_ref,  # REF_REF
  \&format_scalar_ref,  # SCALAR_REF
  \&format_scalar_ref,  # STRING_REF
  \&format_scalar_ref,  # DUAL_REF
  \&format_array,  # ARRAY_REF
  \&format_hash,  # HASH_REF
  \&format_code,  # CODE_REF
  \&format_regexp,  # REGEXP_REF
  \&format_blessed,  # BLESSED_REF
  \&format_glob,  # GLOB_REF
  \&format_lvalue_ref,  # LVALUE_REF
  \&format_format_ref,  # FORMAT_REF
  \&format_io_ref,  # IO_REF
  \&format_vstring_ref,  # VSTRING_REF
);

use constant enum (
  TYPE_CATEGORY_SCALAR,    # undef, number, string, dual
  TYPE_CATEGORY_SCALAR_REF,# ref to scalar
  TYPE_CATEGORY_REF_REF,   # ref to ref
  TYPE_CATEGORY_CONTAINER, # ref to array or hash
  TYPE_CATEGORY_CODE,      # ref to code block or sub
  TYPE_CATEGORY_SPECIAL,   # ref to regexp, object, glob, lvalue, format, io, vstring
);

my @type_to_category = (
  (TYPE_CATEGORY_SCALAR) x 4,
  TYPE_CATEGORY_REF_REF,
  (TYPE_CATEGORY_SCALAR_REF) x 3,
  TYPE_CATEGORY_CONTAINER,
  TYPE_CATEGORY_CONTAINER,
  TYPE_CATEGORY_CODE,
  (TYPE_CATEGORY_SPECIAL) x 7,
);

#
# format_anything() is the first function called to start the recursive 
# traversal of a data structure graph, and is also called by the type-
# specific handler functions (format_xxx()) to continue recursively
# processing each item within container types (arrays, hashes, classes
# and references to scalars or refs). All other data types are terminal
# nodes bounding the edges of the graph.
#
# This function essentially creates a new tree node, fills out the
# first portion of its label with generic type agnostic information
# (like the per-line index and address prefix columns, etc.), then
# invokes one of the format_xxx() handler functions (listed in the
# @type_to_format_func dispatching array) to finish preparing the
# tree node. 
#
# Both this function and all the handlers take a single reference
# argument pointing to a context array (see comments above for
# the various constant names of each array item).
#
# For container data types, the handler function may either add
# sub-nodes to the tree node on its own (simple cases only), or 
# for each item within the container, it calls format_anything()
# to descend the graph and dispatch the correct handler.
#
# Handler functions may pass a string in the $formatted_key
# argument, which format_anything() will add to the tree node
# before calling any handlers. This is used to annotate each
# item in an array or hash with its index or key, independent
# of the actual data type of that item.
#
sub format_anything { # (+++$;$$;$)
  my ($copy_of_obj, $parent_node, $context, $level, $formatted_key) = @_;
  alias my $obj = $_[0];

  my ($visited, $next_index, $index_to_tree_node, 
      $index_ref_counts, $highest_ref_count, $highest_address, $highest_level, 
      $flags, $max_depth) = @$context;

  my $show_addresses = ($flags & DDS_OPTION_SHOW_ADDRESSES);

  my $type = unblessed_typeof($_[0]) // UNDEF;
  my $category = $type_to_category[$type];
  my $is_ref = is_ref($_[0]);

  my $class = classof($obj);

  if ($level > $highest_level) { $context->[highest_level] = $highest_level; }

  #
  # Construct the initial generic parts of the tree node,
  # and then call the type specific handler to finish it;
  # these handlers may recurse into format_anything() for
  # nested data structures like arrays, hashes and refs.
  #
  my $addr = (defined $_[0]) ? (($is_ref) ? Scalar::Util::refaddr($_[0]) : 
                                  Scalar::Util::refaddr(\$_[0])) : 0;

  set_max($context->[highest_address], $addr);
  
  my $duplicated = ($is_ref && (defined $visited->{$addr})) ? 1 : 0;

  my $real_index = $context->[next_index]++;
  my $index = ($duplicated) ? $visited->{$addr} : $real_index;

  my $label = [ ];
  my $node = [ $label ];
  $index_to_tree_node->[$real_index] = $node;
  $index_to_tree_node->[$index] = $node if (!$duplicated);

  my $addr_color = ($duplicated) ? visited_addr_color : normal_addr_color;

  my $refcount = 0;
  if ($duplicated) {
    $refcount = ++$index_ref_counts->[$index];
    set_max($context->[highest_ref_count], $refcount);

    # Set the "ref count" of duplicate backref pseudo-indices to the negative
    # reference count as a flag indicating this index contains the label for
    # this backref, so we can handle it accordingly when we do the final pass 
    # over all the nodes:
    $index_ref_counts->[$real_index] = -$refcount;
  }

  push @$label, (
    ($duplicated 
       ? visited_background_color_even_odd_prefix_tree_cmd
       : normal_background_color_even_odd_prefix_tree_cmd),
    [ 
      TREE_CMD_PREFIX,
      # [1] = PREFIX_LABEL_SLOT_INDEX_COLOR_SYM
      ($duplicated ? visited_index_color_and_symbol : normal_index_color_and_symbol),
      # [2] = PREFIX_LABEL_SLOT_INDEX
      $index, # this will be aligned and padded to the correct field width at the end
      # [3] = PREFIX_LABEL_SLOT_REFCOUNT_COLOR = (placeholder for color of ref count itself)
      ($duplicated ? visited_refcount_color_and_symbol_before : undef), # (placeholder)
      # [4] = PREFIX_LABEL_SLOT_REFCOUNT = (placeholder for ref count)
      ($duplicated ? $refcount : undef), # (placeholder)
      # [5] = PREFIX_LABEL_SLOT_REFCOUNT_SYM = (placeholder for ref count symbol after the actual value)
      ($duplicated ? visited_refcount_symbol_after : undef), # (placeholder)
      # [6] = PREFIX_LABEL_SLOT_ADDR_COLOR_SYM
      ($show_addresses ? (($duplicated) ? visited_addr_color_and_symbol : normal_addr_color_and_symbol) : undef),
      # [7] = PREFIX_LABEL_SLOT_ADDR
      ($show_addresses ? $addr : undef), # (placeholder: will be aligned and padded at end to longest address width)
      # [8] = PREFIX_LABEL_SLOT_ENDCAP
      prefix_label_endcap,
    ],

    # [ ] = branch color
    (($duplicated) ? ( ) : 
       ($type_to_branch_color_tree_cmd[$type] // '')),
    # [ ] = branch style
    (($duplicated) ? visited_branch_style_tree_cmd : 
       (defined $class) ? object_branch_style_tree_cmd :
       ($type_to_branch_style_tree_cmd[$type] // 
        ($is_ref ? ref_branch_style_tree_cmd : normal_branch_style_tree_cmd))),
    # [ ] = branch dashed
    (($duplicated) ? visited_branch_dashed_tree_cmd : ( )),
    # [ ] = node symbol
    (($duplicated) ? $type_to_visited_symbol_tree_cmd[(defined $class) ? BLESSED_REF : $type] :
       $type_to_symbol_tree_cmd[(defined $class) ? BLESSED_REF : $type]),
  );

  if ($level == 0) {
    # Global settings that will be propagated down all sub-branches:
    push @$label, [ TREE_CMD_HORIZ_BRANCH_LENGTH, 2 ];

    my $per_line_prefix_length = 3 + # for referenced / backlink indicator
      5 + # for unique index counter number
      ($show_addresses ? 12 : 0) + # for address (if enabled)
      1 + 16; # for the spacer column before the branches + 4+ levels deep
    
    # This is disabled for now until we can resolve some issues with it:
    # push @$label, [ 
    #  TREE_CMD_MAX_FIELD_WIDTH, 
    #  get_terminal_width_in_columns() - $per_line_prefix_length, 0 ];
  }

  if (defined $formatted_key) {
    push @$label, 
      ((is_array_ref $formatted_key) ? @$formatted_key : 
         ($duplicated ? scale_rgb_fg_in_string($formatted_key, RATIO_2_3) : $formatted_key)),
  }

  if (defined $class) {
    push @$label, ORANGE_3_4.double_left_angle_bracket.
      ORANGE.'class '.Y.U.$class.UX.
        ORANGE_3_4.double_right_angle_bracket.' ';
  }

  if ($duplicated) {
    push @$label,
      duplicated_label_prefix,
      $index,
      duplicated_label_suffix,
      visited_branch_color_tree_cmd;

    return $node;
  }

  $visited->{$addr} = $index; 

  if ($level >= $max_depth) {
    push @$label, get_exceeded_max_depth_warning($max_depth);
  } else {
    my $func = $type_to_format_func[$type];
    $node = $func->($obj, $node, $context, $level, $type);
  }

  return $node;
}

my @ref_type_index_to_description = (
  'Undefined value', 'Numeric scalar value', 'String', 'Dual scalar/string',
  'Reference to reference', 'Reference to numeric scalar value', 'Reference to string', 'Reference to dual scalar/string',
  'Array', 'Hash', 'Code block or subroutine', 'Regular expression',
  'Object of class', 'Typeglob', 'L-value', 'Format',
  'I/O object', 'Version string', 'Unknown type'
);

my @type_short_name = (
  'undef', 'scalar', 'string', 'dual',
  'dual', 'scalar', 'string', 'dual',
  'array', 'hash', 'code', 'regexp',
  'object', 'glob', 'lvalue', 'format',
  'io', 'version', 'unknown'
);

my $source_code_lines_cache;

noexport:; sub fill_source_code_lines_cache(+$) {
  my ($cache, $filename) = @_;

  my $lines = read_file_as_lines($filename);

  if (!defined $lines) {
    warning(U.'DataStructures:'.UX.' Could not read source file ', 
            format_quoted($filename), R.' to determine the original '.
            'symbolic variable name of an object to print');
  }

  return $lines;
}

my $call_to_format_data_structure_func_re = 
  qr{\b ( (?> (?> format|print)_data (?>_as_tree)?) |   # capture group $1 
       pp | dds | enhanced_format_printable_data ) \b
     (?> (?> \s*+ \( ) | \s++)   # handle function call both with and without parens
     (                           # $2 = everything in the first argument (i.e. the target to print)
       (?>
         [^\,\;\(\)\{\}\[\]\'\"] | 
         $nested_parens_braces_brackets_quoted_re
       )++
     )
     [\,\)\;]    # ...and remaining arguments we don't need for this regexp (i.e. $title and %options) 
  }oax;

my $prev_caller_filename = undef;
my $prev_caller_line = undef;
my $prev_caller_pos_in_line = 0;

my $lines_to_eval_from_perl_command_line = undef;

noexport:; sub get_lines_to_eval_from_perl_command_line() {
  return $lines_to_eval_from_perl_command_line if 
    (defined $lines_to_eval_from_perl_command_line);

  my $args //= (read_proc_cmdline() // [ ]);

  my $next_arg_is_eval_code = 0;
  $lines_to_eval_from_perl_command_line = [ grep {
    if ($next_arg_is_eval_code) { $next_arg_is_eval_code = 0; 1; }
    elsif ($_ eq '-e') { $next_arg_is_eval_code = 1; 0; }
    else { 0; }
  } @$args ];

  return $lines_to_eval_from_perl_command_line;
}

noexport:; sub get_eval_code($) {
  my ($eval_id) = @_;

  for (my $i = 0; ; $i++) { 
    my @caller = caller($i);
    return undef if (!@caller); 
    my $eval_code = $caller[6];
    return [ $eval_code ] if (defined $eval_code);
  }

  return undef;
}

noexport:; sub format_title_based_on_caller_source_code(+++$$$$$$) {
  my ($obj, $context, $options, $placeholder_id,
      $caller_package, $caller_filename, $caller_line, 
      $caller_function, $caller_eval_code) = @_;

  $source_code_lines_cache //= MTY::Common::Cache->new(
    \&fill_source_code_lines_cache, 'source_code_lines_cache');

  my $source_code_lines = 
    (!defined $caller_filename) ? undef :
    (defined $caller_eval_code) ? [ $caller_eval_code ] :
    ($caller_filename =~ /\(eval/oamsx) ? get_eval_code($caller_filename) :
    ($caller_filename eq '-e') ? get_lines_to_eval_from_perl_command_line() :
    $source_code_lines_cache->get($caller_filename);

  if (!defined $source_code_lines) {
    return X.R.'[could not read source file]'.X;
  }

  if (defined $caller_eval_code) {
    $caller_filename = '<eval>';
    $caller_line = 1;
  }

  #
  # Line numbers provided by caller() start with line 1,
  # but the actual array of lines is obviously zero based,
  # so decrement the effective line number to compensate:
  #
  $caller_line--;

  if (($caller_line < 0) || ($caller_line >= sizeof($source_code_lines))) {
    return X.R.'[line '.ORANGE.$caller_line.R.
      ' is beyond last line ('.ORANGE.sizeof($source_code_lines).R.
        ') of '.Y.$caller_filename.R.']'.X;
  }

  my $line = $source_code_lines->[$caller_line];

  #
  # Properly handle multiple consecutive invocations of pp 
  # on one source line by starting the regexp search at the
  # position where the last invocation's match ended:
  #
  if ((defined $prev_caller_filename) && 
      (defined $prev_caller_line) &&
      (($prev_caller_filename ne $caller_filename) ||
      ($prev_caller_line != $caller_line))) {
    $prev_caller_pos_in_line = 0;
  }

  pos($line) = $prev_caller_pos_in_line;

  $prev_caller_filename = $caller_filename;
  $prev_caller_line = $caller_line;
  
  if ($line =~ /$call_to_format_data_structure_func_re/oaxgc) {
    my ($called_function, $target_to_print) = ($1, $2);
    my $match_pos = $-[0];
    my $end_pos = pos($line);
    $prev_caller_pos_in_line = ($end_pos >= (length $line)) ? 0 : $end_pos;
    return ($target_to_print, $match_pos);
  } else {
    $prev_caller_filename = undef;
    $prev_caller_line = undef;
    $prev_caller_pos_in_line = 0;
    pos($line) = 0;

    return # $base_prefix.$base_title.
      X.R.'[could not extract original target name from source line: '.
      LIGHTBLUE.format_quoted(LIGHTBLUE.$line).R.']'.X;
  }
}

sub format_data_as_tree(+;$%) {
  my ($obj, $title, %options) = @_;

  # Capture our external caller while we're still the direct callee:
  my $caller = $options{caller} // [ caller(0) ];

  my $type = typeof($obj);
  my $description = $ref_type_index_to_description[$type] // 'Unknown type';

  #
  # If this will be the top level invocation of format_anything(),
  # create the structures shared throughout the recursion process,
  # and put references to them into the context structure below:
  #
  my $visited = { };
  my $index_to_tree_node = [ ];
  my $index_ref_counts = [ ];

  $options{max_depth} = 1 if ($options{no_recursion} // 0);
  $options{single_line} = 0 if ($options{multi_line} // 1);

  my $flags = 
    (($options{single_line} // 0) 
       ? DDS_OPTION_SINGLE_LINE : 0) |
    (($options{show_addresses} // $default_show_addresses) 
       ? DDS_OPTION_SHOW_ADDRESSES : 0) |
    (($options{strip_ansi_console_codes} // 
        $default_strip_ansi_console_codes) 
       ? DDS_OPTION_STRIP_ANSI_CONSOLE_STRINGS : 0) |
    (($options{strip_unicode} // $default_strip_unicode) 
       ? DDS_OPTION_STRIP_UNICODE_STRINGS : 0) |
    (($options{read_line_from_source_to_create_title} // 
        $default_read_line_from_source_to_create_title) 
       ? DDS_OPTION_READ_SOURCE_TO_MAKE_TITLE_FOR_CALLER : 0) |
    (($options{always_print_caller} // $default_always_print_caller) 
       ? DDS_OPTION_ALWAYS_PRINT_CALLER : 0) |
    (($options{hash_details} // $default_show_hash_details) 
       ? DDS_OPTION_HASH_DETAILS : 0) |
    (($options{extensive_hash_details} // $default_show_extensive_hash_details) 
       ? DDS_OPTION_EXTENSIVE_HASH_DETAILS : 0);

  #
  # Note that $context->[next_index] (i.e. the "0" initial value at index #1
  # of the context array below) will always refer to the index counter
  # declared below by the top level call of the recursive descent tree,
  # so it can be incremented globally (w.r.t. the present op-level traversal
  # operation) and yields a unique monotonically incremented value every time.
  #
  # The highest_level field (the "0" at index #5 of the context) is likewise
  # globally set to the highest level the recursion has reached so far.
  #
  my $context = [
    $visited, 0, $index_to_tree_node, $index_ref_counts,
    0,  # highest_ref_count
    0,  # highest_address
    0,  # highest_level
    $flags,
    $options{max_depth} // $default_max_depth,
    $options{one_line_array_max_length} // $default_one_line_array_max_length,
    $options{one_line_hash_max_length} // $default_one_line_hash_max_length,
    $options{max_string_length} // $default_max_string_length,
    $options{max_subtree_items} // $default_max_subtree_items,
  ];
  
  my ($caller_package, $caller_filename, $caller_line, $caller_function,
    $caller_has_args, $caller_wants_array, $caller_eval_code) = @$caller;

  my $title_color = top_level_variable_name_color.U;
  my $dark_color = W_2_3;
  my $trailing_text = 
    X.$dark_color.' '.double_left_paren.'from '.G.($caller_function =~ s{\A (?> \w+ ::)*+}{}roamsxg).
      $dark_color.' in '.Y.filename_of($caller_filename).
      $dark_color.' line '.M.$caller_line;
  my $trailing_text_end = $dark_color.double_right_paren.X;
  my $post_title = X.top_level_variable_name_color.' '.arrow_head.' '.X;

  my $unformatted_title = $title;

  if (defined $title) {
    $title = $title_color.$title.$post_title;
    if (!($flags & DDS_OPTION_ALWAYS_PRINT_CALLER)) { $trailing_text = undef; }
  } else {
    $title = $title_color;
    if ($flags & DDS_OPTION_READ_SOURCE_TO_MAKE_TITLE_FOR_CALLER) {
      my $placeholder_id = $options->{placeholder_id};
      my ($target_name, $source_code_column) = format_title_based_on_caller_source_code(
        $obj, $context, $options, $placeholder_id, $caller_package, 
        $caller_filename, $caller_line, $caller_function, $caller_eval_code);
      $title .= $target_name;
      $trailing_text .= $dark_color.' col '.M.$source_code_column if (defined $source_code_column);
      $unformatted_title = $target_name;
    } else {
      $title .= $trailing_text;
      $trailing_text = undef;
    }

    $title .= $post_title;
  }

  my $tree = format_anything(((is_glob $obj) ? \$obj : $obj), undef, $context, 0, $title);

  #
  # Iterate through all the tree nodes based on their unique counter values,
  # and add a visual indicator and reference count to any nodes that are 
  # referenced from one or more other parts of the data structure. We need
  # to do this *after* we've constructed the entire tree so we're aware of
  # every possible reference.
  #

  my $index_field_width    = max(decimal_digit_count($context->[next_index]), 3);
  my $refcount_field_width = max(decimal_digit_count($context->[highest_ref_count]), 1);
  my $address_field_width  = max(hex_digit_count($context->[highest_address]), 8);
  my $address_field_format = '%'.$address_field_width.'x';
  my $null_address_label = padstring(null_address_label, -$address_field_width).' '.X;

  my $refcount_field_padding = '  '.(' ' x $refcount_field_width).'  ';
  my $refcount_symbol_padding = (' ' x 2);

  $tree->[0]->[0] = root_color_and_symbol_prefix_tree_cmd;

  while (my ($i, $node) = each @$index_to_tree_node) {
    my $label = $node->[0];
    my $prefix = $label->[1];
    my $refcount = $index_ref_counts->[$i] // 0;
    
    $prefix->[PREFIX_LABEL_SLOT_INDEX] = 
      padstring($prefix->[PREFIX_LABEL_SLOT_INDEX], -$index_field_width);

    if ($flags & DDS_OPTION_SHOW_ADDRESSES) {
      my $addr = $prefix->[PREFIX_LABEL_SLOT_ADDR];
      $prefix->[PREFIX_LABEL_SLOT_ADDR] = (($addr)
        ? sprintf($address_field_format, $addr).' '.X
        : $null_address_label);
    }

    if ($refcount > 0) {
      $label->[0] = referenced_background_color_even_odd_prefix_tree_cmd if ($i > 0);

      $prefix->[PREFIX_LABEL_SLOT_INDEX_COLOR_SYM] = referenced_index_color_and_symbol;
      $prefix->[PREFIX_LABEL_SLOT_REFCOUNT_COLOR]  = referenced_refcount_color_and_symbol_before;
      $prefix->[PREFIX_LABEL_SLOT_REFCOUNT]        = padstring($refcount, -$refcount_field_width);
      $prefix->[PREFIX_LABEL_SLOT_REFCOUNT_SYM]    = referenced_refcount_symbol_after;
      $prefix->[PREFIX_LABEL_SLOT_ADDR_COLOR_SYM]  = referenced_addr_color_and_symbol;
      push @$label,
       '  '.referenced_index_medium_color.double_left_angle_bracket.
       'referenced '.referenced_index_color.$refcount.
        referenced_index_medium_color.small_roman_numeral_x.
        double_right_angle_bracket.X;
    } elsif ($refcount < 0) {
      # repeated node
      $prefix->[PREFIX_LABEL_SLOT_INDEX_COLOR_SYM] = visited_index_color_and_symbol;
      $prefix->[PREFIX_LABEL_SLOT_REFCOUNT_COLOR]  = visited_refcount_color_and_symbol_before;
      $prefix->[PREFIX_LABEL_SLOT_REFCOUNT]        = padstring(-$refcount, -$refcount_field_width);
      $prefix->[PREFIX_LABEL_SLOT_REFCOUNT_SYM]    = visited_refcount_symbol_after;
    } else {
      # normal node that isn't referenced elsewhere:
      $prefix->[PREFIX_LABEL_SLOT_REFCOUNT_COLOR]  = '';
      $prefix->[PREFIX_LABEL_SLOT_REFCOUNT]        = $refcount_field_padding;
      $prefix->[PREFIX_LABEL_SLOT_REFCOUNT_SYM]    = $refcount_symbol_padding;
    }
  }

  #
  # Adjust the top level root node's label to show various statistics:
  #
  my $root_label = $tree->[0];
  push @$root_label, $trailing_text.$trailing_text_end if (defined $trailing_text);

  #
  # Return the formatted tree structure suitable for pasing to format_tree():
  #
  # In list context, this also returns the actual title (if it was dynamically
  # generated based on the expression or variable name the caller asked us to
  # print), followed by the total number of tree nodes and the highest level
  # reached by the recursion (which obviously stops whenever it encounters a
  # previously visited node, which inherently limits this depth):
  #
  return (wantarray ? (
    $tree, 
    $unformatted_title,
    $context->[next_index], 
    $context->[highest_level]
  ) : $tree);
}

sub format_data(+;$%) {
  my ($obj, $title, %options) = @_;

  # Capture our external caller while we're still the direct callee:
  $options{caller} //= [ caller(0) ];

  (my $tree, $title) = format_data_as_tree($obj, $title, %options);

  return format_tree($tree);
}

sub print_data(+;$$%) {
  alias my $obj = $_[0];
  my ($title, $fd, %options) = @_[1..$#_];

  # Capture our external caller while we're still the direct callee:
  $options{caller} //= [ caller(0) ];

  $fd //= STDOUT;

  my $text = format_data($obj, $title, %options);
  printfd($fd, $text);
}

my $tree_output_top_separator_line = undef;
my $tree_output_bottom_separator_line = undef;

sub format_gradient_separator_bar(;$$$$$) {
  my ($width, $r, $g, $b, $char) = @_;
  $width //= (get_terminal_width_in_columns() - 2);
  $r //= 80; $g //= 80; $b //= 80; 
  $char //= bottom_edge_horiz_bar;

  my $out = '';
  my $color = fg_color_rgb($r, $g, $b);
  $out .= $color;
  my $granularity = max(int($width / 16), 1);
  my $countdown = $granularity;

  for my $i (0..($width-1)) {
    $countdown--;
    if (!$countdown) {
      no integer;
      my $coeff = ($width - $i) / $width;
      $color = fg_color_rgb(int($r * $coeff), int($g * $coeff), int($b * $coeff));
      $out .= $color;
      use integer;
      $countdown = $granularity;
    }
      
    $out .= $char;
  }

  $out .= X;
  return $out;
}

#
# pp() ("pretty print") is a short name for the equivalent of 
# the print_data() function, plus some additional context 
# sensitive intelligence so that it will automatically print
# the formatted tree to STDERR if the return value is never 
# used by the caller; otherwise it is assumed that the caller 
# will print the returned text itself.
#
sub pp(+;$$%) {
  my ($obj, $title, $fd, %options) = @_;
  my $return_value_used = (defined wantarray);
  
  # Capture our external caller while we're still the direct callee:
  $options{caller} //= [ caller(0) ];

  my $terminal_width = get_terminal_width_in_columns();

  # The folder tab with the title now takes the place of this line:
  # $tree_output_top_separator_line //=
  #   fg_color_rgb(28, 70, 160).(bottom_edge_horiz_bar x ($terminal_width / 2)) .
  #   format_gradient_separator_bar(
  #     ($terminal_width / 2), 28, 70, 160, bottom_edge_horiz_bar).NL;

  $tree_output_bottom_separator_line //=
    fg_color_rgb(28, 70, 160).(top_edge_horiz_bar x ($terminal_width / 2)) .
    format_gradient_separator_bar(
      ($terminal_width / 2), 28, 70, 160, top_edge_horiz_bar).NL;

  (my $tree, $title) = format_data_as_tree($obj, $title, %options);

  my $title_tab = 
    ($options{title_tab} // $default_include_folder_tab_with_title_before_tree) 
      ? print_folder_tab(G.$title, B_2_3, ALIGN_LEFT) : '';

  my $text = 
    $title_tab.
    # $tree_output_top_separator_line. # (now replaced by the folder tab)
    format_tree($tree).
    $tree_output_bottom_separator_line;

  if ((!$return_value_used) || (defined $fd)) {
    $fd //= STDERR;
    printfd($fd, $text);
  }

  return $text if ($return_value_used);
}

#
# Use the enhanced colorized printing code in this package instead
# of the default callback function used by printdebug(), printfd()
# and prints() functions when passed arrays, hashes, refs, etc. 
# 
sub enhanced_format_printable_data {
  my ($print_id, $arg_id, $multi_line) = @_[1..3];
  alias my $obj = $_[0];

  $print_id //= 0;
  $arg_id //= 0;
  $multi_line //= 0;

  $print_id = $print_id + 1; # use #1, #2, #3, etc. labels rather than 0 based

  my $type = typeof $obj;

  my $symbol = 
    enclosed_digit($print_id);

  my $placeholder = 
    (($print_id == 1) ? LIGHTBLUE.' (see' : '').ORANGE.' '.$symbol.' '.
    (($print_id == 1) ? ' '.LIGHTBLUE.'below) ' : '');

  my $title = UX.LIGHTBLUE.'(placeholder'.ORANGE.' '.$symbol.' '.LIGHTBLUE.'from above)';

  $placeholder .= X;

  my $after = 
    (($print_id == 1) ? print_folder_tab(
      LIGHTBLUE.'Contents of placeholders above:', LIGHTBLUE_1_2) : '').
    format_data($obj, $title, 
                caller => [ caller(0) ],
                placeholder_id => $print_id, 
                argument_id => $arg_id).NL;

  return ($placeholder, $after);
}

INIT {
  #
  # Install the enhanced colorized printing code in this package
  # in place of the default callback function used by printdebug(),
  # printfd() and prints() for arrays, hashes, refs, etc. 
  # 
  # The printfd and prints functions will only invoke this code 
  # for references to these data types, whereas simple strings and
  # numbers will be printed as is, to keep the caller's intended
  # appearance of the output.
  #

  $MTY::Common::PrintDebug::format_printable_data_callback =
    \&enhanced_format_printable_data;
}

1;
