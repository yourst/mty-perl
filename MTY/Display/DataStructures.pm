#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Display::DataStructures
#
# Simple text formatting of all the major Perl data types
#
# Copyright 1997 - 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Display::DataStructures;

use integer; use warnings; use Exporter qw(import);

use MTY::Common::Common;
use MTY::Common::Strings;
use MTY::Common::Hashes;
use MTY::RegExp::Strings;
use MTY::RegExp::Blocks;
use MTY::RegExp::PerlSyntax;
use MTY::Display::ANSIColorREs;
use MTY::Display::Colorize;
use MTY::Display::ColorizeErrorsAndWarnings;
use MTY::Display::PrintableSymbols;
use MTY::Display::PrintableSymbolTools;
use MTY::Display::Tree;
use MTY::Display::Table;
use MTY::Display::TextInABox;

use re qw(is_regexp regexp_pattern regnames);

use Sub::Identify qw(:all);
#pragma end_of_includes

preserve:; our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(format_data_as_tree format_data print_data pp);

use constant {
  light_bg_color => bg_color_rgb(32, 32, 32),
  visited_light_bg_color => bg_color_rgb(32, 32, 32), # bg_color_rgb(48, 0, 0),
  referenced_light_bg_color => bg_color_rgb(32, 64, 32),

  # fg_color_rgb(255, 192, 140)
  visited_counter_color => fg_color_rgb(160, 255, 0),
  visited_addr_color => fg_color_rgb(255, 160, 0),

  referenced_counter_color => fg_color_rgb(180, 255, 0), # fg_color_rgb(255, 192, 150),
  referenced_addr_color => fg_color_rgb(180, 255, 0), # fg_color_rgb(216, 180, 140),

  # referenced_counter_color => fg_color_rgb(33, 255, 143), # fg_color_rgb(255, 192, 150),
  # referenced_addr_color => fg_color_rgb(255, 192, 140), # fg_color_rgb(216, 180, 140),

  normal_tree_branch_color => fg_color_rgb(96, 32, 128), # fg_color_rgb(148, 85, 255),
  ref_tree_branch_color => fg_color_rgb(236, 64, 112),

  at_sign_color => fg_color_rgb(128, 128, 128),
  referenced_at_sign_color => fg_color_rgb(192, 192, 192),

  undef_addr_color => fg_color_rgb(216, 180, 140),

  vert_separator => X.fg_color_rgb(64, 96, 192).' '.long_narrow_vert_bar.' '.X,

  undef_color => R, # fg_color_rgb(224, 80, 32),
  dual_type_color => fg_color_rgb(0, 255, 160), # fg_color_rgb(88, 240, 184), # blend between green and cyan
};

use constant {
  dark_bg_color => scale_rgb_bg(light_bg_color, RATIO_2_3),
  visited_dark_bg_color => scale_rgb_bg(visited_light_bg_color, RATIO_2_3),
  referenced_dark_bg_color => scale_rgb_bg(referenced_light_bg_color, RATIO_2_3),

  normal_counter_color => scale_rgb_fg(visited_counter_color, 0.4), #fg_color_rgb(128, 192, 160),
  normal_addr_color => scale_rgb_fg(visited_addr_color, 0.5), # fg_color_rgb(120, 160, 192), # fg_color_rgb(140, 180, 216),

  # visited_at_sign_color => scale_rgb_fg(at_sign_color, RATIO_1_2),
  # visited_addr_color => scale_rgb_fg(normal_addr_color, RATIO_1_2),

  visited_tree_branch_color => scale_rgb_fg(normal_tree_branch_color, RATIO_3_4),

  referenced_counter_dark_color => scale_rgb_fg(referenced_counter_color, 1.0),
};

use constant {
  normal_bg_color_prefix_tree_cmd => 
    [ TREE_CMD_PREFIX, light_bg_color, dark_bg_color ],

  visited_bg_color_prefix_tree_cmd => 
    [ TREE_CMD_PREFIX, visited_light_bg_color, visited_dark_bg_color ],

  referenced_bg_color_prefix_tree_cmd => 
    [ TREE_CMD_PREFIX, referenced_light_bg_color, referenced_dark_bg_color ],

  visited_branch_color_tree_cmd => [
    TREE_CMD_SUB_BRANCH_COLOR, visited_tree_branch_color ],

  normal_branch_style_tree_cmd =>
    [ TREE_CMD_SUB_BRANCH_STYLE, 'single' ],

  visited_branch_style_tree_cmd =>
    [ TREE_CMD_SUB_BRANCH_STYLE, 'single,dashed' ],

  ref_branch_style_tree_cmd => 
    [ TREE_CMD_SUB_BRANCH_STYLE, 'single' ],

  vert_separator_prefix_tree_cmd =>
    [ TREE_CMD_PREFIX, vert_separator ],
};

use constant {
  scalar_type_tree_symbol => G.large_pound_sign,
  string_type_tree_symbol => C.large_dollar_sign,
  dual_type_tree_symbol => dual_type_color.a_slash_s,
  ref_type_tree_symbol => LIGHTBLUE.arrow_tri.'\\',
};

my @type_to_symbol_tree_cmd = map { [ TREE_CMD_SYMBOL, $_ ] } (
  undef_color.box_with_right_slash,  # UNDEF box_with_right_slash
  scalar_type_tree_symbol,  # SCALAR
  string_type_tree_symbol,  # STRING
  dual_type_tree_symbol.' ',  # DUAL
  ref_type_tree_symbol,  # REF_REF
  ref_type_tree_symbol,  # SCALAR_REF
  ref_type_tree_symbol,  # STRING_REF
  ref_type_tree_symbol,  # DUAL_REF
  Y.large_at_sign,  # ARRAY_REF
  PINK.large_percent_sign,  # HASH_REF
  ORANGE.large_ampersand_sign,  # CODE_REF
  ORANGE.rx_symbol.' ',  # REGEXP_REF
  W.dot_in_circle,  # BLESSED_REF
  K.large_asterisk,  # GLOB_REF
  ORANGE.roman_numeral_l,  # LVALUE_REF
  B.deg_f,  # FORMAT_REF
  M.'IO',  # IO_REF
  G.roman_numeral_v,  # VSTRING_REF
);

my @type_to_branch_color_tree_cmd = map { [ TREE_CMD_SUB_BRANCH_COLOR, $_ ] }
(
  # scale_rgb_fg(undef_color, RATIO_2_3), # UNDEF
  # G_2_3,  # SCALAR
  # C_2_3,  # STRING
  # scale_rgb_fg(dual_type_color, RATIO_2_3),  # DUAL
  # ORANGE_2_3,  # REF_REF
  # G_2_3,  # SCALAR_REF
  # C_2_3,  # STRING_REF
  # scale_rgb_fg(dual_type_color, RATIO_2_3),  # DUAL_REF
  ((undef) x 4), #(PURPLE_2_3 x 4),
  ((LIGHTBLUE_2_3) x 4),
  Y_2_3,  # ARRAY_REF
  PINK_2_3,  # HASH_REF
  K_2_3,  # CODE_REF
  SKYBLUE_2_3.rx_symbol,  # REGEXP_REF
  W_2_3,  # BLESSED_REF
  K_2_3,  # GLOB_REF
  ORANGE_2_3,  # LVALUE_REF
  B_2_3,  # FORMAT_REF
  M_2_3,  # IO_REF
  G_2_3,  # VSTRING_REF
);

# These bitmasks go in the flags field of the context array:
noexport:; use constant enumbits (
  DDS_OPTION_SHOW_ADDRESSES,
  DDS_OPTION_STRIP_ANSI_CONSOLE_STRINGS,
  DDS_OPTION_STRIP_UNICODE_STRINGS
);

noexport:; use constant {
  FORMAT_REF_PREFIX => '\\',
};

# In case we're missing the Sub::Identify package:
sub dummy_sub_fullname {
  my ($sub) = @_;
  sprintf('&0x%x', refaddr($sub));
}

sub get_glob_slots($) {
  my ($name) = @_;

  $name = caller()."::$name" unless ($name =~ /::/oax);

  no strict 'refs';

  return ( ) if (!defined *{ $name });

  my @slots;

  push @slots, 'SCALAR'
    if defined *{ $name }{SCALAR} and defined ${ *{ $name }{SCALAR} };

  foreach my $slot (qw( ARRAY HASH CODE IO )) {
    push @slots, $slot if defined *{ $name }{$slot};
  };

  return @slots;

   if (defined $slot) {
        return if $slot eq 'SCALAR' and not defined ${ *{ $name }{SCALAR} };
        return *{ $name }{$slot};
    };

    return \*{ $name };
};

#
# These are the elements in the @context array ref that's passed to each
# recursive invocation of format_xxx() handlers as well as format_anything().
#
# These fields should only contain global data which applies to the entire 
# traversal operation, i.e. this data must be independent of the node we're
# presently recursing into (for that sort of data, actual function call
# parameters on the stack should be used instead).
#

noexport:; use constant enum 
  qw(visited index_ref index_to_tree_node index_ref_counts
     flags max_depth one_line_array_max_length 
     one_line_hash_max_length max_string_length);

my $quotes_required_re = qr{[\s\,\x00-\x1F\x7F-\xFF]}oamsx;

#my $ansi_console_codes_placeholder = R.double_left_angle_bracket.Y.euler_e.R.double_right_angle_bracket.C;
my $ansi_console_codes_placeholder = ORANGE_2_3.double_left_angle_bracket.ORANGE.euler_e.ORANGE_2_3.double_right_angle_bracket.C;

sub format_clipped_string($;$$$$$$) {
  my ($s, $max_length, $subst_control_chars, $show_quotes, $color, $sym_color, $quote_color) = @_;

  $max_length //= INT_MAX;
  $subst_control_chars //= 1;

  $show_quotes //= ($s =~ $quotes_required_re);
  $color //= C;
  $sym_color //= R;
  $quote_color //= scale_rgb_fg($color, 0.5);

  my $from_end = ($max_length < 0);
  $max_length = -$max_length if ($max_length < 0);

  my $orig_length = length($s);
  if ($orig_length > $max_length) {
    $s = substr($s, ($from_end) ?
               max(($orig_length - $max_length), 0) : 0,
               min($max_length, $orig_length));
  }

  my $esc_code_repl = euler_e;
  $s =~ s{$ansi_console_escape_codes_re}{$esc_code_repl}oamsxg;

  if ($subst_control_chars)
    { $s = special_chars_to_printable_symbols($s, $color, $sym_color); }

  $s =~ s{$esc_code_repl}{$ansi_console_codes_placeholder}oamsxg;

  my $lq = ($show_quotes) ? $quote_color.left_quote : '';
  my $rq = ($show_quotes) ? $quote_color.right_quote : '';

  return $lq.$color.$s.$quote_color.
    (($orig_length > $max_length) ? elipsis_three_dots : '').$rq.X;
}

sub format_scalar_as_text(+$;$$) {
  my ($obj, $type, $max_string_length, $show_quotes) = @_;
  $type //= UNDEF;
  $max_string_length //= INT_MAX;

  return
    (($type == UNDEF) ? (R.x_signed.' undef ') :
    ($type == SCALAR) ? (G.$obj) :
    ($type == STRING) ? format_clipped_string("$obj", $max_string_length, 1, $show_quotes, C, R, C_2_3) :
    ($type == DUAL) ? (G.(0+$obj).K.' '.large_right_slash.' '.
    format_clipped_string("$obj", $max_string_length, 1, $show_quotes, C, R, C_2_3)) :
      (R.'UNKNOWN('.reftype($obj).', typeid '.$type.')'));
}

sub format_scalar(+++$$) {
  my ($obj, $node, $context, $level, $type) = @_;
  push @{$node->[0]}, format_scalar_as_text($_[0], $type // undef, $context->[max_string_length], 1);
  return $node;
}

my @scalar_ref_type_names = (
  'undef', 'scalar', 'string', 'dual',
  'ref', 'scalar', 'string', 'dual',
);

sub format_scalar_ref(+++$$) {
  my ($ref, $node, $context, $level, $type) = @_;
  my $obj = ${$ref};

  my $label = $node->[0];
  push @$label, LIGHTBLUE_3_4.'ref to '.LIGHTBLUE.'\\'.U.$scalar_ref_type_names[$type].UX;
  push @$node, format_anything(${$_[0]}, $node, $context, $level+1);
  return $node;
}

sub format_array(+++$$) {
  my ($array, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  my $n = scalar(@$array);
  $type = typeof($array->[0]) // UNDEF;

  push @$label, Y.U.'array'.UX.Y_1_2.wide_left_square_bracket.Y_2_3.'#'.Y.$n.Y_1_2.wide_right_square_bracket.'=';

  my $show_on_one_line = ($n < ($context->[one_line_array_max_length] // 0)) && (all { !ref } @$array);
  my $show_as_qw = $show_on_one_line && ($n > 0) && (all { ($_ =~ /\A $perl_identifier_re \Z/oamsx) } @$array);
  my $show_quotes = $show_on_one_line && ($n > 0) && (any { ($_ =~ /$quotes_required_re/oamsx) || (length > 40) || (!length) } @$array);

  if ($show_as_qw) {
    push @$label, C_3_4.' qw'.C_2_3.round_bold_left_paren.C.
      join(' ', @$array).C_2_3.round_bold_right_paren.X;
  } elsif ($show_on_one_line) {
    push @$label, Y_1_2.wide_left_square_bracket.X.
      join(K.', '.X, (map { format_scalar_as_text($_, typeof($_), $context->[max_string_length], $show_quotes) } @$array)).
      Y_1_2.wide_right_square_bracket.X;
  } else {
    for (my $i = 0; $i < scalar(@$array); $i++) {
      my $formatted_key = Y_1_2.'['.Y.$i.Y_1_2.']'.'  =  ';
      push @$node, format_anything($array->[$i], $node, $context, $level+1, $formatted_key);
    }
  }

  return $node;
}

sub format_hash(+++$$) {
  my ($hash, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  my $n = scalar keys %$hash;

  push @$label, PINK.U.'hash'.UX.PINK_2_3.wide_left_brace.'#'.PINK.$n.PINK_2_3.wide_right_brace.' = ';

  my $show_on_one_line = ($n < ($context->[one_line_hash_max_length] // 0)) && (all { !ref } (values %$hash));

  if ($show_on_one_line) {
    push @$label, PINK_2_3.wide_left_brace.X.
      join(K.', '.X, (pairmap {
        PINK.$a.PINK_1_2.' '.large_arrow_barbed.' '.X.format_scalar_as_text($b, typeof($b), $context->[max_string_length], 1)
      } %$hash)).
        PINK_2_3.wide_right_brace.X;
  } else {
    foreach my $key (sort keys %$hash) {
      my $formatted_key = PINK.$key.PINK_1_2.'  '.large_arrow_barbed.'  '.X;
      push @$node, format_anything($hash->{$key}, $node, $context, $level+1, $formatted_key);
    }
  }

  return $node;
}

sub format_code(+++$$) {
  my ($code, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  my $addr = hexstring(refaddr($code));
  my $name = sub_fullname($code) // ('<unknown @ '.$addr.'>');
  my $show_addr = ($name eq '__ANON__') || ($name eq '<unknown>');
  my $proto = prototype($code);

  push @$label, ORANGE_3_4.'sub '.ORANGE.U.$name.UX;
  push @$label, ORANGE_1_2.'('.ORANGE.$proto.ORANGE_1_2.')' if (defined $proto);
  push @$label, ORANGE_2_3.' @ '.ORANGE.$addr if ($show_addr);
  push @$label, ORANGE_1_2.' '.bold_left_brace.' '.K.elipsis_three_dots.ORANGE_1_2.' '.bold_right_brace.X;

  return $node;
}

my $regexp_comment_re = qr{(?<! \\) \# \N*+ \n}oamsx;

noexport:; sub colorize_regexp_text(+) {
  my ($re) = @_;

  my ($pattern, $modifiers) = ((is_regexp $re) ? regexp_pattern($re) : ("$re", ''));

  $pattern = $pattern
    =~ s{(\[[^\]]+\])}{$R$1$X}roamsxg
    =~ s{\\ (.)}{$K\\$M$1}roamsxg
    =~ s{(?= $regexp_comment_re)}{$K}roamsxg
    =~ s{((?<! \\) \( \? . | (?<! \\) \))}{$B$1$X}roamsxg
    =~ s{((?<! \\) \( (?! \?))}{$C$1$X}roamsxg
    =~ s{\\ (?! \w)}{$K\\$X}roamsxg
    =~ s{\|}{$R\|$X}roamsxg
    =~ s{\]}{$R]}roamsxg
    =~ s{((?<! \() [\+\*\?] | $braces_re)}{$Y$1$X}roamsxg;

  return ORANGE.'qr'.ORANGE_3_4.large_right_slash.X.$pattern.X.
    ORANGE_3_4.large_right_slash.ORANGE.$modifiers;
}

sub format_regexp(+++$$) {
  my ($regexp, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  push @$label, ORANGE.U.'regexp'.UX.ORANGE_1_2.' = '; 
  # ORANGE.'qr'.ORANGE_3_4.large_right_slash.K.' '.elipsis_three_dots.' '.ORANGE_3_4.large_right_slash.X;

  my $text = colorize_regexp_text($regexp);
  push @$label, $text;

  return $node;
}

sub format_blessed(+++$$) {
  my ($obj, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  my $class = classof($obj);
  push @$label, SKYBLUE_2_3.'class '.C.U.$class.UX.SKYBLUE_1_2.' = ';

  return $node;
}

sub format_glob(+++$$) {
  my ($glob, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  push @$label, W.U.'glob'.UX;

  return $node;
}

sub format_lvalue(+++$$) {
  my ($lvalue, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  push @$label, ORANGE.U.'lvalue'.UX;

  return $node;
}

sub format_format(+++$$) {
  my ($format, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  push @$label, B.U.'format'.UX;

  return $node;
}

sub format_io(+++$$) {
  my ($io, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  my $fd = fileno($io);
  my $filename = (defined $fd) ? path_of_open_fd($fd) : undef;

  my $text = M.U.'I/O'.UX;
  $text .= M_2_3.': fd '.M.$fd if (defined $fd);
  $text .= M_2_3.' '.M.large_arrow_barbed.M_2_3.' path '.M.$filename if (defined $filename);
  push @$label, $text;

  return $node;
}

sub format_vstring(+++$$) {
  my ($vstring, $node, $context, $level, $type) = @_;
  my $label = $node->[0];

  push @$label, G.U.'vstring'.UX.G_1_2.' = '.G.$vstring;

  return $node;
}

my @type_to_format_func = (
  \&format_scalar,  # UNDEF
  \&format_scalar,  # SCALAR
  \&format_scalar,  # STRING
  \&format_scalar,  # DUAL
  \&format_scalar_ref,  # REF_REF
  \&format_scalar_ref,  # SCALAR_REF
  \&format_scalar_ref,  # STRING_REF
  \&format_scalar_ref,  # DUAL_REF
  \&format_array,  # ARRAY_REF
  \&format_hash,  # HASH_REF
  \&format_code,  # CODE_REF
  \&format_regexp,  # REGEXP_REF
  \&format_blessed,  # BLESSED_REF
  \&format_glob,  # GLOB_REF
  \&format_lvalue_ref,  # LVALUE_REF
  \&format_format_ref,  # FORMAT_REF
  \&format_io_ref,  # IO_REF
  \&format_vstring_ref,  # VSTRING_REF
);

use constant enum (
  TYPE_CATEGORY_SCALAR,    # undef, number, string, dual
  TYPE_CATEGORY_SCALAR_REF,# ref to scalar
  TYPE_CATEGORY_REF_REF,   # ref to ref
  TYPE_CATEGORY_CONTAINER, # ref to array or hash
  TYPE_CATEGORY_CODE,      # ref to code block or sub
  TYPE_CATEGORY_SPECIAL,   # ref to regexp, object, glob, lvalue, format, io, vstring
);

my @type_to_category = (
  (TYPE_CATEGORY_SCALAR) x 4,
  TYPE_CATEGORY_REF_REF,
  (TYPE_CATEGORY_SCALAR_REF) x 3,
  TYPE_CATEGORY_CONTAINER,
  TYPE_CATEGORY_CONTAINER,
  TYPE_CATEGORY_CODE,
  (TYPE_CATEGORY_SPECIAL) x 7,
);

#
# format_anything() is the first function called to start the recursive 
# traversal of a data structure graph, and is also called by the type-
# specific handler functions (format_xxx()) to continue recursively
# processing each item within container types (arrays, hashes, classes
# and references to scalars or refs). All other data types are terminal
# nodes bounding the edges of the graph.
#
# This function essentially creates a new tree node, fills out the
# first portion of its label with generic type agnostic information
# (like the per-line index and address prefix columns, etc.), then
# invokes one of the format_xxx() handler functions (listed in the
# @type_to_format_func dispatching array) to finish preparing the
# tree node. 
#
# Both this function and all the handlers take a single reference
# argument pointing to a context array which contains any data
# that is invariant throughout the recursion and thus would be
# wasteful to repeatedly push onto the stack. This data includes
# both the tracking arrays and hashes used to detect cycles and
# previously seen data references, as well as additional fields
# that are set based on the optional settings external callers
# can request to control the appearance of the output.
#
# For container data types, the handler function may either add
# sub-nodes to the tree node on its own (simple cases only), or 
# for each item within the container, it calls format_anything()
# to descend the graph and dispatch the correct handler.
#
# Handler functions may pass a string in the $formatted_key
# argument, which format_anything() will add to the tree node
# before calling any handlers. This is used to annotate each
# item in an array or hash with its index or key, independent
# of the actual data type of that item.
#
sub format_anything(+++$;$) {
  my ($obj, $parent_node, $context, $level, $formatted_key) = @_;

  my ($visited, $index_ref, $index_to_tree_node, $index_ref_counts, $flags, $max_depth) = @$context;

  my $type = unblessed_typeof($_[0]) // UNDEF;
  my $category = $type_to_category[$type];
  my $class = classof($_[0]);

  #
  # Construct the initial generic parts of the tree node,
  # and then call the type specific handler to finish it;
  # these handlers may recurse into format_anything() for
  # nested data structures like arrays, hashes and refs.
  #
  my $addr = (defined $_[0]) ? (is_ref($_[0]) ? Scalar::Util::refaddr($_[0]) : Scalar::Util::refaddr(\$_[0])) : 0;

  my $repeat = (is_ref($_[0]) && (exists $visited->{$addr})) ? 1 : 0;

  # If we already visited this object, use the counter we already assigned it;
  # otherwise assign it the current counter and then increment the counter:
  my $index = ($repeat) ? $visited->{$addr} : ${$index_ref}++;

  my $index_color = ($repeat) ? visited_counter_color : normal_counter_color;
  my $addr_color = ($repeat) ? visited_addr_color : normal_addr_color;

  my $label = [
    ($repeat ? visited_bg_color_prefix_tree_cmd : normal_bg_color_prefix_tree_cmd),
    [ 
      TREE_CMD_PREFIX, 
      $index_color.' '.($repeat ? arrow_open_tri : ' ').' '.
      $index_color.padstring($index, -5).' '.$addr_color,
        #($repeat ? visited_at_sign_color : $at_sign_color).' '.large_at_sign.
        #(($addr) ? $addr_color : $undef_addr_color),
    ],
    [
      TREE_CMD_PREFIX,
      (($addr) ? sprintf('% 12x', $addr) : (R_3_4.(' ' x 6).x_signed.' null')).' '.X,
    ],
    # vert_separator_prefix_tree_cmd,
    (($repeat) ? visited_branch_color_tree_cmd : 
       ($type_to_branch_color_tree_cmd[$type] // '')),
    (($repeat) ? visited_branch_style_tree_cmd : 
       ($is_ref) ? ref_branch_style_tree_cmd :
       normal_branch_style_tree_cmd),
    $type_to_symbol_tree_cmd[$type],
  ];

  if ($level == 0) {
    # Global settings that will be propagated down all sub-branches:
    push @$label, [ TREE_CMD_HORIZ_BRANCH_LENGTH, 2 ];
    push @$label, [ TREE_CMD_MAX_FIELD_WIDTH, get_terminal_width_in_columns() - ((3+5+12)+1+16), 0 ];
  }

  if (defined $formatted_key) {
    push @$label, 
      ((is_array_ref $formatted_key) ? @$formatted_key : $formatted_key),
  }

  my $node = [ $label ];

  if ($repeat) {
    $index_ref_counts->[$index]++;
    my $refcount = $index_ref_counts->[$index];
    push @$label, ORANGE_2_3.'(same as #'.ORANGE.$index.ORANGE_2_3.')';
    return $node;
  }

  if (defined $class) {
    push @$label, SKYBLUE_1_2.double_left_angle_bracket.
      SKYBLUE_2_3.'class '.C.U.$class.UX.
      SKYBLUE_1_2.double_right_angle_bracket.' ';
  }

  if ($addr) {
    $visited->{$addr} = $index; 
    $index_to_tree_node->[$index] = $node;
  }

  my $func = $type_to_format_func[$type];
  $node = $func->($obj, $node, $context, $level, $type);

  return $node;
}

our @ref_type_index_to_description = (
  'Undefined value', 'Numeric scalar value', 'String', 'Dual scalar/string',
  'Reference to reference', 'Reference to numeric scalar value', 'Reference to string', 'Reference to dual scalar/string',
  'Array', 'Hash', 'Code block or subroutine', 'Regular expression',
  'Object of class', 'Typeglob', 'L-value', 'Format',
  'I/O object', 'Version string', 'Unknown type'
);

noexport:; sub format_title_from_caller {
  my ($caller_package, $caller_filename, $caller_line, $caller_function) = @_;
  return X.B.'(from '.G.($caller_function =~ s{\A (?> \w+ ::)*+}{}roamsxg).
    B.' in '.Y.$caller_filename.B.':'.M.$caller_line.B.')'.X;
};

sub format_data_as_tree(+;$%) {
  my ($obj, $title, %options) = @_;

  my $type = typeof($obj);
  my $description = $ref_type_index_to_description[$type] // 'Unknown type';

  if (defined $title) {
    $title = G.U.$title.UX.K.': '.X;
  } else {
    $title = format_title_from_caller(caller(0));
  }

  #
  # Create structures shared throughout the recursion process
  # if this is the top level invocation of format_anything():
  #
  my $visited = { };
  my $index_to_tree_node = [ ];
  my $index_ref_counts = [ ];

  #
  # Note that counter_ref will always point to the instance of the counter
  # variable declared by the top level call of the recursive descent tree, 
  # so it can be incremented and used correctly from any recursion level:
  #
  my $index = 0;

  my $flags = 
    (($options{show_addresses} // 1) 
       ? DDS_OPTION_SHOW_ADDRESSES : 0) |
    (($options{strip_ansi_console_codes} // 1) 
       ? DDS_OPTION_STRIP_ANSI_CONSOLE_STRINGS : 0) |
    (($options{strip_unicode} // 1) 
       ? DDS_OPTION_STRIP_UNICODE_STRINGS : 0);

  my $context = [
    $visited, \$index, $index_to_tree_node, $index_ref_counts,
    $flags,
    $options{max_depth} // INT_MAX, 
    $options{one_line_array_max_length} // 12,
    $options{one_line_hash_max_length} // 6,
    $options{max_string_length} // 80,
  ];
  
  my $tree = format_anything($obj, undef, $context, 0, $title);

  #
  # Iterate through all the tree nodes based on their unique counter values,
  # and add a visual indicator and reference count to any nodes that are 
  # referenced from one or more other parts of the data structure. We need
  # to do this *after* we've constructed the entire tree so we're aware of
  # every possible reference.
  #

  while (my ($i, $node) = each @$index_to_tree_node) {
    my $count = $index_ref_counts->[$i];
    next if (!$count);

    my $label = $node->[0];
    my ($ref_to_counter, $addr_or_ref_count) = ${$label}[1,2];

    $label->[0] = referenced_bg_color_prefix_tree_cmd;

    $label->[1] = [ 
      TREE_CMD_PREFIX, 
      referenced_counter_color.' '.arrow_tri.' '.
      padstring($i, -5).referenced_addr_color.' ',
    ];

    push @$label,
      '   '.LIGHTBLUE_2_3.'('.LIGHTBLUE_3_4.'referenced '.
        referenced_counter_color.$count.
        referenced_counter_dark_color.
        small_roman_numeral_x.LIGHTBLUE_2_3.')'.X;
  }

  return $tree;
}

sub format_data(+;$%) {
  my ($obj, $title, %options) = @_;
  my $tree = format_data_as_tree($obj, $title // format_title_from_caller(caller(0)), %options);
  return format_tree($tree);
}

sub print_data(+;$$%) {
  my ($obj, $title, $fd, %options) = @_;
  $fd //= STDOUT;
  my $tree = format_data_as_tree($obj, $title // format_title_from_caller(caller(0)), %options);
  my $text = format_tree($tree);
  printfd($fd, $text);
}

#
# Short name for the equivalent of the print_data() function,
# plus some additional context sensitive intelligence so that
# it will automatically print the formatted tree to STDERR if
# the return value is never used by the caller; otherwise it
# is assumed that the caller will print the returned text.
#
sub pp(+;$$%) {
  my ($obj, $title, $fd, %options) = @_;
  my $return_value_used = (defined wantarray);

  my $tree = format_data_as_tree($obj, $title // format_title_from_caller(caller(0)), %options);
  my $text = format_tree($tree);

  if ((!$return_value_used) || (defined $fd)) {
    $fd //= STDERR;
    printfd($fd, $text);
  }

  return $text if ($return_value_used);
}

1;
