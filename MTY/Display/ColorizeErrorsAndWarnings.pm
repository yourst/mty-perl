# -*- cperl -*-
#
# MTY::Display::ColorizeErrorsAndWarnings
#
# Copyright 2003 - 2014 Matt T. Yourst <yourst@yourst.com>
#
# Colorize: ANSI console colors and attributes for any terminal
# (works with Linux console, XTerm, Mac OS X, BSD, Solaris, etc)
#

package MTY::Display::ColorizeErrorsAndWarnings;

use integer; use warnings; use Exporter::Lite;

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($abort_on_warnings $die_error_message $include_stack_backtrace
     $max_warning_count $max_warning_line_count
     $print_function_args_in_backtrace $warning_count_so_far
     $warning_line_count_so_far $warning_message
     %already_printed_warning_messages die_and_print die_in_color
     die_or_warn_in_color format_stack_backtrace
     replace_ref_data_type_name_with_sigil simple_warning
     simple_warning_string warn_in_color warn_without_stack_trace);

use Carp;
use Carp qw(cluck verbose shortmess longmess);

use MTY::System::POSIX;
use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Common::Common qw(INT_MAX LONG_MAX);

use MTY::Common::Strings;
use MTY::Filesystem::Files;
use MTY::RegExp::Define;
use MTY::RegExp::Blocks;
use MTY::RegExp::FilesAndPaths;
use MTY::Display::Colorize;
use MTY::Display::ColorCapabilityCheck;
use MTY::Display::PrintableSymbols;
use MTY::Display::TextInABox;

our $abort_on_warnings = 3;
our $die_error_message = '(unknown)';
our $warning_message = '(unknown)';

our $include_stack_backtrace = 1;
our $print_function_args_in_backtrace = 1;
our $max_warning_count = 10;
our $max_warning_line_count = undef;

our $warning_count_so_far = 0;
our $warning_line_count_so_far = 0;

our %already_printed_warning_messages = ( );

sub simple_warning_string {
  return ' '. $Y.warning_sign.' '.$Y.$U.'WARNING:'.$X.' '.$R.join('', @_).$X.NL;
}

sub simple_warning {
  print(STDERR simple_warning_string(@_));
}

my $perl_package_and_identifier_re = qr{((?: \w+ ::)*) (\w+)}oax;

my $call_stack_line_re = 
  qr{(?: 
       $perl_package_and_identifier_re
       \( ($inside_parens_re) \) \s+
       (?: called \s+)? 
     )? at \s+ (\S+) \s+ line \s+ (\d+) \.?
  }oax;

sub format_stack_backtrace($) {
  my ($callstack_text) = @_;

  my $backtrace = '';

  my $cwd = quotemeta(realpath(getcwd()));
  my $cwd_re = qr{$cwd/}oamsx;

  my @callstack_lines = split(/\s* \n \s*/oamsx, $callstack_text);
  shift @callstack_lines; # remove point of origin, since we already printed it

  my @callstack = ( );
  my $longest_module_and_function_name = 0;

  foreach my $line (@callstack_lines) {
    my @fields = $line =~ /$call_stack_line_re/oamsx;

    if ((scalar @fields) < 6) { 
      # We can't handle this backtrace format (typically it contains an 'eval'):
      return $callstack_text; 
    }

    my ($module, $function, $args, $unused, $filename, $line) = undefs_to_empty_strings(@fields);

    $module =~ s{::$}{}oax;          # remove trailing '::' if present

    # no module name but full path (which implies the module name):
    if (ends_with($filename, '/'.($module =~ s{::}{/}roaxg).'.pm')) { $module = ''; }
    if ($module eq 'main') { $module = ''; }

    # Don't print the current directory in the path:
    $filename =~ s{$cwd_re}{}oamsxg;
    $filename =~ s{/usr/lib/perl5/(?: (site|vendor)_perl/)? (?: 5\.[\d\.]+/)? }{$B.'<'.(is_there($1) ? $1 : 'base').'>/'.$Y}oamsxge;

    push @callstack, [ $module, $function, $filename, $line, $args ];
      
    set_max($longest_module_and_function_name, (is_there($module) ? length($module.'::') : 0) + length($function));
  }

  foreach my $callstack_line (@callstack) {
    my ($module, $function, $filename, $line, $args) = @$callstack_line;
      
    if ($print_function_args_in_backtrace && is_there($args)) {
      sub replace_ref_data_type_name_with_sigil($$) {
        my ($typename, $refaddr) = @_;
        my $typesym = $ref_type_index_to_symbol[
          $ref_type_string_to_index{$typename}];
        if ($typesym eq '%') { $typesym = '%%'; }
        return $C.$typesym.$Y.$refaddr;
      }
      $args =~ s{\b(\w++)\((0x\w++)\)}{replace_ref_data_type_name_with_sigil($1, $2)}oamsxge;
      $args =~ s{\s*+,\s*+}{$K, $C}oamsxg;
      $args = $K.' ('.$G.$args.$K.')';
    } else {
      $args = '';
    }
      
    my $module_and_function = $B.(is_there($module) ? $module.'::' : '').$C.$function;
      
    $backtrace .= 
      $K.' '.dot.' '.$B.padstring($module_and_function, $longest_module_and_function_name).
        $K.' in '.$Y.$filename.$K.':'.$M.$line.$args.$X.NL;
  }
    
  return $backtrace;
}

sub die_or_warn_in_color($$;@) {
  my $type = shift;
  my $do_include_stack_backtrace = shift;

  $do_include_stack_backtrace //= $include_stack_backtrace;
  my $is_warn = ($type eq 'WARNING') ? 1 : 0;

  if ($is_warn && (defined $abort_on_warnings) && ($warning_count_so_far >= $abort_on_warnings)) {
    $type = 'ERROR';
    $is_warn = 0;
  }

  if (!$is_warn) { $do_include_stack_backtrace = 1; }

  my $m = $_[0] // '(unknown)';
  chomp $m;

  my $warning_line_count = 0;
  
  if ($is_warn) {
    $max_warning_line_count //= get_terminal_height_in_lines();

    $already_printed_warning_messages{$m}++;
    my $repeats = $already_printed_warning_messages{$m};

    if (($warning_count_so_far >= $max_warning_count) ||
          ($warning_line_count_so_far >= $max_warning_line_count) ||
            ($repeats > 1)) {
      my $excess = max($warning_count_so_far - $max_warning_count, 0);
      my $divisor = 
        ($excess < $max_warning_count) ? 1 : 
        ($excess < $max_warning_count*10) ? 10 :
        ($excess < $max_warning_count*50) ? 50 : 100;

      if (($warning_count_so_far % $divisor) == 0) {
        print(STDERR $R.'('.$U.'Warning:'.$UX.' '.$warning_count_so_far. ' '.$Y.$U.
                'WARNING'.$UX.$R.' messages silenced)'.$X.NL);
      }
      goto update_warning_counts;
    }
  }

  if (!is_stderr_color_capable()) {
    if ($is_warn) { 
      $warning_line_count = ((scalar @_) > 0) ? count_lines(@_) : 1;
      warn @_;
      goto update_warning_counts; 
    } else { 
      die @_; 
    }
  }

  # This is redundant in the error message 
  # since it's also in the stack backtrace:
  $m =~ s{\s at \s ((?: (?> \( [^\)]+ \)) | \S+)) \s line \s (\d+)\.?}{\n${K}in $Y$1$K:$M$2$K}oamsxg;
  $m =~ s{\$ $perl_package_and_identifier_re \b}{${B}${1}${G}\$${2}${R}}oamsxg;

  my $backtrace = ($do_include_stack_backtrace) ? format_stack_backtrace(shortmess()) : undef;

  my $warning_color = fg_color_rgb(255, 255, 0);
  my $error_color = fg_color_rgb(255, 192, 0); # bright red-orange

  my $prefix = 
    (($is_warn) ? $warning_color.warning_sign : $error_color.x_symbol) . ' ';

  my $message = '%{tab}'.$prefix.($is_warn ? $warning_color : $error_color).$type;

  # if ($is_warn && ($max_warning_line_count < INT_MAX))
  #   { $message .= '  '.$R.'#'.$warning_line_count_so_far; }
  $message .= ' '.NL;
  $message .= $R.$m.$X.NL;
  if (!$is_warn) { $message .= NL.$K.'('.$G.$0.$R.' has been terminated.'.$K.')'.NL; }

  if (defined $backtrace) {
    $message .= '%{div=dashed}'.NL.
      $G.$U.'Stack backtrace'.$X.$K.' (after point of origin shown above):'.$X.NL.
        $backtrace.NL;
  }

  my $boxtype = ($is_warn) ? 'rounded' : 'heavy';

  my $divtype = 
    ($is_warn) ? 'single' : 'double';

  $message = text_in_a_box($message, -1, ($is_warn ? $Y : $R), $boxtype, $divtype).$X.NL;

  $warning_line_count = count_lines($message);
  print(STDERR $message);

  update_warning_counts:
  if ($is_warn) {
    $warning_count_so_far++;
    $warning_line_count_so_far += $warning_line_count;
    
    if (($warning_count_so_far == $max_warning_count) ||
          ($warning_line_count_so_far == $max_warning_line_count)) {
      print(STDERR NL.$R.'(Warning: '.$R.$warning_count_so_far.
              ' '.$Y.$U.'WARNING'.$UX.$R.' messages occupying '.
                $warning_line_count_so_far.
                ' lines have already been reported; '.$Y.$U.
                'silencing any subsequent warnings'.$UX.$R.')'.$X.NL.NL);
    }
  }

  if (!$is_warn) { exit(255); }
  return 1;
}

sub die_in_color {
  die @_ if $^S; # if we're called from inside an eval { ... }
  die_or_warn_in_color('ERROR', $include_stack_backtrace, @_);
}

sub warn_in_color {
  die @_ if $^S; # if we're called from inside an eval { ... }
  die_or_warn_in_color('WARNING', $include_stack_backtrace, @_);
}

sub warn_without_stack_trace { 
  die_or_warn_in_color('WARNING', 0, @_); 
}

sub die_and_print($$;$) {
  die @_ if $^S; # if we're called from inside an eval { ... }
  my ($primary_error, $postmortem_message, $include_backtrace) = @_;
  # local (*primary_error, *postmortem_message, *include_backtrace) = \ (@_);

  die_or_warn_in_color('ERROR', $include_backtrace // 1, $primary_error);
  print(STDERR $postmortem_message);
  exit(255);
}

INIT {
  my $env_var_name = __PACKAGE__ =~ s/::/_/roaxg;
  # my $config = ($ENV{$env_var_name} // '').' '.($ENV{COLORIZE} // '');
  my $config = $ENV{COLORIZE};
  my $disabled = 0;

  if (is_there($config)) {
    my $options = parse_list_of_key_equals_value_into_hash($config);
    if (($options->{enabled} // 1) == 1) { $disabled = 0; }
    if (exists $options->{disabled}) { $disabled = 1; }
    my $aow = $options->{max_warning_count} // $options->{abort_on_warnings};
    if (defined $aow) { $abort_on_warnings = $aow; }
  }

  if (!$disabled) {
    $Carp::Verbose = 1;
    $Carp::MaxEvalLen = 32;
    $Carp::MaxArgLen = 32;
    $Carp::MaxArgNums = 8;
    $Carp::RefArgFormatter = sub {
      my $t = typeof($_[0]);
      return $ref_type_index_to_symbol[typeof($_[0])].
        sprintf('0x%x', refaddr($_[0]));
    };

    $Carp::CarpInternal{(__PACKAGE__)} = 1;
    $SIG{__DIE__} = sub { die_in_color(@_); };
    $SIG{__WARN__} = sub { warn_in_color(@_); };
  }
};

1;
