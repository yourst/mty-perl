#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Display::TreeBuilder
#
# Copyright 2015 Matt T. Yourst <yourst@yourst.com>
#
# Utility functions for easily constructing printable trees from a variety
# of common hierarchical and graph oriented data structures, including:
#
# - Dependency Graphs to Trees:
#  
#   Sets of nodes where each node provides an array of its dependencies
#   on other nodes; caller defined keys are used to identify nodes and
#   each of their dependencies. This code provides numerous ways to
#   customize the visual appearance of the resultant tree (which is
#   the dependency graph from the viewpoint of a specified origin node),
#   by mapping each key into a label that can contain the full range of
#   formatting commands supported by the underlying Tree package. There
#   are also a variety of options for controlling the scope and means
#   of recursive descent throughout the dependency graph, as well as
#   options for controlling the presentation and handling of previously
#   visited nodes, nodes with the same set of dependencies as earlier
#   nodes, and numerous other features.
#
# - Indented Text to Trees:
#
#   Converts lines of text indented according to their logical nesting
#   into fully formatted trees. The indent to tree level mapping can
#   either be specified manually or automatically derived. Alternatively,
#   the caller can use the labels_and_levels_to_tree() function to 
#   produce the same types of trees when the nesting level of each node 
#   is already known as an integer value, rather than being expressed
#   indirectly through its indentation in a text file.
#
# - Delimited Paths to Trees:
#
#   Generates trees from lists of strings in the format of paths with
#   their components delimited by a specified regexp (or simply given
#   directly as an array of arrays). This can easily handle both the
#   obvious case of filesystem paths delimited by '/', as well as
#   any other similar data set.
#

package MTY::Display::TreeBuilder;

use integer; use warnings; use Exporter qw(import);

use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Common::Strings;
use MTY::Display::Colorize;
use MTY::Display::ColorCapabilityCheck;
use MTY::Display::ANSIColorREs;
use MTY::Display::PrintableSymbols;
use MTY::Display::PrintableSymbolTools;
use MTY::Display::TextInABox;
use MTY::Display::Table;
use MTY::Display::Tree;
use MTY::RegExp::Define;
use MTY::RegExp::Tools;
use MTY::RegExp::Blocks;
use MTY::RegExp::Numeric;
use MTY::RegExp::Strings;
use MTY::RegExp::PerlSyntax;
#pragma end_of_includes

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(create_level_skip_map get_shaded_tree_label indented_text_to_tree
     dependency_graph_to_tree labels_and_levels_to_tree
     create_histogram_of_used_levels tree_of_hashes_to_printable_tree
     delimited_paths_to_tree_of_hashes $split_leading_spaces_from_text_re
     dependency_graph_to_tree_recursive DEPENDENCY_GRAPH_TO_TREE_NO_RECURSION
     split_text_into_arrays_of_lines_and_indents
     DEPENDENCY_GRAPH_TO_TREE_HIDE_VISITED_BRANCHES
     DEPENDENCY_GRAPH_TO_TREE_SHOW_DEPENDENCY_COUNT
     DEPENDENCY_GRAPH_TO_TREE_FIND_DUPLICATE_DEP_SETS
     DEPENDENCY_GRAPH_TO_TREE_COMPACT_ALL_VISITED_DEPS
     DEPENDENCY_GRAPH_TO_TREE_COMPACT_REPEAT_INDICATOR
     DEPENDENCY_GRAPH_TO_TREE_REPRINT_VISIBLE_BRANCHES);

use constant enumbits 
  qw(DEPENDENCY_GRAPH_TO_TREE_HIDE_VISITED_BRANCHES
     DEPENDENCY_GRAPH_TO_TREE_REPRINT_VISIBLE_BRANCHES
     DEPENDENCY_GRAPH_TO_TREE_SHOW_DEPENDENCY_COUNT
     DEPENDENCY_GRAPH_TO_TREE_NO_RECURSION
     DEPENDENCY_GRAPH_TO_TREE_FIND_DUPLICATE_DEP_SETS
     DEPENDENCY_GRAPH_TO_TREE_COMPACT_ALL_VISITED_DEPS
     DEPENDENCY_GRAPH_TO_TREE_COMPACT_REPEAT_INDICATOR);

my ($default_tree_symbol_arrow_tri, $default_tree_symbol_arrow_filled_tri,
    $default_tree_symbol_arrow_open_tri, $default_tree_symbol_checkmark,
    $default_tree_symbol_red_x, $visited_branch_style_tree_cmd,
    $visited_branch_color_tree_cmd);

#
# These are pre-formatted tree node attributes we declare only once 
# here so we can simply reference them later rather than needlessly 
# using distinct arrays for the same constant content:
#

$default_tree_symbol_arrow_tri =
  [ TREE_CMD_SYMBOL, B.arrow_tri, B.arrow_open_tri ];
  
$default_tree_symbol_arrow_filled_tri =
  [ TREE_CMD_SYMBOL, arrow_tri ];
  
$default_tree_symbol_arrow_open_tri =
  [ TREE_CMD_SYMBOL, arrow_open_tri ];
  
$default_tree_symbol_checkmark =
  [ TREE_CMD_SYMBOL, G_2_3.checkmark ];
  
$default_tree_symbol_red_x =
  [ TREE_CMD_SYMBOL, R.x_symbol ];

$visited_branch_style_tree_cmd =
  [ TREE_CMD_BRANCH_DASHED, 1 ];
  
$visited_branch_color_tree_cmd =
  [ TREE_CMD_BRANCH_COLOR, scale_rgb_fg($tree_branch_color, 1.0) ];

noexport:; sub get_shaded_tree_label($++;$) {
  my ($key, $key_to_shaded_label, $label, $ratio) = @_;
  $ratio = 0.6;

  my $shaded_label = $key_to_shaded_label->{$key};
  if (defined $shaded_label) { return $shaded_label; }

  if (is_array_ref $label) {
    $shaded_label = [ map {
      ((is_array_ref $_) ? ((($_->[0] == TREE_CMD_SYMBOL) && (defined $_->[1]))
         ? [ TREE_CMD_SYMBOL, scale_rgb_fg_in_string($_->[1], $ratio) ] : $_)
       : (scale_rgb_fg_in_string($_, $ratio)))
    } @$label ];
  } else {
    die;
    $shaded_label = scale_rgb_fg_in_string($label, $ratio);
  }

  $key_to_shaded_label->{$key} = $shaded_label;
  return $shaded_label;
}

noexport:; sub dependency_graph_to_tree_recursive {
  my ($from, $context) = @_;
  my ($key_to_deplist, $key_to_label, $options, 
      $visited, $origin, $key_to_shaded_label,
      $repeated_direct_dep_sets) = @$context;

  my $reprint_visited_branches = 
    ($options & DEPENDENCY_GRAPH_TO_TREE_REPRINT_VISIBLE_BRANCHES) != 0;
  my $show_dep_counts = 
    ($options & DEPENDENCY_GRAPH_TO_TREE_SHOW_DEPENDENCY_COUNT) != 0;
  my $hide_visited_branches =
    ($options & DEPENDENCY_GRAPH_TO_TREE_HIDE_VISITED_BRANCHES) != 0;
  my $no_recursion = 
    ((($options & DEPENDENCY_GRAPH_TO_TREE_NO_RECURSION) != 0) && ($from ne $origin)) ? 1 : 0;

  my $deps = $key_to_deplist->{$from};
  my @one_elem_array = ( $deps );
  $deps = (defined $deps) ? ((ref $deps) ? $deps : \@one_elem_array) : \@empty_array;

  my $n = scalar(@$deps);

  my $already_visited = $visited->{$from};
  my $label = $key_to_label->{$from} // $from;
  my $info;

  if (defined $already_visited && (!$reprint_visited_branches))
    { return $already_visited; }

  if (!is_array_ref $label) { $label = [ Y.$label.' '.X ]; }

  $info = [
    $default_tree_symbol_arrow_tri,
    @$label,
  ];

  if ($from eq $origin) {
    # this is the root node:
    push @$info, 
      [ TREE_CMD_HORIZ_BRANCH_LENGTH, 2 ],
      [ TREE_CMD_BRANCH_STYLE, 'rounded' ];
  }

  if (($n > 0) && $show_dep_counts) 
    { push @$info, K.' ('.C.$n.B.' deps'.$K.')'.X; }

  my $node = [ $info ];

  my $node_symbol_cmd = first { ((is_array_ref $_) && ($_->[0] == TREE_CMD_SYMBOL)) } @$label;

  my $shaded_label = get_shaded_tree_label($from, $key_to_shaded_label, $label);

  if ($options & DEPENDENCY_GRAPH_TO_TREE_COMPACT_REPEAT_INDICATOR) {
    $already_visited_node = [ [
      $default_tree_symbol_checkmark,
      $visited_branch_color_tree_cmd,
      $visited_branch_style_tree_cmd,
      @$shaded_label,
      LIGHTBLUE_3_4.' '.counterclockwise_curved_arrow.' '
    ] ];
  } else {
    $already_visited_node = [ [
      $default_tree_symbol_checkmark,
      $visited_branch_color_tree_cmd,
      $visited_branch_style_tree_cmd,
      @$shaded_label,
      LIGHTBLUE_3_4.' '.large_arrow_barbed.' '.
      wide_left_square_bracket.
      LIGHTBLUE.counterclockwise_curved_arrow.' '.
      LIGHTBLUE_3_4.'see above'.
      wide_right_square_bracket.X,
    ] ];
  }

  $visited->{$from} = $already_visited_node;

  if ($no_recursion) { return $node; }

  my $dep_count = scalar(@$deps);

  my $already_visited_all_direct_deps =
    (all { ((defined $_) && (exists $visited->{$_})) } @$deps) && ($dep_count > 0);

  #
  # First try to find another node with exactly the same (sorted) list of
  # dependencies as this node. If no matches are found, remove the last
  # dependency and try again, then the last 2, and so forth until the set
  # is empty. This is implemented by concatenating all of this node's
  # dependency names together, then on each successive iteration, we
  # subtract the length in characters of the last dependency to be
  # removed, and try again with that shorter substring. This avoids
  # wasting time rebuilding the combined key string again and again,
  # since defining a substring doesn't even need to copy the text.
  # 
  my $dep_set_hash_key = join('', map { $_.'|' } @$deps);
  my $dep_set_hash_key_length = length $dep_set_hash_key;
  my $shared_dep_count = $dep_count;
  my $same_deps_as_key = undef;

  while ($shared_dep_count > 0) {
    $same_deps_as_key = $repeated_direct_dep_sets->
      {substr($dep_set_hash_key, 0, $dep_set_hash_key_length)};
    last if (defined $same_deps_as_key);
    $dep_set_hash_key_length -= (length($deps->[$shared_dep_count-1]) + 1);
    $shared_dep_count--;
  }

  my $all_shared = ($shared_dep_count == $dep_count);
 
  $repeated_direct_dep_sets->{$dep_set_hash_key} //= $from;

  if ($already_visited_all_direct_deps && ($dep_count >= 2) && 
      ($options & DEPENDENCY_GRAPH_TO_TREE_COMPACT_ALL_VISITED_DEPS)) {
    push @$info, 
      # [ TREE_CMD_FIELD ],
      # [ TREE_CMD_MAX_FIELD_WIDTH, 120 ],
      ' '.LIGHTBLUE_2_3.'('.LIGHTBLUE.'already listed all '.
        W.(scalar @$deps).LIGHTBLUE.' deps'.LIGHTBLUE_2_3.'): '.K;
    if (!defined $same_deps_as_key) {
      push @$info, (map { 
        my $label = $key_to_label->{$_} // $_;
        my $shaded_label = get_shaded_tree_label($_, $key_to_shaded_label, $label);
        (@$shaded_label, K.', '.X);
      } @$deps);
    }

    return $node;
  }

  if ((defined $same_deps_as_key) && ($already_visited_all_direct_deps) && 
      ($dep_count > 1) && ($options & DEPENDENCY_GRAPH_TO_TREE_FIND_DUPLICATE_DEP_SETS)) {
    my $label_of_same_deps_key = $key_to_label->{$same_deps_as_key} // $same_deps_as_key;

    my @label_without_tree_cmds = (is_array_ref $label_of_same_deps_key)
      ? ( grep { (!is_array_ref $_) } @$label_of_same_deps_key ) 
      : ( $label_of_same_deps_key );

    my $identical_dep_set_node = [ [
      [ TREE_CMD_SYMBOL, R.counterclockwise_curved_arrow ],
      [ TREE_CMD_BRANCH_STYLE, 'rounded' ],
      [ TREE_CMD_BRANCH_COLOR, K_3_4 ],
      [ TREE_CMD_BRANCH_DASHED, 1, 1 ],
      R_3_4.double_left_paren.R.
        (($all_shared) ? 'same set' : 'same initial subset').
        ' of '.ORANGE.$shared_dep_count.R.' deps as '.ORANGE,
      @label_without_tree_cmds,
      ((!$all_shared) ? (R.' + '.ORANGE.($dep_count - $shared_dep_count).
         R.' unique deps') : ( )),
      R_3_4.double_right_paren,
    ] ];
    push @$node, $identical_dep_set_node;

    return $node if ($all_shared);
  }

  foreach my $dep (@{$deps}[$shared_dep_count .. ($dep_count-1)]) {
    next if (!defined $dep);

    next if (exists($visited->{$dep}) && $hide_visited_branches);

    my $label = $key_to_label->{$dep} // $dep;
    if (!is_array_ref $label) { $label = [ $label ]; }
    if ($dep eq $origin) {
      push @$node, [[
        $default_tree_symbol_red_x.M,
        @$label,
        '  '.X.R.U.'(circular dependency)'.X
      ]];
    } else {
      push @$node, dependency_graph_to_tree_recursive($dep, $context);
    }
  }

  return $node;
}

sub dependency_graph_to_tree($+;+$+$) {
  my ($from, $key_to_deplist, $key_to_label, $options, $visited, $origin) = @_;

  $key_to_label //= { };
  $options //= 
    DEPENDENCY_GRAPH_TO_TREE_FIND_DUPLICATE_DEP_SETS |
    DEPENDENCY_GRAPH_TO_TREE_COMPACT_REPEAT_INDICATOR;
  $visited //= { };
  $origin //= $from;
  my $key_to_shaded_label = { };
  my $repeated_direct_dep_sets = { };

  #
  # Sort each dependency list in ascending alpha order so we'll get consistent
  # comparisons between identical lists associated with different nodes:
  #
  foreach my $deplist (values %$key_to_deplist) { @$deplist = sort @$deplist; }

  my $context = [ 
    $key_to_deplist, $key_to_label, $options, 
    $visited, $origin, $key_to_shaded_label,
    $repeated_direct_dep_sets,
  ];

  return dependency_graph_to_tree_recursive($from, $context);
}

#
# Convert a pair of equal length arrays into a tree,
# where a given entry in the first array contains a
# scalar text string for the node's label, and the
# corresponding entry (at the same index) in the
# second array specifies that node's absolute depth,
# where 0 is the root, and all depths in the array 
# except for the first (root) entry must be >= 1.
#
our $split_leading_spaces_from_text_re = 
  compile_regexp(qr{^ ([\ \t]*+) (\N*+) (?> \n | \Z)}oamsx, 
                 'split_leading_spaces_from_text');

noexport:; sub create_histogram_of_used_levels($$) {
  my ($levels, $n) = @_;

  my @levels_used = ( );

  for my $i (0..($n-1)) {
    my $level = $levels->[$i];
    $levels_used[$level] = (defined $levels_used[$level]) ? ($levels_used[$level] + 1) : 1;
  }
  return \@levels_used;
}

noexport:; sub create_level_skip_map($) {
  my ($levels_used) = @_;

  my $n = scalar @$levels_used;

  my @skip_map = ( );
  prealloc(\@skip_map, scalar(@$levels_used));

  my $valid_levels = 0;

  for my $i (0..($n-1)) {
    if ($levels_used->[$i]) { $skip_map[$i] = $valid_levels++; }
    die if (!$levels_used);
  }

  return \@skip_map;
}

sub split_text_into_arrays_of_lines_and_indents {
  my ($text) = @_;

  my $linenum = 0;

  my $lines = (is_array_ref($text)) ? $text : [ split(/\n/oamsx, $text) ];

  my $linecount = scalar @$lines;
  if (!$linecount) { return ([ ], [ ]); }

  my @indents = ( );
  prealloc(\@indents, $linecount);
  
  my @indent_levels_used = ( );
  
  for my $linenum (0..($linecount-1)) {
    my $line = $lines->[$linenum];
    next if (!defined $line);
    my $spaces;
    ($spaces, $line) = ($line =~ /$split_leading_spaces_from_text_re/oamsx);
    my $indent_level = length($spaces);

    $indent_levels_used[$indent_level] = 
      (defined $indent_levels_used[$indent_level]) ? 
        ($indent_levels_used[$indent_level] + 1) : 1;

    $lines->[$linenum] = $line;
    $indents[$linenum] = $indent_level;
  }

  #
  # Add two special reference entries to the end of the indents array:
  #
  # = the skip list, which maps potentially sparse input indent sizes
  #   onto a contiguous monotonically increasing set of indents
  #
  # - the histogram, which counts the number of occurrences of each
  #   input indent level.
  #
  $indents[$linecount+0] = \@indent_levels_used;
  $indents[$linecount+1] = create_level_skip_map(\@indent_levels_used);

  return ($lines, \@indents);
}

sub labels_and_levels_to_tree($;$) {
  my ($labels, $levels) = @_;

  my $n = scalar @$labels;

  if (!defined $levels) {
    ($labels, $levels) = split_text_into_arrays_of_lines_and_indents($labels);
  }

  my $used_levels = $levels->[$n+0];
  my $skip_map = $levels->[$n+1];

  if (!defined $used_levels) 
    { $used_levels = create_histogram_of_used_levels($levels, $n); }

  if (!defined $skip_map)
    { $skip_map = create_level_skip_map($used_levels); }

  my $rootnode = [ [ '(root) ' ] ];

  my @node_at_level = ( );

  for my $i (0..($n-1)) {
    my $label = $labels->[$i];
    my $level = $levels->[$i];
    next if (!defined $label);
    die if (!defined $level);
    $level = $skip_map->[$levels->[$i]];
    die if (!defined $level);

    my $node = [ $label ];
    my $parent = ($level > 0) ? $node_at_level[$level-1] : $rootnode;
    $node_at_level[$level] = $node;    
    push @$parent, $node;
  }

  return $rootnode;
}

sub indented_text_to_tree($) {
  my ($text) = @_;

  my ($line_list, $indent_list) = split_text_into_arrays_of_lines_and_indents($text);
  return labels_and_levels_to_tree($line_list, $indent_list);
}

sub delimited_paths_to_tree_of_hashes(+;$+) {
  my ($pathlist, $delimiter, $path_to_metadata) = @_;
  $delimiter //= '/';

  $delimiter = quotemeta($delimiter);
  my $splitter_re = qr{$delimiter}oa;

  my $root = { };

  foreach my $path (@$pathlist) {
    my @chunks = split(/$splitter_re/, $path);

    my $node = $root;

    foreach my $chunk (@chunks) {
      next if (!length $chunk);

      if (exists $node->{$chunk}) {
        $node = $node->{$chunk};
      } else {
        my $subnode = { };
        $node->{$chunk} = $subnode;
        $node = $subnode;
      }
    }

    my $metadata = $path_to_metadata->{$path};

    if (defined $metadata) { $node->{''} = $metadata; }
  }

  return $root;
}

my $tree_format_if_no_metadata_color = fg_color_rgb(180, 108, 255);

sub tree_of_hashes_to_printable_tree {
  my ($hash_root, $name, $metadata, $format_if_no_metadata, $parent) = @_;

  $format_if_no_metadata //= $tree_format_if_no_metadata_color;
  my $label = $metadata // $format_if_no_metadata.$name;

  my $tree_node = (is_array_ref $metadata) ? $metadata : 
    [ ((defined $metadata) ? $default_tree_symbol_arrow_filled_tri : $default_tree_symbol_arrow_open_tri), $label ];

  $tree_node = [ $tree_node ];

  while (my ($subnode_name, $subnode) = each %$hash_root) {
    next if (!length $subnode_name);
    my $metadata = $subnode->{''};
    push @$tree_node, tree_of_hashes_to_printable_tree($subnode, $subnode_name, $metadata, $format_if_no_metadata, $tree_node);
  }

  return $tree_node;
}

1;
