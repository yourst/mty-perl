#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Filesystem::EnhancedFileStats
#
# Enhanced file stat() facility which also identifies extended attributes,
# ACLs, mount points, subvolumes, open files and more
#
# Copyright 1997 - 2014 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Filesystem::EnhancedFileStats;

#
# NOTE: EnhancedFileStats is a separate module from FileStats
# (which has most of the relevant constant definitions) since
# this is arrangement was necessary to break a dependency
# loop with other modules (like MTY::Filesystem::BtrFS) which
# need the basic stat() facilities, yet the enhanced stat()
# facilities themselves depend on these other modules. 
#
# Therefore, you should use both FileStats and EnhancedFileStats
# when the enhanced stat() facility is desired.
#
use integer; use warnings; use Exporter::Lite;

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($enable_file_stats_cache $file_stats_cache_accesses
     $file_stats_cache_hits FILE_TIMESTAMP_ACCESSED
     FILE_TIMESTAMP_CHANGED_ATTRS FILE_TIMESTAMP_MODIFIED_DATA
     STATS_QUERY_ACCESSIBLE STATS_QUERY_ACLS STATS_QUERY_ALL STATS_QUERY_BASE
     STATS_QUERY_DEFAULT STATS_QUERY_EXTENTS STATS_QUERY_MOUNTS
     STATS_QUERY_OPENFD STATS_QUERY_SYMLINK STATS_QUERY_XATTRS
     STATS_QUERY_XATTR_VALUES XATTR_NAMESPACE_SECURITY XATTR_NAMESPACE_SYSTEM
     XATTR_NAMESPACE_USER file_stats_cache_fill fixup_nanosec_file_timestamps
     flush_file_stats_cache get_enhanced_file_stats get_file_atime
     get_file_ctime get_file_mtime get_file_stats get_file_timestamps
     get_mtime_of_fd get_mtime_of_path is_directory_from_stats
     is_path_directory mkdirs open_and_read_directory path_cache_fill
     path_exists path_exists_relative_to_dir_fd stat_files_in_directory);

use MTY::System::POSIX;
use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Common::Strings;
use MTY::Common::Cache;
use MTY::Filesystem::Files;
use MTY::Filesystem::FileStats;
use MTY::RegExp::FilesAndPaths;
use MTY::Filesystem::Mounts;
use MTY::Filesystem::ExtAttrs;
use MTY::Filesystem::ProcFS;
use MTY::Filesystem::OpenFiles;
use MTY::Filesystem::ExtentMap;
use MTY::Filesystem::BtrFS;

my %file_stats_cache;

our $enable_file_stats_cache = 1;
our $file_stats_cache_accesses = 0;
our $file_stats_cache_hits = 0;

my $file_stats_cache;

noexport:; sub file_stats_cache_fill(+$$$$) {
  my ($cache, $full_path, $fd_rel_path, $base_dir_fd, $follow_symlinks) = @_;

  my @statlist = sys_fstatat($base_dir_fd // AT_FDCWD, $fd_rel_path, 
    ($follow_symlinks ? 0 : AT_SYMLINK_NOFOLLOW));

  #
  # If file doesn't exist or we could not access its stats
  # for any reason, cache this negative result as undef:
  #
  return ((scalar @statlist) ? [ @statlist ] : undef);
}

my $path_cache;

noexport:; sub path_cache_fill(+$) {
  my ($cache, $path) = @_;

  #
  # Use the file stats cache as a fallback, but don't query the full stats
  # unless they already exist in the file stats cache, since that defeats
  # the purpose of the path cache's lightweight file existence check.
  #

  my ($stats, $already_in_stats_cache) = 
    ($enable_file_stats_cache) ? $file_stats_cache->probe($path) : (undef, 0);

  #
  # Add an entry to the path cache, since we already need to look up the 
  # full path to query the stats, so we might as well improve the path
  # cache hit rate too.
  #
  # Note that this may cause the path cache to return false negatives 
  # in cases where the final element of the specified path (i.e. the 
  # actual target file or directory) does in fact exist, but its stats
  # could not be queried, typically because of a permission denial.
  #
  # However, POSIX directory traversal semantics preclude this scenario,
  # since if a directory can be traversed (its 'x' permission is set),
  # any file or subdirectory within it can also have its stats queried,
  # regardless of the permissions on each individual file or subdirectory.
  # However, POSIX ACLs and/or the specialized semantics in SELinux, etc.
  # may alter this behavior to make this obscure case a reality). 
  # 
  # In any case, the ultimate effect of this false negative is almost always
  # irrelevant, since if a file is unreadable, it might as well not even
  # exist, e.g. in applications like searching for an include file or an
  # executable within the first path in a list of search paths to check
  # (e.g. PATH, -Ixxx, etc).
  #
  my $real_path;

  if ($already_in_stats_cache) {
    $real_path = (defined $stats) ? $stats->[STAT_PATH] : undef;
  } else {
    $real_path = ((sys_access($path, F_OK)) ? realpath($path) : undef);
  }

  return $real_path;
}

INIT {
  $file_stats_cache = MTY::Common::Cache->new(\&file_stats_cache_fill, 'file_stats_cache');
  $path_cache = MTY::Common::Cache->new(\&path_cache_fill, 'path_cache');
};

sub get_file_stats($;$$) {
  my ($path, $base_dir_fd, $follow_symlinks) = @_;
  $follow_symlinks //= 1;

  my $pathkey;
  my $cache_hit = 0;

  $pathkey = (defined $base_dir_fd) ?
      get_path_of_open_path_fd($base_dir_fd).'/'.$path : $path;

  my $stats = (($enable_file_stats_cache) 
                 ? $file_stats_cache->get($pathkey, $path, $base_dir_fd, $follow_symlinks)
                 : file_stats_cache_fill(undef, $pathkey, $path, $base_dir_fd, $follow_symlinks));

  return (wantarray ? ((defined $stats) ? @$stats : ( )) : $stats);
}

sub flush_file_stats_cache() {
  $file_stats_cache->flush();
  $path_cache->flush();
}

sub path_exists($;$) {
  my ($path, $freq_search_hint) = @_;
  $freq_search_hint //= 0;

  return (($enable_file_stats_cache) 
            ? $path_cache->get($path) 
            : path_cache_fill(undef, $path));
}

sub path_exists_relative_to_dir_fd($$;$) {
  my ($fd, $path, $freq_search_hint) = @_;
  $freq_search_hint //= 0;

  return (sys_faccessat($fd, $path, F_OK, 0)) ? 1 : 0;
}

my $directory_separator_re = qr{/}oamsx;

#
# Create any and all missing directories comprising the specified path:
#
sub mkdirs($;$) {
  my ($path, $perms) = @_;
  $perms //= 0755; # 0755 = rwxr-xr-x

  if (path_exists($path.'/')) { return $path; }

  my @components = split($directory_separator_re, $path);
  
  my $path_so_far = '/';

  foreach my $dir (@components) {
    $path_so_far .= $dir.'/';
    next if (path_exists($path_so_far));
    print("=> mkdir [$path_so_far]\n");
    mkdir($path_so_far, $perms) || return $path_so_far;
    $path_cache->put($path_so_far, $path_so_far);
  }

  return $path_so_far;
}

#
# get_file_timestamps([pathname|handle|fd|statarray|stathash]):
#
# Return an array of the form [mtime, ctime, atime] containing
# the specified file's three POSIX defined timestamps in seconds,
# as floating point values with nanosecond precision.
#
use constant {
  FILE_TIMESTAMP_MODIFIED_DATA => 0,
  FILE_TIMESTAMP_CHANGED_ATTRS => 1,
  FILE_TIMESTAMP_ACCESSED      => 2,
};

#my $nanosec = 1000000000.0;

sub fixup_nanosec_file_timestamps(+) {
  my $stats = $_[0];

  $stats->[STAT_MTIME_NS] = ($stats->[STAT_MTIME] * BILLION) + $stats->[STAT_MTIME_NS];
  $stats->[STAT_CTIME_NS] = ($stats->[STAT_CTIME] * BILLION) + $stats->[STAT_CTIME_NS];
  $stats->[STAT_ATIME_NS] = ($stats->[STAT_ATIME] * BILLION) + $stats->[STAT_ATIME_NS];

  return $stats;
}

sub get_mtime_of_fd($) {
  my @stats = sys_fstatat($_[0], '', AT_EMPTY_PATH);
  return (scalar @stats) ? (($stats[STAT_MTIME] * BILLION) + $stats[STAT_MTIME_NS]) : undef;
}

sub get_mtime_of_path($) {
  my @stats = sys_fstatat(AT_FDCWD, $_[0], 0);
  return (scalar @stats) ? (($stats[STAT_MTIME] * BILLION) + $stats[STAT_MTIME_NS]) : undef;
}

sub get_file_timestamps {
  my @stats = fixup_nanosec_file_timestamps(stat_path_or_fd(@_, AT_SYMLINK_NOFOLLOW));

  return [
    $stats[STAT_MTIME_NS], 
    $stats[STAT_CTIME_NS], 
    $stats[STAT_ATIME_NS]
  ];
}

sub get_file_mtime($) { return get_file_timestamps(@_)->[FILE_TIMESTAMP_MODIFIED_DATA]; }
sub get_file_ctime($) { return get_file_timestamps(@_)->[FILE_TIMESTAMP_CHANGED_ATTRS]; }
sub get_file_atime($) { return get_file_timestamps(@_)->[FILE_TIMESTAMP_ACCESSED]; }

my $remove_trailing_slash_re = qr{\/$}oamsx;

use constant {
  STATS_QUERY_BASE    => (1 << 0), # basic sys_stat() info
  STATS_QUERY_SYMLINK => (1 << 1), # symlink target
  STATS_QUERY_MOUNTS  => (1 << 2), # mount points
  STATS_QUERY_ACLS    => (1 << 3), # ext attrs
  STATS_QUERY_XATTRS  => (1 << 4), # ext attrs
  STATS_QUERY_XATTR_VALUES => (1 << 5), # ext attrs
  STATS_QUERY_OPENFD  => (1 << 6), # open files
  STATS_QUERY_EXTENTS => (1 << 7), # cloned copy-on-write extents (on btrfs et al)
  STATS_QUERY_ACCESSIBLE => (1 << 8),
};

use constant {
  #
  # Query the subset of all possible stats which we can obtain
  # quickly without requiring the caller to obtain additional
  # information for us (like the list of all open files, etc).
  # Mount points are still handled by default since /proc/mounts
  # only needs to be queried once (unless the caller is actively
  # mounting or unmounting filesystems of course).
  #
  STATS_QUERY_DEFAULT => 
    STATS_QUERY_BASE |
    STATS_QUERY_SYMLINK |
    STATS_QUERY_MOUNTS,

  STATS_QUERY_ALL     => 0x7fffffff, # all
};

# my $xyz = STATS_QUERY_ALL;
#print("openfd=".is_numeric($xyz & STATS_QUERY_OPENFD).NL);

use constant {
  XATTR_NAMESPACE_USER => { },
  XATTR_NAMESPACE_SYSTEM => {namespace => 'system'},
  XATTR_NAMESPACE_SECURITY => {namespace => 'security'},
};

sub get_enhanced_file_stats($;$+$$+$+) {
  my ($name, $follow_symlinks, $stats, $base_dir_fd, $base_dir_name, $base_dir_stats, $stats_subset, $open_files) = @_;

  $follow_symlinks //= 0;
  $stats_subset //= STATS_QUERY_DEFAULT;
  my $fullpath = $name;

  if (defined $base_dir_fd) { 
    $base_dir_name //= get_path_of_open_path_fd($base_dir_fd);
    if ((!defined $base_dir_name) || (!defined $base_dir_stats))
      { die('base_dir_name and base_dir_stats are required if base_dir_fd is defined'); }
    $base_dir_name = strip_trailing_slash(realpath($base_dir_name));
    $fullpath = $base_dir_name.'/'.$name;
  } else {
    $fullpath = realpath($name);
    #if (!defined $fullpath) { warn 'Could not translate '.$name.' to full path'; }
  }

  $stats //= get_file_stats($name, $base_dir_fd, $follow_symlinks);
  if (!defined $stats) { return undef; }

  if ((scalar @$stats) > STAT_NAME) { 
    # If the stats cache already contains the enhanced stats, just return them:
    return (wantarray ? @$stats : $stats); 
  }

  $name =~ s{$remove_trailing_slash_re}{}oamsx;
  
  $stats->[STAT_NAME] = $name;
  $stats->[STAT_PATH] = $fullpath;

  my $type = ($stats->[STAT_MODE] >> S_IFMT_SHIFT);
  $stats->[STAT_TYPE] = $type;
  $is_dir = ($type == FILE_TYPE_DIR); # but we don't know if the directory is a mount point or subvolume yet...
  $is_special = ($type == FILE_TYPE_PIPE) || ($type == FILE_TYPE_SOCKET) || ($type == FILE_TYPE_BLOCK_DEV) || ($type == FILE_TYPE_CHAR_DEV);

  fixup_nanosec_file_timestamps($stats);

  if (($type == FILE_TYPE_SYMLINK) && ($stats_subset & STATS_QUERY_SYMLINK))
    { $stats->[STAT_SYMLINK] = sys_readlinkat($base_dir_fd // AT_FDCWD, $name); }

  my $xattrs = { };
  my $access_acl = undef;
  my $default_acl = undef;
  my $capability_acl = undef;

  my $query_acls = ($stats_subset & STATS_QUERY_ACLS) ? 1 : 0;
  my $query_xattrs = ($stats_subset & STATS_QUERY_XATTRS) ? 1 : 0;
  my $query_xattr_values = ($stats_subset & STATS_QUERY_XATTR_VALUES) ? 1 : 0;

  # print(STDERR "$fullpath: query_acls = $query_acls, query_xattrs = $query_xattrs, query_xattr_values = $query_xattr_values\n");

  # querying ACLs implies querying at least xattr names, since ACLs are stored in xattrs:
  $query_xattrs |= $query_acls; 

  # querying xattr values implies querying the list of xattrs
  $query_xattrs |= $query_xattr_values;

  # querying xattr values lets us query ACLs with no extra overhead:
  $query_acls |= $query_xattr_values;

  if (($type != FILE_TYPE_SYMLINK) && $query_xattrs) {
    my @xattr_names = sys_listxattr($fullpath);
    
    if ($query_xattr_values) {
      foreach my $name (@xattr_names) 
        { $xattrs->{$name} = sys_getxattr($fullpath, $name); }
               
      if ($query_acls) {
        $access_acl = $xattrs->{'system.posix_acl_access'};
        $default_acl = $xattrs->{'system.posix_acl_default'};
        $capability_acl = $xattrs->{'security.capability'};
      }
    } else { # ! $query_xattr_values
      $xattrs = array_to_hash_keys([ @xattr_names ], undef);
    }

    if ($query_acls) {
      #
      # If we do not want xattrs but do want just the ACLs, 
      # use a faster method of only querying the access ACL
      # and default ACL plus any executable capabilities:
      #
      if (!$query_xattr_values) {
        # Only query the values of the xattrs that actually exist:
        foreach my $name (@xattr_names) {
          next if (ord($name) != ord('s')); # skip if not system.* or security.*
          my $ref = 
            ($name eq 'system.posix_acl_access') ? \$access_acl :
            ($name eq 'system.posix_acl_default') ? \$default_acl :
            ($name eq 'security.capability') ? \$capability_acl : undef;
          if (defined $ref) { 
            my $value = sys_getxattr($fullpath, $name); 
            $$ref = $value;
            $xattrs->{$name} = $value;
          }
        }
      }

      $stats->[STAT_ACL] = $access_acl;
      $stats->[STAT_DEFAULT_ACL] = $default_acl;
      $stats->[STAT_CAPABILITIES] = $capability_acl;
    }

    $stats->[STAT_XATTRS] = $xattrs;
  }

  if ($stats_subset & STATS_QUERY_EXTENTS) {
    my $extents = get_file_extents($fullpath, $stats);
    my $summary = summarize_extents($extents, $stats);
    $stats->[STAT_EXTENTS] = $summary;
  }

  if ($stats_subset & STATS_QUERY_OPENFD) {
    if (!defined $open_files) {
      die('get_enhanced_file_stats: STATS_QUERY_OPENFD requested, '.
         'but open_files argument was not provided (caller must pass '.
         'hash returned by find_all_open_files())');
    }

    my $open_as_fd_in_contexts = $open_files->{$fullpath};
    $stats->[STAT_OPENFD] = $open_as_fd_in_contexts;
  }

  if ($stats_subset & STATS_QUERY_ACCESSIBLE) {
    my $access_type = ($is_dir) ? X_OK : R_OK;
    $stats->[STAT_IS_ACCESSIBLE] = sys_faccessat($base_dir_fd // AT_FDCWD, $name, $access_type, AT_EACCESS) ? 1 : 0;
  }

  if (!$is_dir) { return $stats; } # files and other non-containers don't need any info collected below here

  #
  # It must be a simple directory if the device number of the parent
  # directory is the same as the specified directory's device number
  # (even subvolumes will change the minor device numbers):
  #
  # If the name ends with a slash, chop it off to prevent confusion:
  #

  #
  # It must be a mount point (or a subvolume) if we make it to here:
  #
  # (Note: the list of mounted filesystems is only obtained from 
  # /proc/self/mountinfo the first time this is called; subsequent
  # calls return the cached copy of this list unless it has changed:
  #

  if ($stats_subset & STATS_QUERY_MOUNTS) {
    $base_dir_stats //= [ (defined $base_dir_fd) ?
      sys_fstatat($base_dir_fd, undef, AT_EMPTY_PATH) :
      sys_fstatat(AT_FDCWD, directory_of($name), 0) ];
    
    if (($base_dir_stats->[STAT_DEV] == $stats->[STAT_DEV]) && ($name ne '/'))
      { $stats->[STAT_TYPE] = FILE_TYPE_DIR; return $stats; }
  
    my $all_mounts = query_mounted_filesystems() // { };
    $all_mounts //= { }; # in case /proc/mounts was unavailable or caller did not ask for mount info
  
    #
    # We really need to have the entire absolute path name at this point.
    # If we are doing this relative to $base_dir_fd, it is OK if we just
    # slap the filename onto the end of $base_dir_name as long as we found
    # the real path with all symlinks resolved of the base directory
    # in which the specified file resides:
    #
  
    my $mountpoint = undef;
    my $mountinfo = $all_mounts->{$fullpath};
    
    if (!defined $mountinfo) {
      # It must be a subvolume of a mounted filesystem closer to the root:
      $mountpoint = find_mount_point($fullpath);
      if (!defined $mountpoint) { die("Cannot find filesystem containing '$fullpath'"); }
      $mountinfo = $all_mounts->{$mountpoint};
      if (!defined $mountinfo) { die("No mount information found for mount point '$mountpoint'"); }    
    }

    # Get the filesystem type name:
    $stats->[STAT_FSTYPE] = $mountinfo->[MOUNTINFO_TYPE];
    # We can simply reuse the mount category as the extended file type,
    # since by this point it is guaranteed to be a mount point directory
    # with one of the types FILE_TYPE_{BLOCK_DEV, BIND, VOLATILE, SPECIAL,
    # NETWORK or FUSE}_MOUNT:

    $stats->[STAT_TYPE] = $mountinfo->[MOUNTINFO_CATEGORY];
    
    if (($stats->[STAT_FSTYPE] eq 'btrfs') && 
          is_btrfs_subvol_or_root($fullpath, $stats)) {
      $stats->[STAT_TYPE] = (is_subvol_writable($fullpath) 
                               ? FILE_TYPE_SUBVOLUME :
                                 FILE_TYPE_SNAPSHOT);
    }
  } else { # (!STATS_QUERY_MOUNTS)
    if ($name eq '/') { $stats->[STAT_TYPE] = FILE_TYPE_MOUNT_POINT; }
  }

  return (wantarray ? (@$stats) : $stats);
}

sub is_path_directory($) {
  my ($dev, $inode, $mode) = get_file_stats($_[0], undef, 1);
  return S_ISDIR($mode) ? 1 : 0;
}

sub is_directory_from_stats($) {
  my ($stats) = @_;
  return (S_ISDIR($stats->[STAT_MODE]) ? 1 : 0);
}

#
# Open a O_PATH file descriptor for the specified path (which is typically a
# directory, but may also be a single file or other filesystem object). 
#
# Query the stats of the path to determine if it's a directory; if so, read 
# the directory to produce an array of the filenames it contains. If the path
# is *not* a directory, this array will have only one element corresponding to
# the path itself (specifically the non-directory portion of the path).
#
# Return the opened file descriptor, the array of filenames, the stats of the
# directory itself, and a flag indicating if the path was a directory or a file.
#
sub open_and_read_directory($;$$) {
  my ($path, $follow_symlinks, $exclude_dot_and_dot_dot) = @_;
  $follow_symlinks //= 0;
  $exclude_dot_and_dot_dot //= 0;

  my $dirfd = sys_open_path($path, undef, 0);
  if (!defined $dirfd) { warn('Cannot open "'.$path.'" (errno '.$?.')'); return undef; }

  my $base_path_stats = [ sys_fstatat($dirfd, '', AT_EMPTY_PATH) ];
  my $path_is_dir = S_ISDIR($base_path_stats->[STAT_MODE]);
  my $flags = $exclude_dot_and_dot_dot ? READ_DIR_ExCLUDE_DOT_AND_DOT_DOT : 0;
  my $filenames = ($path_is_dir) ? read_directory($path, $flags) : [ $path ];
  return ($dirfd, $filenames, $base_path_stats, $path_is_dir);
}

sub stat_files_in_directory { # ($;+$$+$$+)
  my ($base_dir_path, $filenames, $follow_symlinks, 
      $base_dir_fd, $base_dir_stats, $filename_to_stats_hash, 
      $prepend_to_path_key, $get_enhanced_stats, $open_files) = @_;

  $follow_symlinks //= 0;
  $prepend_to_path_key //= '';
  $get_enhanced_stats //= STATS_QUERY_DEFAULT;

  my $close_base_dir_fd = (!defined $base_dir_fd);

  $base_dir_fd //= sys_open_path($base_dir_path, undef, 0);

  if (!defined $base_dir_fd) { 
    warn('Cannot open directory "'.$base_dir_path.'" (errno '.$?.')');
    return undef;
  }

  $base_dir_stats //= [ sys_fstatat($base_dir_fd, '', AT_EMPTY_PATH) ];
  die if (!scalar @$base_dir_stats);

  my $path_is_dir = S_ISDIR($base_dir_stats->[STAT_MODE]);

  $filenames //= ($path_is_dir) ? read_directory($base_dir_path, READ_DIR_ExCLUDE_DOT_AND_DOT_DOT) : [ $base_dir_path ];

  $filename_to_stats_hash //= { };
  prealloc($filename_to_stats_hash, $filenames);

  foreach my $filename (@$filenames) {
    my $stats = get_enhanced_file_stats($filename, $follow_symlinks, undef, 
                                        $base_dir_fd, $base_dir_path, $base_dir_stats, 
                                        $get_enhanced_stats, $open_files);

    $filename_to_stats_hash->{$prepend_to_path_key.$filename} = $stats;
  }

  sys_close($base_dir_fd) if ($close_base_dir_fd);

  return $filename_to_stats_hash;
}

1;


  #
  # Check for "small" directories (based on the heuristic assumption 
  # that stat() on a directory on most filesystems will report a size
  # field that is proportional to the number of files in the directory
  # and/or the sum of the lengths of the filenames (plus some other 
  # relatively compact fixed size metadata, like the file type and 
  # inode number, or an equivalent identifier).
  #
  # If the directory is "small", i.e. less than 256K "bytes" or whatever
  # unit the target filesystem uses to express directory sizes in the
  # stat() size field), it's often faster just to read it all in one
  # big read request.
  # 
  # However, for truly huge directories with hundreds of thousands or
  # even millions of files, it's often faster to read the directory
  # one entry at a time (subject to internal buffering by perl, libc
  # and/or the kernel and filesystem itself), then call stat() to
  # read that inode, and repeat this alternation until we've read
  # the entire directory and have every file's stats.
  #
  # (TODO: unfortunately perl seems to lack a means to read a larger
  # chunk of directory entries (i.e. more than one) in a single 
  # readdir() call, unless we want the entire directory all at once;
  # there is apparently no middle ground. Therefore this heuristic
  # is disabled for now...)
  # 

  # my $is_small_dir = ((-s $fd) < (256*1024));
