#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Filesystem::ProcFS
#
# Process related utility functions that use /proc on Linux
#
# Copyright 2003 - 2014 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Filesystem::OpenFiles;

use integer; use warnings; use Exporter::Lite;

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(@open_type_to_description @open_type_to_long_description
     @open_type_to_padded_description @open_type_to_single_letter_description
     OPEN_AS_CURRENT_DIR OPEN_AS_EXECUTABLE OPEN_AS_ROOT_DIR OPEN_FOR_MMAP
     OPEN_ON_FD classify_fd_target find_all_open_files
     find_all_open_files_fast_skip_details find_files_opened_by_pid
     find_files_opened_by_pid_fast_skip_details first_pid_with_fd_open_on
     get_invoked_command_name get_local_socket_path
     get_pid_of_first_consumer_of_fd get_pid_of_first_consumer_of_stderr
     get_pid_of_first_consumer_of_stdout get_real_command_name_of_pid
     get_script_path get_unix_local_socket_info
     pid_and_fd_to_target_filename_or_anon_inode);

use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Filesystem::Files;
use MTY::Filesystem::FileStats;
use MTY::Common::Strings;
use MTY::RegExp::Define;
use MTY::System::POSIX;
use MTY::Filesystem::ProcFS;

#
# File Descriptor related functions which use /proc/<pid>/fd/*:
#

sub pid_and_fd_to_target_filename_or_anon_inode($$) {
  return read_proc_link($_[0], 'fd/'.$_[1]); 
}

my $classify_fd_target_re = qr{^ (\w++) : \[? (\w++) \]? $}oax;
my $deleted_file_tag_re = qr{\s \(deleted\) $}oax;

my %special_fd_type_name_to_file_type = (
  socket => FILE_TYPE_SOCKET,
  pipe => FILE_TYPE_PIPE,
  anon_inode => FILE_TYPE_SPECIAL,
);

my $socket_anon_inode_to_info = undef;

sub get_unix_local_socket_info($) {
  my ($inode) = @_;

  if (!defined $socket_anon_inode_to_info) {
    my $lines = read_proc_matrix(undef, 'net/unix') // [ ];

    foreach my $info (@$lines) {
      my ($kernel_addr, $refcount, $protocol, $flags, $type, $state, $inode, $path) = @$info;
      $socket_anon_inode_to_info{$inode} = $info;
    }
  }

  return $socket_anon_inode_to_info{$inode};
}
                               
sub get_local_socket_path($) {
  my ($inode) = @_;
  my $info = get_unix_local_socket_info($inode);
  return undef if (!defined $info);
  my ($kernel_addr, $refcount, $protocol, $flags, $type, $state, $same_as_inode, $path) = @$info;
  return $path;
}

sub classify_fd_target($) {
  my ($proc_symlink_target) = @_;
  if (!defined $proc_symlink_target) { return undef; }

  my $deleted = ($proc_symlink_target =~ s{$deleted_file_tag_re}{}oamsx) ? 1 : 0;
  my $special_type = undef;
  my $path_or_inode = $proc_symlink_target;

  if ($proc_symlink_target =~ /$classify_fd_target_re/oax) { ($special_type, $path_or_inode) = ($1, $2); }

  my $type = (is_there($special_type)) ? $special_fd_type_name_to_file_type{$special_type} :
    (is_there($path_or_inode)) ? (get_file_type($path_or_inode) // FILE_TYPE_SPECIAL) : 
      FILE_TYPE_SPECIAL; 

  if (($type == FILE_TYPE_SOCKET) && is_there($path_or_inode))
    { $path_or_inode = get_local_socket_path($path_or_inode) // $path_or_inode; }
  
  return ($type, $path_or_inode, $deleted);
}

sub first_pid_with_fd_open_on($$;+) {
  my ($target_filename_or_anon_inode, $fd_to_check, $pidlist) = @_;

  if (!defined($pidlist)) { $pidlist = get_pids(); }

  foreach my $pid (@$pidlist) {
    my $target_of_fd_in_pid = read_proc_link($pid, 'fd/'.$fd_to_check);
    next if (!defined($target_of_fd_in_pid));
    return $pid if ($target_of_fd_in_pid eq $target_filename_or_anon_inode);
  }

  return undef;
}

#
# Find the process ID (PID) of the first process started after our own process
# to which our process has piped its stdout. We find this by starting with
# the anonymous inode pointed to by /proc/self/fd/1 (which will be a symlink
# to e.g. 'pipe:[xxx]'), then we find the next consecutive PID P for which
# /proc/P/fd/0 (i.e. stdin) is opened toread from the same pipe as our stdout
# (i.e. its /proc/P/fd/0 symlink also points back to the same 'pipe:[xxx]').
#
# Because shells usually obtain consecutive (or at least very closely
# spaced ascending) PIDs for each process in a pipeline constructed
# with e.g. '... | this_process | P | ...', this algorithm's average
# runtime is O(1), since our target is generally the process with the
# next highest PID after our own PID. If a PID numbering wraparound
# is detected, we may need to check O(N) processes (N ~= 100 - 200
# on most workstations), but that is very rare and only occurs once
# every 64K to 1M+ forks.
#
sub get_pid_of_first_consumer_of_fd($) {
  my ($fd) = @_;
  my $my_pid = getpid();
  my $stdout_fd_target = pid_and_fd_to_target_filename_or_anon_inode($my_pid, $fd);
  my $pidlist = get_pids($my_pid + 1);
  my $consumer_pid = first_pid_with_fd_open_on($stdout_fd_target, 0, $pidlist);
  return $consumer_pid;
}

sub get_pid_of_first_consumer_of_stdout {
  return get_pid_of_first_consumer_of_fd(1);
}

sub get_pid_of_first_consumer_of_stderr {
  return get_pid_of_first_consumer_of_fd(2);
}

my $interpreter_cmd_names_re = 
  qr{^(?: (\w* (?: sh | awk | make)) | 
       (?: p (?: erl | ython) | ruby | sed | java))}oamsx;

sub get_real_command_name_of_pid(;$) {
  my $pid = $_[0] // getpid();

  my @cmdline = read_proc_null_sep_array($pid, 'cmdline');

  if (!@cmdline) { 
    my $exe = read_proc($pid, 'exe') // 'unknown';
    @cmdline = ($exe);
  }

  my $cmd = basename(shift @cmdline);

  # interpreters are often prefixed with 'env' to set up their environment:
  if ($cmd eq 'env') { $cmd = basename(shift @cmdline); }

  # we want to know the actual script being interpreted:
  if (($cmd =~ /$interpreter_cmd_names_re/oamsx) && (scalar @cmdline)) {
    do { $cmd = shift @cmdline; } until (($cmd // '') !~ /^-/oa);
    # by this point we should *finally* know the real name of the script:
    $cmd = basename($cmd // 'unknown');
  }

  return $cmd;
}

#
# Get the command name used to invoke process <pid>.
# If the process was an interpreted script, this is 
# the name (with neither leading directories nor 
# resolution of any symlinks) of the script itself.
#
my $proc_stat_invoked_command_re = 
  qr{^ \d++ \s++ \( ([^\)]++) \)}oax;

sub get_invoked_command_name(;$) {
  my $pid = $_[0] // 'self';
  my $stat = read_proc($pid, 'stat');
  my ($cmdname) = ($stat =~ /$proc_stat_invoked_command_re/oax);
  return $cmdname;
}

sub get_script_path(;$) {
  my $pid = $_[0] // 'self';
  my @cmdline = read_proc_null_sep_array($pid, 'cmdline');
  my $interp = shift @cmdline;
  my $script = undef;
  foreach $arg (@cmdline) {
    # skip any options
    next if ($arg =~ /^-/oax); 
    # return the first non-option argument
    $script = $arg; last;
  }

  return ((wantarray) ? ($script, $interp) : $script);
}

my $special_proc_maps_filename_re = qr{^\[ [^\]]+ \]$}oax;
my $deleted_proc_filename_re = qr{\s\(deleted\)$}oax;

use constant {
  OPEN_ON_FD               => 0,
  OPEN_AS_ROOT_DIR         => 1,
  OPEN_AS_CURRENT_DIR      => 2,
  OPEN_AS_EXECUTABLE       => 3,
  OPEN_FOR_MMAP            => 4,
};

our @open_type_to_description = 
  ('fd', 'root', 'cwd', 'exec', 'mmap');

our @open_type_to_padded_description = 
  ('fd  ', 'root', 'cwd ', 'exec', 'mmap');

our @open_type_to_long_description = 
  ('file descriptor', 'root directory', 'current directory', 'executable', 'memory mapped');

our @open_type_to_single_letter_description =
  ('f', 'r', 'c', 'x', 'm');

#
# Find all files opened by the specified process ID (whether directly
# via a file descriptor, implicitly as the root directory, current
# directory or executable file, or memory mapped):
#
# Returns a hash which maps open path names to nested array references of the form:
# 
#   $path => [ 
#     [ OPEN_AS_xxx, <pid>, <is_deleted>, <info_specific_to_that_type> ], 
#     ...
#   ]
#
# If a given path is open in multiple contexts (e.g. through both a file descriptor
# and memory mapping), the outer array will contain multiple entries, one for
# each context in which the same path is open.
#
# Information specific to each context in which a given file may be open by a process:
#
#  [ OPEN_ON_FD, <pid>, <is_deleted?>, <fd>, <type from file's stat record>, <actual path or inode> ]);
#  [ OPEN_AS_ROOT_DIR, <pid>, 0 ]
#  [ OPEN_AS_CURRENT_DIR, <pid>, 0 ]
#  [ OPEN_AS_EXECUTABLE, <pid>, 0 ]
#  [ OPEN_FOR_MMAP, <pid>, <is_deleted?>, <corresponding line from /proc/pid/maps> ]
# 
#
# Special anonymous objects like pipes, sockets, events, inotifies, etc. are represented
# by keys in the form provided by the Linux kernel itself:
#
#   <object type>:[<inode or other unique identifier>]
#
# The second $path_to_info argument can be used to specify an existing hash reference
# into which the records should be added. The caller can use the same hash to collect
# information on every process in the system, since each record includes the process
# ID to prevent conflicts and ambiguity. (However, each distinct path name will only
# have a single hash key even if it contains multiple records).
#
sub find_files_opened_by_pid($;+) {
  my ($pid, $path_to_info) = @_;

  $path_to_info //= { };

  #
  # Check the executable filename first - if it's empty
  # or can't be read at all, this is a kernel thread 
  # which doesn't have any open file descriptors or
  # memory mappings (at least not of userspace files),
  # so we can quickly skip right over it.
  # (Since it is not unusual for multi-processor Linux 
  # machines to have more kernel threads than userspace
  # threads, so this optimization can make this function 
  # much faster by skipping over kernel threads entirely.
  #
  my $exe = read_proc_link($pid, 'exe');
  if (!is_there($exe)) { return $path_to_info; }

  return undef if (!open_proc($pid));

  my $pid_subdir_fd = open_proc($pid, 'fd');
  return undef if (!defined $pid_subdir_fd);

  my $rootdir = read_proc_link($pid, 'root');
  my $cwd = read_proc_link($pid, 'cwd');
  my $maps = read_proc_matrix($pid, 'maps');

  append_to_hash_of_arrays($path_to_info, $rootdir, 
    [ OPEN_AS_ROOT_DIR, $pid, 0 ]);
  append_to_hash_of_arrays($path_to_info, $cwd, 
    [ OPEN_AS_CURRENT_DIR, $pid, 0 ]);
  append_to_hash_of_arrays($path_to_info, $exe, 
    [ OPEN_AS_EXECUTABLE, $pid, 0 ]);

  foreach $map (@$maps) {
    my $filename = $map->[5];
    next if (!defined $filename); # (must be an anonymous mapping)
    # skip pseudo-file entries like [heap], [stack], [vdso], [vsyscall]:
    next if ($filename =~ /$special_proc_maps_filename_re/oax);
    my $is_deleted = ($filename =~ /$deleted_proc_filename_re/oax);

    append_to_hash_of_arrays($path_to_info, $filename, 
                             [ OPEN_FOR_MMAP, $pid, $is_deleted, $map ]);
  }

  my @fdlist = read_proc_subdir($pid, 'fd');

  foreach $fd (@fdlist) {
    next if (($fd eq '.') || ($fd eq '..'));
    my $target = sys_readlinkat($pid_subdir_fd, $fd);

    if (!defined $target) {
      warn("Cannot read link target for fd $fd of pid $pid (error was: $!)");
      next;
    }

    my ($type, $path_or_inode, $is_deleted) = classify_fd_target($target);

    append_to_hash_of_arrays($path_to_info, $target, 
      [ OPEN_ON_FD, $pid, $is_deleted, $fd, $type, $path_or_inode ]);
  }

  close_proc($pid, 'fd');
  close_proc($pid);

  return $path_to_info;
}

#
# Faster streamlined version of find_files_opened_by_pid() which doesn't
# capture any details other than the path names (if this is all the caller
# cares about - find_files_opened_by_pid() can always be used to provide
# details on only the interesting processes if desired).
#
# This function returns a hash keyed by each absolute fully qualified 
# file path, and the corresponding value is the total number of processes 
# and/or distinct contexts in which each file is currently open.
#
sub find_files_opened_by_pid_fast_skip_details($;+) {
  my ($pid, $pathnames) = @_;

  $pathnames //= { };

  #
  # (see notes for find_files_opened_by_pid() for why we
  # check the executable filename first to skip over any
  # kernel threads as a performance optimization):
  #
  my $exe = read_proc_link($pid, 'exe');
  if (!is_there($exe)) { return $pathnames; }

  return undef if (!open_proc($pid));

  my $pid_subdir_fd = open_proc($pid, 'fd');
  return undef if (!defined $pid_subdir_fd);

  my $rootdir = read_proc_link($pid, 'root');
  my $cwd = read_proc_link($pid, 'cwd');
  my $maps = read_proc_matrix_column($pid, 'maps', 6);

  $pathnames->{$rootdir}++;
  $pathnames->{$cwd}++;
  $pathnames->{$exe}++;

  foreach $mapped_filename (@$maps) { $pathnames->{$mapped_filename}++; }

  my @fdlist = read_proc_subdir($pid, 'fd');

  foreach $desc (@fdlist) {
    next if (($desc eq '.') || ($desc eq '..'));
    my $target = sys_readlinkat($pid_subdir_fd, $desc)
      || warn("Cannot read link target for fd $desc of pid $pid (error was: $!)");
      
    $pathnames->{$target}++;
  }

  close_proc($pid, 'fd');

  close_proc($pid);

  return $pathnames;
}

sub find_all_open_files(;+$) {
  my $pidlist = $_[0] // get_pids();
  my $skip_details = ($_[1] // 0);

  my $mypid = getpid();
  my $open_files = { };

  foreach my $pid (@$pidlist) { 
    # don't try to read the caller's own proc fd info, since
    # it will be changing as we open files in /proc/self:
    next if ($pid == $mypid);
    if ($skip_details) {
      find_files_opened_by_pid_fast_skip_details($pid, $open_files);
    } else {
      find_files_opened_by_pid($pid, $open_files);
    }
  }
  return $open_files;
}

sub find_all_open_files_fast_skip_details(;+) {
  return find_all_open_files($_[0], 1);
}

1;
