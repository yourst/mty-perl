#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Filesystem::Files
#
# Common functions on files and directories
#
# Copyright 1997 - 2014 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Filesystem::Files;

use integer; use warnings; use Exporter::Lite;

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($max_read_chunk_size $trailing_slash_re READ_DIR_ExCLUDE_DOT_AND_DOT_DOT
     STDERR_FD STDIN_FD STDOUT_FD basename_of directory_of filename_of
     final_suffix_of get_proc_self_fd_fd is_file_handle is_same_file
     normalize_trailing_slash open_file_or_dir path_of_open_fd read_directory
     read_file read_file_handle resolve_and_open_path resolve_path
     split_dir_and_filename split_filename_into_basename_and_suffixes
     split_path split_path_into_dirs_basename_and_suffixes
     split_path_version_aware strip_trailing_slash suffix_of write_file
     write_file_handle);

use Scalar::Util qw(openhandle);

use IO::File ();
use IO::Dir ();

use MTY::System::POSIX;
use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Common::Common qw(INT_MAX);
use MTY::Filesystem::ProcFS;

use MTY::Common::Strings;
use MTY::RegExp::FilesAndPaths;

use constant {
  STDIN_FD => 0,
  STDOUT_FD => 1,
  STDERR_FD => 2,
};

BEGIN {
  *cwd = *POSIX::getcwd;
  *getcwd = *POSIX::getcwd;
};

#
# Split specified path into list of (directory, basename, suffixes),
# with empty strings in place of any missing components:
#
sub split_path($;$) {
  my ($path, $re) = @_;
  $re //= $filesystem_path_re;

  my ($dirname, $basename, $suffixes) = ($_[0] =~ /$re/oax);
  if (!is_there($dirname)) { $dirname = '.'; };
  $basename //= '';
  $suffixes //= '';
  if ((!is_there($basename)) && (is_there($suffixes))) {
    # dot files (e.g. ".filename") with nothing before the dot
    # should appear as the basename, not the suffix with no basename:
    $basename = $suffixes;
    $suffixes = '';
  }

  return ($dirname, $basename, $suffixes);
}

sub split_path_version_aware($) {
  return split_path($_[0], $filesystem_dir_basename_suffixes_version_aware_re);
}

sub split_dir_and_filename($) {
  if ($_[0] =~ /$directory_and_filename_re/oax) {
    return ((is_there($1) ? $1 : './'), $2);
  } else {
    return ( );
  }
}

sub split_filename_into_basename_and_suffixes($) {
  my @result = ($_[0] =~ /$basename_and_suffixes_re/oax);
  $result[0] //= '';
  $result[1] //= '';
  return @result;
}

sub directory_of($) {
  my ($result) = ($_[0] =~ /$directory_in_path_re/oax);
  if (!is_there($result)) { $result = '.'; };
  return $result;
}

sub filename_of($) {
  my ($result) = ($_[0] =~ /($filename_in_path_re)/oax);
  return $result;
}

sub basename_of($) {
  my ($result) = ($_[0] =~ /$filename_without_suffixes_in_path_re/oax);
  return $result;
}

sub suffix_of($) {
  my ($result) = ($_[0] =~ /$suffixes_in_path_re/oax);
  return $result;
}

sub final_suffix_of($) {
  my ($result) = ($_[0] =~ /$final_suffix_in_path_re/oax);
  return $result;
}

sub split_path_into_dirs_basename_and_suffixes($) {
  my ($path) = @_;
  # local (*path) = \ (@_);

  if (my @dirs_basename_and_suffixes = ($path =~ /$filesystem_path_re/oamsx)) {
    return @dirs_basename_and_suffixes;
  } else { 
    return undef; 
  }
}

our $trailing_slash_re = qr{/++$}oax;

sub normalize_trailing_slash($;$) {
  my ($dirlist, $suffix) = @_;
  # local (*dirlist, *suffix) = \ (@_);

  $suffix //= '/';

  if (is_array_ref($dirlist)) {
    my @out = map { ($_ =~ s{$trailing_slash_re}{}roax).$suffix; } @$dirlist;
    return (wantarray ? @out : \@out);
  } else {
    return ($dirlist =~ s{$trailing_slash_re}{}roax).$suffix;
  }
}

sub strip_trailing_slash {
  return normalize_trailing_slash($_[0], '');
}

sub is_file_handle {
  return openhandle($_[0]);
}

sub is_same_file {
  my ($file1, $file2) = @_;
  # local (*file1, *file2) = \ (@_);

  my ($dev1, $inode1) = sys_stat($file1);
  my ($dev2, $inode2) = sys_stat($file2);
  return (($dev1 == $dev2) && ($inode1 == $inode2));
}

#
# Read the entire file into $text (or @text, if used in list context
# to return an array of lines):
#
# (This is usually faster than the following code, despite looking
# like it's a lot longer and more convoluted, since it bypasses
# buffering and directly uses the read syscall to grab everything).
#
# read_file_handle {
#  my ($F) = @_;
#  local (*F) = \ (@_);
#  local $/; # turn off all line separators in this function
#  return <$F>;
# }
#

our $max_read_chunk_size = 1048576;

sub read_file_handle($;+) {
  my ($fd, $bufref) = @_;

  if (openhandle($_[0])) { $fd = fileno($_[0]); }

  my $buf = '';
  $bufref = \$buf if (!defined($bufref)) || (!ref($bufref));

  my $chunksize = max(((-s $fd) // 0), $max_read_chunk_size);

  while (1) {
    my $n = sys_read($fd, substr($$bufref, length($$bufref)), $chunksize);

    if (!defined($n)) { die("read_file_handle(): WARNING: n not defined: errno = ".$!.", ^E = ".$^E.NL); }
    return undef if (!defined($n));
    last if ($n <= 0);
  }

  return ((wantarray) ? split(/\n/oax, $$bufref) : $$bufref);
}

sub read_file($;+) {
  my ($filename, $bufref) = @_;

  my $fd = sys_open($filename, O_RDONLY);
  if (!defined $fd) { return undef; }

  my $ret = read_file_handle($fd, $bufref);
  sys_close($fd);
  return $ret;
}

# sub read_file_in_dir($) { ... }

sub write_file_handle($$) {
  my ($fd, $dataref) = @_;

  if (openhandle($fd)) { $fd = fileno($fd); }

  my $len = length($dataref);
  my $remaining = $len;
  my $offset = 0;
  do {
    my $n = sys_write($fd, substr($dataref, $offset), $remaining);
    if (!defined($n)) 
      { print(STDERR "Cannot write to fd: $!\n"); return undef; }

    $remaining -= $n;
    $offset += $n;
  } while ($remaining > 0);

  return $len;
}

sub write_file($$) {
  my ($filename, $buf) = @_;
  # if (openhandle($_[0])) { return write_file_handle($_[0], $_[1]); }

  my $fd = sys_open($filename, O_WRONLY|O_CREAT|O_TRUNC);
  if (!defined $fd) { return undef; }
  my $len = write_file_handle($fd, $buf);
  sys_close($fd);
  return $len;
}

sub open_file_or_dir($) {
  my ($path) = @_;
  # local (*path) = \ (@_);


  $path = realpath($path);

  if (!(-e $path)) { return undef; }

  my $fd = 
    (-d $path) ? IO::Dir->new($path) :
    (-f $path) ? IO::File->new($path, O_RDONLY) :
    undef;
  
  return $fd;
}

#
# $abspath = resolve_path($relative_path, $extra_open_path_flags)
# ($fd, $abspath) = resolve_and_open_path($relative_path, $extra_open_path_flags)
#
# This is roughly 2x to 3x faster than the libc and/or perl native
# implementation of realpath, which starts at the root and traverses
# each directory comprising the path, following any symlinks until
# they reach a real file or directory. Each step for each directory
# requires several system calls which must be done strictly in order.
#
# In contrast, this function simply asks the kernel for the final 
# absolute path, since the kernel obviously already knows this and 
# can return it much faster than any userspace function can redo
# this work without the benefit of direct access to the kernel's
# directory and inode caches.
#
# Specifically, this function opens a file descriptor for the
# specified path itself using the O_PATH flag (which skips the
# slower process of actually preparing to access the file's data).
# It then simply reads the symlink target of /proc/self/fd/<path-fd>,
# through which the kernel conveniently provides the real path of
# any file descriptor. This requires only three system calls for
# the entire path (rather than for every directory in it):
#
# 1. <fd> = open(<target>, O_PATH)
# 2. <real_path_of_target> = readlinkat("/proc/self/fd/", "<fd>")
# 3. close(<fd>)
#
# As a companion function to resolve_path(), the sys_open_realpath()
# function returns a pair of the form:
#
#   (O_PATH file descriptor for path, 
#    full path of first argument),
#
# which is often a convenient compound operation, since the O_PATH
# file descriptor needs to be opened anyway.
#
# IMPORTANT NOTE:
#
# The sys_realpath() function may return incorrect results from its
# cache in certain cases where symlinks are redirected, directories
# are swapped or filesystems are remounted under existing names.
# Eventually this should support something like inotify to ensure
# the cache is flushed if and when these rare events happen...
#

my $proc_self_fd_fd = undef;

sub get_proc_self_fd_fd() {
  if (!defined $proc_self_fd_fd) { 
    $proc_self_fd_fd = MTY::Filesystem::ProcFS::open_proc('self', 'fd');
    die if ($proc_self_fd_fd < 0);
  }
  return $proc_self_fd_fd;
}

sub path_of_open_fd($) {
  my ($fd) = @_;
  return sys_readlinkat(get_proc_self_fd_fd(), "$fd");
}

sub resolve_and_open_path($;$$) { 
  my ($relative_path, $basefd, $extra_open_path_flags) = @_;

  my $fd = sys_open_path($relative_path, undef, $extra_open_path_flags);
  #
  # If we can't even open a path handle to it, it doesn't exist, so tell the
  # cache to record a negative result for this query so we won't repeat it:
  #
  if ($fd < 0) { return (undef, undef); }

  my $abspath = path_of_open_fd($fd);
  return ($fd, $abspath);
}

#
# This is essentially identical to resolve_and_open_path() except it closes
# the (temporarily) opened O_PATH file descriptor and only returns its path:
#
sub resolve_path($;$$) {
  my ($fd, $p) = resolve_and_open_path(@_);
  sys_close($fd) if (defined $fd);
  return $p;
}

use constant {
  READ_DIR_ExCLUDE_DOT_AND_DOT_DOT => (1 << 0),
};

sub read_directory($;$) {
  my ($path, $flags) = @_;
  $flags //= 0;

  my $dirfd = sys_opendir($path);

  if (!defined $dirfd) { 
    warn('read_directory(): Cannot open directory "'.$path.'"'); 
    return undef; 
  }

  my $filelist = [ sys_readdir($dirfd) ];

  # print(STDERR 'read_directory('.$path.', '.$flags.'): #filelist for "'.$path.'" is '.scalar(@$filelist).NL);
  
  if ($flags && READ_DIR_EXCLUDE_DOT_AND_DOT_DOT) {
    my $newlist = [ ];
    foreach my $filename (@$filelist) 
      { push @$newlist, $filename if ($filename !~ /^ \.+ $/oax); }
    $filelist = $newlist;
  }
  
  # print(STDERR 'read_directory('.$path.', '.$flags.'): filelist = {'.NL.'  '.join(NL.'  ', @$filelist).NL.'}'.NL);
  
  sys_closedir($dirfd);
  return (wantarray ? @$filelist : $filelist);
}

1;
