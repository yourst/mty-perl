#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Filesystem::BtrFS
#
# Copyright 2003 - 2014 Matt T. Yourst <yourst@yourst.com>
#
# BtrFS filesystem queries and subvolume and snapshot management
#

package MTY::Filesystem::BtrFS;

use integer; use warnings; use Exporter::Lite;

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(%fs_root_to_fs_uuid %fsobj_type_to_name
     BTRFS_SPECIAL_INODE_SUBVOLUME_ROOT FSOBJ_TYPE_BTRFS_ROOT FSOBJ_TYPE_DIR
     FSOBJ_TYPE_FILE FSOBJ_TYPE_MOUNT_POINT FSOBJ_TYPE_OTHER
     FSOBJ_TYPE_READONLY_SUBVOL FSOBJ_TYPE_SNAPSHOT FSOBJ_TYPE_SUBVOL
     FSOBJ_TYPE_SYMLINK FSOBJ_TYPE_UNKNOWN FSOBJ_TYPE_WRITABLE_SNAPSHOT
     check_for_btrfs_errors create_btrfs_snapshot create_btrfs_subvol
     format_subvol_attrs format_subvol_attrs_as_env_vars get_btrfs_property
     get_root_subvol_attrs is_btrfs_snapshot is_btrfs_subvol_or_root
     is_subvol_writable parse_btrfs_subvol_attrs query_btrfs_subvol
     query_btrfs_subvols remove_btrfs_subvol remove_btrfs_subvols
     run_btrfs_command set_btrfs_property update_subvol_xattrs);

use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Common::Strings;
use MTY::Filesystem::Files;
use MTY::Filesystem::FileStats;
use MTY::System::POSIX;
use MTY::Filesystem::ProcFS;
use MTY::Filesystem::Mounts;
use MTY::Filesystem::ExtAttrs;
use MTY::System::Misc;
use MTY::Display::Colorize;
use MTY::Display::ColorizeErrorsAndWarnings;
use MTY::Display::TextInABox;
use MTY::Display::PrintableSymbols;
use MTY::RegExp::Define;
use MTY::RegExp::Tools;
use MTY::RegExp::Blocks;
use MTY::RegExp::Numeric;
use MTY::RegExp::Strings;
use MTY::RegExp::FilesAndPaths;
use MTY::System::POSIX;

#
# BtrFS explicitly defines inode 256 as the root inode of
# any subvolume or the filesystem root itself; the stat
# device id field will vary to make the (inode, devid)
# combination unique.
#
# The btrfs utility determines if a given directory is a
# subvolume mount point by simply checking if its inode
# equals 256 (and it is on a btrfs filesystem of course).
#
use constant {
  BTRFS_SPECIAL_INODE_SUBVOLUME_ROOT => 256,
};

sub is_btrfs_subvol_or_root($;$) {
  my ($path, $stats) = @_;

  $stats //= [ stat($path) ];

  if (!scalar @$stats) { return 0; }

  my $mountpoint = find_mount_point($path);
  if (!defined $mountpoint) { return 0; }

  my $mountinfo = query_mount_point($mountpoint);
  if (!defined $mountinfo) { return 0; }

  my $fstype = $mountinfo->[MOUNTINFO_TYPE] // 'unknown';

  return
    (($fstype eq 'btrfs') &&
    (($stats->[STAT_MODE] >> S_IFMT_SHIFT) == FILE_TYPE_DIR) &&
    ($stats->[STAT_INODE] == BTRFS_SPECIAL_INODE_SUBVOLUME_ROOT)) ? 1 : 0;
}

sub is_subvol_writable($) {
  my $dir = $_[0];
  return ((-d $dir) && POSIX::access($dir, &POSIX::W_OK)) ? 1 : 0;
}

my $btrfs_subvol_list_re = compile_regexp(
  qr{^ID \s++ (\d++) \s++ 
      gen \s++ (\d++) \s++ 
      cgen \s++ (\d++) \s++
      parent \s++ (\d++) \s++
      top \s level \s++ (\d++) \s++ 
      parent_uuid \s++ (?> - | ($uuid_re)) \s++
      uuid \s++ ($uuid_re) \s++
      path \s++ (?> \<FS_TREE\>\/)?+ (\N++)
     }oamsx, 'btrfs_subvol_list');

use constant {
  FSOBJ_TYPE_UNKNOWN => 0,
  FSOBJ_TYPE_MOUNT_POINT => 1,
  FSOBJ_TYPE_BTRFS_ROOT => 2,
  FSOBJ_TYPE_SUBVOL => 3,
  FSOBJ_TYPE_READONLY_SUBVOL => 4,
  FSOBJ_TYPE_SNAPSHOT => 5,
  FSOBJ_TYPE_WRITABLE_SNAPSHOT => 6,
  FSOBJ_TYPE_DIR => 7,
  FSOBJ_TYPE_FILE => 8,
  FSOBJ_TYPE_SYMLINK => 9,
  FSOBJ_TYPE_OTHER => 10
};

our %fsobj_type_to_name = (
  FSOBJ_TYPE_UNKNOWN, 'unknown',
  FSOBJ_TYPE_MOUNT_POINT, 'non-btrfs-mount-point',
  FSOBJ_TYPE_BTRFS_ROOT, 'btrfs-root',
  FSOBJ_TYPE_SUBVOL, 'subvolume',
  FSOBJ_TYPE_READONLY_SUBVOL, 'read-only-subvolume',
  FSOBJ_TYPE_WRITABLE_SNAPSHOT, 'writable-snapshot',
  FSOBJ_TYPE_SNAPSHOT, 'snapshot',
  FSOBJ_TYPE_DIR, 'directory',
  FSOBJ_TYPE_FILE, 'file',
  FSOBJ_TYPE_SYMLINK, 'symlink',
  FSOBJ_TYPE_OTHER, 'other'
);

my $btrfs_cmd = '/sbin/btrfs';

my $last_btrfs_cmdline = '';
my $last_btrfs_output = '';
my $last_btrfs_rc = 0;

sub run_btrfs_command(@) {
  my $cmdline = $btrfs_cmd.' '.join(' ', map { '\''.$_.'\'' } @_);
  if (($_[0] eq 'device') && ($_[1] eq 'show-super')) {
    # This special case is handled by the standalone btrfs-show-super utility:
    $cmdline = $btrfs_cmd.' '.join(' ', map { '\''.$_.'\'' } @_);
  }

  $last_btrfs_cmdline = $cmdline;
  my $out = qx{$cmdline};
  $last_btrfs_output = $out;
  $last_btrfs_rc = int($? // 255);

  return (wantarray) ? split(/\n/, $out) : $out;
}

sub check_for_btrfs_errors(;$) {
  my $cond = $_[0];
  my $ok = (defined $cond) ? (!!($cond)) : (int($last_btrfs_rc) == 0);
  return 1 if ($ok);

  warn_without_stack_trace($btrfs_cmd.' returned exit code '.$last_btrfs_rc.' and errno '.$!);
  printfd(STDERR, NL.$C.$U.'Command:'.$X.' '.$R.'(exit code '.$M.$last_btrfs_rc.$R.')'.$X.NL.NL.$G.$last_btrfs_cmdline.$X.NL.NL);
  printfd(STDERR, $Y.$U.'Output (from command\'s stdout):'.$X.NL.NL.$R.
          $last_btrfs_output.$X.NL.$K.'[End of command output]'.$X.NL.NL);
  die;
  return 0;
}

sub format_subvol_attrs(+) {
  my $h = $_[0];

  my $type = $h->{type} // FSOBJ_TYPE_UNKNOWN;
  my $type_name = $fsobj_type_to_name{$type} // '<unknown type '.$type.'>';

  #my $out = $G.$type_name.$X.' '.$C.$U.$h->{path}.':'.$X.NL;
  my $out = $C.$U.$h->{path}.':'.$X.NL;

  # print the attributes in a logically sensible order:
  my @key_order = qw(type id parent_id toplevel_id uuid parent_uuid 
                     gen creation_gen
                     readonly writable snapshot
                     fs_uuid fs_label 
                     root_subvol_id root_subvol_path);
  
  foreach $k (@key_order) {
    next if (!exists $h->{$k});
    my $v = $h->{$k} // '<undefined>';
    if ($k eq 'type') { $v = $G.$type_name; }
    $out .= sprintf('  '.$Y.'%-17s'.$X.' %s'.$X.NL, ($k.':'), $v);
  }
  $out .= NL;
  return $out;
}

sub format_subvol_attrs_as_env_vars(+;$) {
  my $h = $_[0];

  foreach $k (sort keys %{$h}) {
    my $v = $h->{$k} // '';
    if ($k eq 'type') { $v = $fsobj_type_to_name{$v} // 'undefined'; }
    $out .= 'BTRFS_SUBVOL_'.uc($k).'=\''.$v.'\''.NL;
  }
  return $out;
}

our %fs_root_to_fs_uuid = ( );

my $fs_label_and_uuid_re = 
  qr{^  Label: \s*+ (none | (?> ' [^']+ ')) \s*+ 
     \b uuid: \s*+ (\S++)}oamsx;

my $fs_dev_re = 
  qr{^ \s*+ 
     devid \s++ (\d++) \s++
     size  \s++ (\S++) \s++
     used  \s++ (\S++) \s++
     path  \s++ (\N+) \n}oamsx;


my $btrfs_get_default_subvolume_re = 
  qr{^ID \s++ (\d++) 
     (?: 
       \s++ gen (\d++)
       \s++ top \s level \s++ (\d++)
       (?: \s++ path (\N++))?
     )?
    }oamsx;

sub get_root_subvol_attrs($) {
  my ($fs_root) = @_;
  my $s = run_btrfs_command('filesystem', 'show', $fs_root);

  my ($fs_label, $fs_uuid) = ($s =~ qr/$fs_label_and_uuid_re/oamsx);

  my @dev_list = split_into_array_of_arrays_of_captured_groups($s, $fs_dev_re);

  my %h = (
    id => 0, gen => 0, creation_gen => 0, parent_id => undef, 
    toplevel_id => undef, parent_uuid => undef, uuid => undef, 
    path => $fs_root, snapshot => 0, readonly => 0, writable => 0,
    type => FSOBJ_TYPE_BTRFS_MOUNT_POINT);

  return \%h if (!defined($fs_uuid));

  foreach $dev (@dev_list) {
    #my ($match, $devid, $size, $used, $block_dev_path) = @{$dev};
    my %devinfo = (
      devid => $dev->[1],
      size  => $dev->[2],
      used  => $dev->[3],
      block_dev_path => $dev->[4]);
    $dev = \%devinfo;
  }

  $h{devices} = \@dev_list;

  $h{fs_uuid} = $fs_uuid;
  $h{fs_label} = $fs_label;
  $fs_root_to_fs_uuid{$fs_root} = $fs_uuid;

  $s = run_btrfs_command('subvolume', 'get-default', $fs_root);

  check_for_btrfs_errors();

  my $writable = is_subvol_writable($fs_root);
  my $readonly = $writable ? 0 : 1;

  $h{readonly} = $readonly;
  $h{writable} = $writable;

  my ($root_subvol_id, $gen, $root_toplevel_id, $root_subvol_path) = 
    ($s =~ /$btrfs_get_default_subvolume_re/oamsx);
  
  die unless (is_there($root_subvol_id));

  $h{id} = $root_subvol_id;
  $h{root_subvol_id} = $root_subvol_id;
  $h{root_subvol_path} = 
    ($fs_root eq '/' ? '' : $fs_root).
    '/'.($root_subvol_path // '');
  $h{toplevel_id} = $root_toplevel_id // BTRFS_DEFAULT_ROOT_SUBVOL_ID;
  $h{gen} = $gen // 0;
  $h{type} = FSOBJ_TYPE_BTRFS_ROOT;

  $h{uuid} = $fs_uuid;

  # Skip this step unless we really need to know the filesystem's generation number:
  my $query_superblock_details = 0;

  if ($query_superblock_details) {    
    $s = run_btrfs_command('device', 'show-super', $dev_list[0]->{block_dev_path});
    check_for_btrfs_errors();
    my %superblock = ( );
    while ($s =~ /^ (\S++) \s++ (\N++) \n/oamsx) { 
      my ($k, $v) = ($1, $2);
      $v =~ s{\s*+ \[match\]$}{}oamsxg;
      $superblock{$k} = $v; 
    }
    $h{superblock} = \%superblock;
    $h{gen} = $superblock{generation};
    $h{creation_gen} = $superblock{generation};
  }

  return \%h;
};

sub parse_btrfs_subvol_attrs($;$) {
  local ($input, $fs_root) = @_;
  $fs_root = $_[1] // '/';
  my $fs_root_prefix = ($fs_root =~ s{/$}{}roaxg).'/';

  if (my ($id, $gen, $creation_gen, $parent_id, 
          $toplevel_id, $parent_uuid, $uuid, $path) =
            ($input =~ /$btrfs_subvol_list_re/oamsxg)) {

    my $snapshot = (((defined $parent_uuid) && ($parent_uuid ne '-')) ? 1 : 0),
    my $writable = is_subvol_writable($fs_root_prefix.$path);
    my $readonly = !$writable;
    my $type = 
      (($snapshot) 
        ? ($writable ? FSOBJ_TYPE_WRITABLE_SNAPSHOT : FSOBJ_TYPE_SNAPSHOT)
        : ($writable ? FSOBJ_TYPE_SUBVOL : FSOBJ_TYPE_READONLY_SUBVOL));

    my %h = (
      id => $id, 
      type => $type,
      gen => $gen, 
      creation_gen => $creation_gen,
      parent_id => $parent_id, 
      toplevel_id => $toplevel_id,
      parent_uuid => $parent_uuid, 
      uuid => $uuid, 
      path => $path,
      #fs_uuid => $fs_root_to_fs_uuid{$fs_root} // undef,
      snapshot => (((defined $parent_uuid) && ($parent_uuid ne '-')) ? 1 : 0),
      readonly => ($readonly ? 1 : 0),
      writable => ($readonly ? 0 : 1));

    return \%h;
  } else {
    warn('Cannot parse output of "btrfs subvol show": "'.$input.'"');
    return undef;
  }
}

sub query_btrfs_subvols(;$) {
  my $fs_root = $1 // '/';
  %subvols = ( );

  my $root_subvol_attrs = get_root_subvol_attrs($fs_root);

  $subvols{'/'} = $root_subvol_attrs;

  @subvol_list_to_parse = run_btrfs_command(qw(subvolume list -a -p -c -g -u -q), $fs_root);

  foreach $s (@subvol_list_to_parse) {
    my $h = parse_btrfs_subvol_attrs($s, $fs_root);
    die unless (defined($h));
    #$h->{fs_uuid} = $root_subvol_attrs->{fs_uuid};
    $subvols{$h->{path}} = $h;
  }

  return (wantarray ? %subvols : \%subvols);
}

my %btrfs_subvol_show_output_fields_to_query_btrfs_subvol_hash_keys = (
  'Name' => 'path',
  'uuid' => 'uuid',
  'Parent uuid' => 'parent_uuid',
  'Creation time' => 'creation_timestamp',
  'Object ID' => 'id',
  'Generation (Gen)' => 'gen',
  'Gen at creation' => 'creation_gen',
  'Parent' => 'parent_id',
  'Top Level' => 'toplevel_id',
  'Flags' => 'flags',
  'Snapshot(s)' => 'snapshot_list');

my $btrfs_subvol_show_re = 
  qr{^ \s*+ ([^\:\n]++) \: \s*+
     (\N*+) \n
  }oamsx;

sub query_btrfs_subvol($;$) {
  my ($subvol_path, $fs_root) = @_;
  $fs_root //= '/';

  my $readonly = 0;
  my $writable = 0;
  my $subvol_is_root = 0;
  my $snapshot = 0;

  my $out = run_btrfs_command('subvolume', 'show', $subvol_path);
  # check_for_btrfs_errors();
  if ($out =~ /ERROR/) { return undef; }

  my %subvol_info = ( );

  if ($out =~ /is btrfs root/) { 
    %subvol_info = get_root_subvol_attrs($fs_root);
  } else {
    while ($out =~ /$btrfs_subvol_show_re/oamsxg) {
      my ($key, $value) = ($1, $2);
      if ($key eq 'Flags') {
        $subvol_info{readonly} = ($value =~ /readonly/) ? 1 : 0;
        $subvol_info{writable} = ($readonly) ? 0 : 1;
      } elsif ($key eq 'Parent uuid') {
        $subvol_info{snapshot} = ($value ne '-') ? 1 : 0;
        if ($value eq '-') { $value = undef; }
      }
      $key = $btrfs_subvol_show_output_fields_to_query_btrfs_subvol_hash_keys{$key};
      $subvol_info{$key} = $value;
    }

    $subvol_info{type} = 
      ($snapshot) ? (($writable) ? FSOBJ_TYPE_WRITABLE_SNAPSHOT : FSOBJ_TYPE_SNAPSHOT) :
        (($writable) ? FSOBJ_TYPE_SUBVOL : FSOBJ_TYPE_READONLY_SUBVOL);
  }

  return (wantarray ? %subvol_info : \%subvol_info);
}

sub is_btrfs_snapshot($) {
  my ($path) = @_;

  my $subvol_info = query_btrfs_subvol($path);
  if (!defined $subvol_info) { return 0; }

  return $subvol_info->{snapshot} // 0;
}

sub create_btrfs_subvol($;$) {
  my ($path, $qgroupid) = @_;

  my @cmdline = ('subvolume', 'create', $path);
  if (defined $qgroupid) { push @cmdline,('-i', $qgroupid); }

  my $result = run_btrfs_command(@cmdline);
  check_for_btrfs_errors();
  return ($last_btrfs_rc == 0);
}

sub create_btrfs_snapshot($$;$$) {
  my ($source_subvolume, $snapshot_name, $readonly, $qgroupid) = @_;

  my @cmdline = ('subvolume', 'snapshot', $source_subvolume, $snapshot_name);
  if (($readonly // 0) > 0) { push @cmdline,'-r'; }
  if (defined $qgroupid) { push @cmdline,('-i', $qgroupid); }

  my $result = run_btrfs_command(@cmdline);
  check_for_btrfs_errors();
  return ($last_btrfs_rc == 0);
}

sub remove_btrfs_subvols {
  my $result = run_btrfs_command('subvolume', 'delete', @_);
  check_for_btrfs_errors();
  return ($last_btrfs_rc == 0);
}

sub remove_btrfs_subvol {
  return remove_btrfs_subvols(@_);
}

my $btrfs_property_re = qr{^ (\w++) \s*+ = \s*+ (\N+) \n}oamsx;

sub get_btrfs_property($$) {
  my ($path, $property) = @_;

  my $result = run_btrfs_command('property', 'get', $path, $property);
  check_for_btrfs_errors();
  if ($result =~ /$btrfs_property_re/oamsx) {
    return $2;
  } else {
    return undef;
  }
}

sub set_btrfs_property($$$) {
  my ($path, $property, $value) = @_;

  my $result = run_btrfs_command('property', 'set', $path, $property, $value);
  check_for_btrfs_errors();
  return ($last_btrfs_rc == 0);
}

sub update_subvol_xattrs($;$) {
  my ($subvol, $fs_root) = @_;
  $fs_root //= '/';
  my %attrs = query_btrfs_subvol($subvol, $fs_root);

  my %extattrs = (
    'user.subvol.type' => $fsobj_type_to_name{$attrs{type}},
    'user.subvol.uuid' => $attrs{uuid},
    'user.subvol.parent_uuid' => $attrs{parent_uuid},
    'user.subvol.creation_timestamp' => $attrs{creation_timestamp},
    'user.subvol.id' => $attrs{id},
    'user.subvol.parent_id' => $attrs{parent_id},
    'user.subvol.toplevel_id' => $attrs{toplevel_id},
    'user.subvol.creation_gen' => $attrs{creation_gen},
    'user.subvol.gen' => $attrs{gen},
    'user.subvol.readonly' => $attrs{readonly},
    'user.subvol.writable' => $attrs{writable},
    'user.subvol.snapshot' => $attrs{snapshot});

  set_xattrs($subvol, %extattrs);
}
