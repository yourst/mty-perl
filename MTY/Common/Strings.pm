#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Common::Strings
#
# Character string and text related utility functions
# (except for regular expressions, which are in MTY::RegExp::*)
#
# Copyright 1997 - 2014 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Common::Strings;

use integer; use warnings; use Exporter::Lite;

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($control_chars_re $undef_placeholder %boolean_words
     %print_debug_enabled_for_package @powers_of_1024_unit_names ALIGN_CENTER
     ALIGN_JUSTIFIED ALIGN_LEFT ALIGN_RIGHT CR ESC NL TAB
     add_prefix_and_suffix add_prefix_and_suffix_in_place append_with_sep
     bitmap_of_matching_chars chop_off_start_and_end_markers contains
     count_and_remove_leading_spaces count_and_remove_trailing_spaces
     count_lines count_matching_chars count_non_matching_chars
     delimited_strings_to_subarrays ends_with format_hex
     format_size_with_units insert_thousands_separators
     interpolate_control_chars is_printdebug_enabled join_and_wrap_long_lines
     join_undefs join_undefs_with_sep join_with_prefix_and_suffix
     length_with_thousands_separators maxlength padstring
     padstring_with_suffix padstrings
     parse_list_of_key_equals_value_into_hash printdebug printed_length
     printfd prints remove_leading_space remove_leading_trailing_space
     remove_leading_trailing_space_and_undef_if_empty remove_trailing_space
     remove_with_regexp_and_return_removed_char_count sep_if_not_first
     starts_with substitute_placeholders truncate_printed_string
     truncate_printed_strings word_wrap_long_lines wrap);

use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::RegExp::Define;
use MTY::RegExp::Strings;
use MTY::Display::ANSIColorREs;

use Text::Tabs ();
#use String::Util qw(crunch hascontent nocontent trim ltrim rtrim define unquote no_space equndef neundef ords deords crunchlines);
#pragma end_of_includes

noexport:; use constant 1.01;

use constant {
  NL => "\n",
  CR => "\r",
  TAB => "\t",
  ESC => "\e",
};

sub contains($$) {
  return (index($_[0], $_[1]) >= 0) ? 1 : 0;
}

sub starts_with($$) {
  local (*s, *prefix) = \ (@_);
  return (((length $s) >= (length $prefix)) && (substr($s, 0, length($prefix)) eq $prefix)) ? 1 : 0;
}

sub ends_with($$) {
  local (*s, *suffix) = \ (@_);
  return (((length $s) >= (length $suffix)) && (substr($s, -length($suffix), length($suffix)) eq $suffix)) ? 1 : 0;
}

our $undef_placeholder = '<undef>';

sub join_undefs_with_sep($@) {
  my ($sep, @list) = @_;

  return join($sep, (map { $_ // $undef_placeholder } @list));
}

sub join_undefs {
  return join('', (map { $_ // $undef_placeholder } @_));
}

our %boolean_words = (
  '0' => 0,
  'no' => 0,
  'n' => 0,
  'false' => 0,
  'f' => 0,
  'off' => 0,
  'disable' => 0,
  'disabled' => 0,
  'without' => 0,
  'skip' => 0,
  'exclude' => 0,
  'not' => -1,

  '1' => 1,
  'yes' => 1,
  'y' => 1,
  'true' => 1,
  't' => 1,
  'on' => 1,
  'enable' => 1,
  'enabled' => 1,
  'with' => 1,
  'use' => 1,
);

sub printfd {
  my $fd = (defined(fileno($_[0]))) ? shift : STDOUT;
  print($fd join_undefs(@_));
}

sub prints { goto &printfd; }

our %print_debug_enabled_for_package = ( );

sub printdebug {
  my $package = caller() // 'main';
  if ($print_debug_enabled_for_package{$package} // 0) { printfd(STDERR, @_); }
}

sub is_printdebug_enabled(;$) {
  my $package = $_[0] // caller() // 'main';
  return ($print_debug_enabled_for_package{$package} // 0) ? 1 : 0;
}

INIT {
  my @printdebug_package_list = split(/,|\s+/oax, ($ENV{'PRINTDEBUG'} // ''));

  %print_debug_enabled_for_package = array_to_hash_keys(@printdebug_package_list, 1);

  if (scalar keys %print_debug_enabled_for_package) {
    printfd(STDERR, '# printdebug enabled via PRINTDEBUG environment variable for the following packages:'.NL.
                   '#  '.join(NL.'#  ', @printdebug_package_list).NL);
  }
}

sub append_with_sep($$$) {
  $_[0] .= $_[2] if (length($_[0]) > 0);
  $_[0] .= $_[1];
  return $_[0];
}

#
# count_matching_chars($string_to_search, $chars_to_match):
#
# Given the set of individual characters in <$chars_to_match>, return the total
# number of characters in <string_to_search> that appear in this set (multiple
# appearances of any character(s) in <string_to_search> are counted each time
# they appear).
#

sub count_matching_chars($$) {
  return ($_[0] =~ tr/$_[1]//);
}

sub count_non_matching_chars($$) {
  return ($_[0] =~ tr/$_[1]//c);
}

sub count_lines($) {
  my $n = 0;
  foreach $arg (@_) { $n += ($_[0] =~ tr/\n//s); }
  return $n;
}

our $control_chars_re = compile_regexp
  (qr{\\([abentrf])}oamsx, 'control_chars');

my %control_char_escapes_to_chars = 
  ('a' => "\a",
   'b' => "\b",
   'e' => "\e",
   'n' => "\n",
   't' => "\t",
   'r' => "\r",
   'f' => "\f");

sub interpolate_control_chars($) {
  return $_[0] =~ 
    s{$control_chars_re}
     {$control_char_escapes_to_chars{$1} // ('\\'.$1)}roamsxge;
}

#
# bitmap_of_matching_chars($string_to_search, $chars_to_match):
#
# Given the set of individual characters in <$chars_to_match>, return a bitmap
# where bit N is 1 if the character at index N in <$chars_to_match> appears
# anywhere within <$string_to_search>, or bit N is 0 if that character was
# not found within <$string_to_search>. The string specifying <$chars_to_match>
# should include at most 32 characters.
#
# Note that count_matching_chars($A, $B) may be greater than the number of bits
# set in bitmap_of_matching_chars($A, $B), since count_matching_chars() counts
# repeated characters multiple times, unlike bitmap_of_matching_chars().
#
sub bitmap_of_matching_chars($$) {
  die "TODO";
#  my $b = 0;
#  my $n = scalar($_[0]);
#  for ($i = 0; $i < $n; $i++) {
#    # ... substr($2, $i, 1); # is there a more efficient way to do this?
#    #return $1 ~= tr/$_[1]//s;
#  }
}

#
# $outstring = chop_off_start_and_end_markers($instring, $startchar, $endchar):
#
sub chop_off_start_and_end_markers($$$) {
  local (*s, *startchar, *endchar) = \ (@_);

  my $ec = chop($s);
  if ((ord($ec) ne ord($endchar)) || (ord($s) != ord($startchar))) {
    die('chop_off_start_and_end_markers('.$s.', '.$startchar.', '.$endchar.'): '.
        'real start was '.chr(ord($s)).' and end was '.$ec."\n");
  }
  return substr($s, 1, length($s)-1);
}

#
# maxlength($string1, $string2, ...):
# 
# Returns the length in characters of the longest string in the specified list.
#
# NOTE: This finds the raw length in characters; if you want the visual appearance 
# based printed length (taking into account control codes, special glyphs and tabs),
# use printed_length() instead (see below).
#

sub maxlength(@) {
  my $m = 0;
  foreach $s (@_) {
    next if (!defined($s));
    my $len = length($s);
    $m = ($len > $m) ? $len : $m;
  }
  return $m;
}

#
# printed_length($string1, $string2, ...):
#
# This function finds the true length of a string in printable characters:, even with 
# strings containing embedded console escape codes (e.g. for colors and attributes), 
# since it doesn't count those escapes when it calculates the true length of the string
# (unlike perl's length() function). It also expands each tab (\t) into 8 spaces.
#
# If multiple strings are specified as a list, printed_length() returns the length
# of the longest string in the list (*not* the sum of the lengths).
#

sub printed_length {
  my $maxlength = 0;
  foreach my $s (@_) {
    next if (!defined($s));
    my $n = length($s);
    my $nonprinted_count = ($s =~ tr/\x00-\x1F//);
    if ($nonprinted_count > 0) {
      # slow path: only do the following if the string contains control chars:
      $n = length(Text::Tabs::expand($s =~ s/$ansi_console_escapes_and_nonprinted_characters_re//roamsxg)); 
    }
    set_max($maxlength, $n);
  }
  return $maxlength;
}

sub truncate_printed_string($$) {
  return '' if ((!defined($_[0])) || ((length $_[0]) == 0) || ($_[1] == 0));
  # fast path: avoid the following unless string has control chars:
  if ($_[0] !~ tr/\x00-\x1F//s) { return substr($_[0], 0, $_[1]); }

  local (*s, *limit) = \ (@_);

  if ($s =~ tr/\t//s) { $s = Text::Tabs::expand($s); }

  set_min($limit, length($s));
  pos($s) = 0;
  my $n = 0;

  while ($n < $limit) {
    if ($s =~ /$ansi_console_escapes_and_nonprinted_characters_re/oamsxg) {
      ; # no action needed - just skip over these char(s), since they aren't printable
    } elsif ($s =~ /$printable_chars_re/oamsxg) {
      my $span_length = ($+[0] - $-[0]);
      my $over_length = ($n + $span_length) - $limit;
      if ($over_length > 0) { 
        $span_length -= $over_length;
        pos($s) = pos($s) - $over_length;
        $n = $limit;
        last;
      }
      $n += $span_length;
    }
  }

  return substr($s, 0, pos($s));
}

sub truncate_printed_strings {
  my $limit = shift;
  foreach my $s (@_) {
    $s = printed_substr($s, $limit);
  }

  return (wantarray ? @_ : \@_);
}

use constant {
  ALIGN_LEFT => -1,
  ALIGN_CENTER => 0,
  ALIGN_RIGHT => +1,
  ALIGN_JUSTIFIED => -1
};

#
# padstring($string, $alignment, $desired_length_in_chars, 
#   $optional_padding_string_to_repeat, $fill_right_when_centered, $suffix):
#
# Pad a string to the desired length in characters by repeating the padding string (or
# a single space (" ") if no padding is specified) until the combined length of the string
# plus the padding is at least the desired length (it may be longer than this if the string's
# length already exceeds the desired length, in which case no padding will be used).
#
# This function works correctly even with strings containing embedded console escape
# codes  (e.g. for colors and attributes); see printed_length() for details on this. Only the
# string may contain escape codes; the pad must only contain spaces or printable characters.
#
# In cases where the string would normally contain such escape codes (and optionally more text
# after them), padstring() will be more efficient if the escape codes and any subsequent text
# (which should be the same length if padstring() is being used to align columns) are removed
# from $string and instead placed in the $suffix argument (whose length is *not* counted when
# determining how much padding to insert). This optimization allows the normal lengthof() to
# be used on $string without the overhead of having to first remove its control codes.
#
# (For convenience the padstring_with_suffix() function is equivalent to this but without
# having top pass undef for the intervening arguments before $suffix).
#
sub padstring($$;$$$$) {
  my ($width, $align, $pad, $fill_right_when_centered, $suffix) = @_[1..5];
  my $rs = undef;

  if (!defined $_[0]) { return '<undef>'; }

  $align //= -1;
  $pad //= ' ';
  $fill_right_when_centered //= 0;

  # Negative width means align to the right:
  if ($width < 0) { $width = -$width; $align = +1; }
  my $len = printed_length($_[0]);
  if (length($pad) > 1) { $pad = substr($pad, 0, 1); }

  if ($len > $width) {
    $rs = substr($_[0], 0, $width);
    $len = min(printed_length($rs), $width);
  }

  my $n = $width - $len;
  my $leftpad; my $rightpad;

  if ($align == 0) { 
    # (0 = centered):
    my $n2 = int($n / 2);
    my $leftover = $width - ($n2 + $len + $n2);
    $leftpad = $n2;
    $rightpad = ($fill_right_when_centered ? ($n2 + $leftover) : 0);
  } elsif ($align < 0) {
    # (-1 = left):
    $leftpad = 0;
    $rightpad = $n;
  } elsif ($align > 0) {
    $leftpad = $n;
    $rightpad = 0;
  }

  return (($pad x $leftpad) . ($rs // $_[0]) . ($suffix // '') . ($pad x $rightpad));
}

sub padstring_with_suffix($$$;$) {
  my ($string, $suffix, $width, $alignment) = @_;
  return padstring($string, $width, $alignment, undef, undef, $suffix);
}

sub padstrings(+$;$$) {
  my $array = shift;
  foreach $s (@$array) {
    $s = padstring($s, @_);
  }
  return $array;
}

sub format_hex($;$;$) {
  my ($value, $width, $pad) = @_;

  my $format = '%'.(((defined $width) && ($width < 0)) ? '-' : '').
    ($pad // '').((defined $width) ? abs($width) : '').'llx';

  return sprintf($format, $value);
}

#
# join_with_prefix_and_suffix($prefix, $suffix, $sep, @list): 
# wrap a $prefix and $suffix around each item in the list of arguments, 
# then return a string of these wrapped items separated by $sep. (This
# is essentially an enhanced version of perl's join() function):
#

sub add_prefix_and_suffix {
  my ($prefix, $suffix, $listref) = @_;

  if (!is_array_ref($listref)) { $listref = \@_[2..scalar(@_)-1]; }
  my @out = map { $prefix.$_.$suffix; } @$listref;
  return (wantarray ? @out : \@out);
}

sub add_prefix_and_suffix_in_place {
  my ($prefix, $suffix, $listref) = @_;

  if (!is_array_ref($listref)) { $listref = \@_[2..scalar(@_)-1]; }
  foreach $elem (@$listref) { $elem = $prefix.$elem.$suffix; }
  return (wantarray ? @$listref : $listref);
}

sub join_with_prefix_and_suffix {
  my ($prefix, $suffix, $separator, $listref) = @_;

  if (!is_array_ref($listref)) { $listref = \@_[3..scalar(@_)-1]; }
  if (! scalar @$listref) { return $always_fail_re; }
  return $prefix.join($suffix.$separator.$prefix, @$listref).$suffix;
}

#
# wrap($prefix, $suffix, $sep, @list): wrap a $prefix and $suffix around each item
# in the list of arguments, then return a string of these wrapped items separated
# by $sep. (This is essentially an enhanced version of perl's join() function):
#

sub wrap($$$;@) {
  my ($prefix, $suffix, $sep) = @_;

  die if (!all_defined($prefix, $suffix, $sep));

  my $out = '';
  foreach (my $i = 3; $i < scalar(@_); $i++) {
    $out .= $sep if ($i > 3);
    $out .= $prefix . $_[$i] . $suffix;
  }

  return $out;
}

#
# Alternative regexps for removing leading and trailing whitespace:
#
#   m/\A \s* (.*?) \s* \Z/oamsxg      or:      s/^\s+ | \s+$/oamsxg
#   (sets $1)                                  (replaces original)
#
#                                     or:      s/^\s+//oamsx;
#                                              s/\s+$/oamsx/;
#                                              (even more efficient)
#

my $leading_spaces_re = qr{^\s*+}oamsx;
my $trailing_spaces_re = qr{\s*+$}oamsx;

sub remove_with_regexp_and_return_removed_char_count {
  return undef if (!defined($_[0]));
  my $re = $_[1] // $trailing_spaces_re;
  my $n = length($_[0]);
  $_[0] =~ s{$re}{}oamsxg;
  return ($n - length($_[0]));
}

sub count_and_remove_leading_spaces {
  return remove_with_regexp_and_return_removed_char_count($_[0], $leading_spaces_re);
}

sub count_and_remove_trailing_spaces {
  return remove_with_regexp_and_return_removed_char_count($_[0], $trailing_spaces_re);
}

sub remove_leading_space {
  return undef if (!defined($_[0]));
  return ($_[0] =~ s/$leading_spaces_re//roamsxg);
}

sub remove_trailing_space {
  return undef if (!defined($_[0]));
  return ($_[0] =~ s{$trailing_spaces_re}{}roamsxg);
}

sub remove_leading_trailing_space($) {
  return undef if (!defined($_[0]));
  return ($_[0] 
          =~ s/$leading_spaces_re//roag
          =~ s/$trailing_spaces_re//roag);
}

sub remove_leading_trailing_space_and_undef_if_empty($) {
  return undef if (!defined($_[0]));
  my $s = ($_[0] 
           =~ s/$leading_spaces_re//roag
           =~ s/$trailing_spaces_re//roag);
  return (length($s) > 0) ? $s : undef;
}

sub sep_if_not_first($;$) {
  my $sep = $_[1] // ' ';
  return ((defined $_[0]) && ((length $_[0]) > 0)) ? $sep : '';
}

my $words_re = 
  qr{(?|
       (\n) | 
       (?> [\ \t]*+ ([^\s]++) [\ \t]++)
     )
    }oamsx;

sub join_and_wrap_long_lines(+;$$$$$) {
  #my ($list, $maxlength, $sep, $prefix, $suffix, $initial) = @_;
  local (*list, *maxlength, *sep, *prefix, *suffix, *initial) = \ (@_);

  $maxlength //= 78;
  $sep //= ' ';
  $prefix //= '';
  $suffix //= '';
  $initial //= '';

  my $sep_length = length($sep);
  my $prefix_length = printed_length($prefix);
  my $suffix_length = printed_length($suffix);
#  $maxlength = ($maxlength - $suffix_length) ? ($maxlength - $suffix_length) : 0;

  my $chars_so_far = printed_length($initial);
  my $out = '';
  my $word_in_line = 0;

  foreach $word (@$list) {
    my $force_nl = 0;
    if (!defined $word) { $force_nl = 1; $word = ''; }

    my $n = length($word);
    my $sepn = (($word_in_line > 0) ? $sep_length : 0);
    my $new_line_len = $chars_so_far + $sepn + $n;

    if (($new_line_len > $maxlength) || $force_nl) {
      $out .= $suffix.NL.$prefix;
      $chars_so_far = $prefix_length;
      $word_in_line = 0;
    }

    $out .= (($word_in_line > 0) ? $sep : '') . $word;
    $chars_so_far += $sepn + $n;
    $word_in_line++;
  }

  $out .= $suffix;

  return $out;
}

sub word_wrap_long_lines($;$$$$) {
  my ($s, $maxlength, $prefix, $suffix, $initial) = @_;


  return join_and_wrap_long_lines(split(/\s+/oax, $s), $maxlength, ' ', $prefix, $suffix, $initial);
}

sub delimited_strings_to_subarrays(+;$) {
  my ($rows, $delim) = @_;

  return [ map { [ split($delim, $_) ] } @$rows ];
}

my $placeholder_re = qr{(?! \\) % ((?| ([^\{]) | \{ ([^\}]++) \}))}oax;

sub substitute_placeholders($+) {
  my ($format, $placeholder_to_var_ref) = @_;

  return ($format =~ s{$placeholder_re}{
    my $valueref = $placeholder_to_var_ref->{$2};
    my $value = (is_code_ref $valueref) ? $valueref->($2, $1) : $$valueref;
    $value;
  }roaxge);
}

my $comma_colon_equals_re = qr{(?<! \\) [\,\:\=]}oax;

sub parse_list_of_key_equals_value_into_hash($) {
  my ($s) = @_;
  my @list = split(/$comma_colon_equals_re/, $s);
  if (((scalar @list) & 1) != 0) {
    warn($0.': parse_list_of_key_equals_value_into_hash: mismatch between keys and values'.NL.
           "Input string: ".$s.NL.
           "Created list: '".join("', '", @list)."' (".scalar(@list)." elements)".NL.
           'ARGV:'.NL.'  '.join(NL.'  ', @ARGV).NL);
    return { };
  }

  return { @list };
}

my $groups_of_3_digits_re = qr{\d\d\d \K (?= \d)}oax;

sub insert_thousands_separators($;$) {
  my ($s, $sep) = @_;
  $sep //= ',';

  my $n = length($s);
  if ($n <= 3) { return $s; }

  my $mod = $n % 3;
  return 
    substr($s, 0, $mod).
    (($mod > 0) ? $sep : '').
      (substr($s, $mod) =~ s{$groups_of_3_digits_re}{$sep}roaxg);
}

sub length_with_thousands_separators($;$) {
  my ($s, $sep) = @_;
  $s = "$s";
  $sep //= ',';

  my $n = length($s);
  return $n + (($n <= 3) ? 0 : ((($n - 1) / 3) * length($sep)));
}

our @powers_of_1024_unit_names = (' ', 'K', 'M', 'G', 'T', 'P', 'E');

sub format_size_with_units($;$$$$$) {
  my ($size, $max_decimal_digits, $separator, $units_prefix, $units_suffix, $custom_powers_of_1024_unit_names) = @_;
  $max_decimal_digits //= 7;
  $separator //= ',';
  $units_prefix //= ' ';
  $units_suffix //= 'b';
  $custom_powers_of_1024_unit_names //= \@powers_of_1024_unit_names;

  my $powers_of_1024 = 0;
  my $n = $size;

  while (length("$n") > $max_decimal_digits) {
    $n = ($n + 512) >> 10; 
    $powers_of_1024++;
  }

  my $sizestr = (is_there($separator)) ? insert_thousands_separators($n, $separator) : "$n";

  if ($powers_of_1024 > 0) {
    $sizestr .= $units_prefix.
      ($powers_of_1024_unit_names[$powers_of_1024] // '?').$units_suffix;
  }

  return $sizestr;
}

1;
