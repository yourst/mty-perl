#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Common::Strings
#
# Character string and text related utility functions
# (except for regular expressions, which are in MTY::RegExp::*)
#
# Copyright 1997 - 2014 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Common::Strings;

use integer; use warnings; use Exporter::Lite;

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($control_chars_re @powers_of_1024_unit_names ALIGN_CENTER ALIGN_JUSTIFIED
     ALIGN_LEFT ALIGN_RIGHT CR ESC NL TAB add_prefix_and_suffix
     add_prefix_and_suffix_in_place append_with_sep bitmap_of_matching_chars
     cat_undefs chop_off_start_and_end_markers contains
     count_and_remove_leading_spaces count_and_remove_trailing_spaces
     count_lines count_matching_chars count_non_matching_chars
     delimited_strings_to_subarrays ends_with
     expand_fields_and_columns_in_line format_columns
     format_delimited_columns format_hex format_size_with_units
     insert_thousands_separators interpolate_control_chars
     join_and_wrap_long_lines join_undefs join_with_prefix_and_suffix
     length_with_thousands_separators maxlength padstring
     padstring_with_suffix padstrings
     parse_list_of_key_equals_value_into_hash prep_to_format_columns
     prepare_prefix_string_subst_regexp print_columns printed_length
     remove_leading_space remove_leading_trailing_space
     remove_leading_trailing_space_and_undef_if_empty remove_trailing_space
     remove_with_regexp_and_return_removed_char_count sep_if_not_first
     starts_with subst_prefix_strings subst_prefix_strings_and_return_parts
     substitute_placeholders test_format_columns truncate_printed_string
     truncate_printed_strings word_wrap_long_lines wrap);

use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::RegExp::Define;
use MTY::RegExp::Strings;
use MTY::Display::ANSIColorREs;

use Text::Tabs ();
#use String::Util qw(crunch hascontent nocontent trim ltrim rtrim define unquote no_space equndef neundef ords deords crunchlines);
#pragma end_of_includes

noexport:; use constant 1.01;

use constant {
  NL => "\n",
  CR => "\r",
  TAB => "\t",
  ESC => "\e",
};

sub contains($$) {
  return (index($_[0], $_[1]) >= 0) ? 1 : 0;
}

sub starts_with($$) {
  local (*s, *prefix) = \ (@_);
  return (((length $s) >= (length $prefix)) && (substr($s, 0, length($prefix)) eq $prefix)) ? 1 : 0;
}

sub ends_with($$) {
  local (*s, *suffix) = \ (@_);
  return (((length $s) >= (length $suffix)) && (substr($s, -length($suffix), length($suffix)) eq $suffix)) ? 1 : 0;
}

sub join_undefs {
  my $sep = shift;
  my $out = '';
  my $first = 1;

  foreach my $obj (@_) {
    my $s = $obj // '<undef>';
    $out .= ($first ? '' : $sep).$s;
    $first = 0;
  }

  return $out;
}

sub cat_undefs {
  my $out = '';

  foreach my $obj (@_) {
    my $s = $obj // '<undef>';
    $out .= $s;
  }

  return $out;
}

sub append_with_sep($$$) {
  $_[0] .= $_[2] if (length($_[0]) > 0);
  $_[0] .= $_[1];
  return $_[0];
}

#
# count_matching_chars($string_to_search, $chars_to_match):
#
# Given the set of individual characters in <$chars_to_match>, return the total
# number of characters in <string_to_search> that appear in this set (multiple
# appearances of any character(s) in <string_to_search> are counted each time
# they appear).
#

sub count_matching_chars($$) {
  return ($_[0] =~ tr/$_[1]//);
}

sub count_non_matching_chars($$) {
  return ($_[0] =~ tr/$_[1]//c);
}

sub count_lines($) {
  my $n = 0;
  foreach $arg (@_) { $n += ($_[0] =~ tr/\n//s); }
  return $n;
}

our $control_chars_re = compile_regexp
  (qr{\\([abentrf])}oamsx, 'control_chars');

my %control_char_escapes_to_chars = 
  ('a' => "\a",
   'b' => "\b",
   'e' => "\e",
   'n' => "\n",
   't' => "\t",
   'r' => "\r",
   'f' => "\f");

sub interpolate_control_chars($) {
  return $_[0] =~ 
    s{$control_chars_re}
     {$control_char_escapes_to_chars{$1} // ('\\'.$1)}roamsxge;
}

#
# bitmap_of_matching_chars($string_to_search, $chars_to_match):
#
# Given the set of individual characters in <$chars_to_match>, return a bitmap
# where bit N is 1 if the character at index N in <$chars_to_match> appears
# anywhere within <$string_to_search>, or bit N is 0 if that character was
# not found within <$string_to_search>. The string specifying <$chars_to_match>
# should include at most 32 characters.
#
# Note that count_matching_chars($A, $B) may be greater than the number of bits
# set in bitmap_of_matching_chars($A, $B), since count_matching_chars() counts
# repeated characters multiple times, unlike bitmap_of_matching_chars().
#
sub bitmap_of_matching_chars($$) {
  die "TODO";
#  my $b = 0;
#  my $n = scalar($_[0]);
#  for ($i = 0; $i < $n; $i++) {
#    # ... substr($2, $i, 1); # is there a more efficient way to do this?
#    #return $1 ~= tr/$_[1]//s;
#  }
}

#
# $outstring = chop_off_start_and_end_markers($instring, $startchar, $endchar):
#
sub chop_off_start_and_end_markers($$$) {
  local (*s, *startchar, *endchar) = \ (@_);

  my $ec = chop($s);
  if ((ord($ec) ne ord($endchar)) || (ord($s) != ord($startchar))) {
    die('chop_off_start_and_end_markers('.$s.', '.$startchar.', '.$endchar.'): '.
        'real start was '.chr(ord($s)).' and end was '.$ec."\n");
  }
  return substr($s, 1, length($s)-1);
}

#
# maxlength($string1, $string2, ...):
# 
# Returns the length in characters of the longest string in the specified list.
#
# NOTE: This finds the raw length in characters; if you want the visual appearance 
# based printed length (taking into account control codes, special glyphs and tabs),
# use printed_length() instead (see below).
#

sub maxlength(@) {
  my $m = 0;
  foreach $s (@_) {
    next if (!defined($s));
    my $len = length($s);
    $m = ($len > $m) ? $len : $m;
  }
  return $m;
}

#
# printed_length($string1, $string2, ...):
#
# This function finds the true length of a string in printable characters:, even with 
# strings containing embedded console escape codes (e.g. for colors and attributes), 
# since it doesn't count those escapes when it calculates the true length of the string
# (unlike perl's length() function). It also expands each tab (\t) into 8 spaces.
#
# If multiple strings are specified as a list, printed_length() returns the length
# of the longest string in the list (*not* the sum of the lengths).
#

sub printed_length {
  my $maxlength = 0;
  foreach my $s (@_) {
    next if (!defined($s));
    my $n = length($s);
    my $nonprinted_count = ($s =~ tr/\x00-\x1F//);
    if ($nonprinted_count > 0) {
      # slow path: only do the following if the string contains control chars:
      $n = length(Text::Tabs::expand($s =~ s/$ansi_console_escapes_and_nonprinted_characters_re//roamsxg)); 
    }
    set_max($maxlength, $n);
  }
  return $maxlength;
}

sub truncate_printed_string($$) {
  return '' if ((!defined($_[0])) || ((length $_[0]) == 0) || ($_[1] == 0));
  # fast path: avoid the following unless string has control chars:
  if ($_[0] !~ tr/\x00-\x1F//s) { return substr($_[0], 0, $_[1]); }

  local (*s, *limit) = \ (@_);

  if ($s =~ tr/\t//s) { $s = Text::Tabs::expand($s); }

  set_min($limit, length($s));
  pos($s) = 0;
  my $n = 0;

  while ($n < $limit) {
    if ($s =~ /$ansi_console_escapes_and_nonprinted_characters_re/oamsxg) {
      ; # no action needed - just skip over these char(s), since they aren't printable
    } elsif ($s =~ /$printable_chars_re/oamsxg) {
      my $span_length = ($+[0] - $-[0]);
      my $over_length = ($n + $span_length) - $limit;
      if ($over_length > 0) { 
        $span_length -= $over_length;
        pos($s) = pos($s) - $over_length;
        $n = $limit;
        last;
      }
      $n += $span_length;
    }
  }

  return substr($s, 0, pos($s));
}

sub truncate_printed_strings {
  my $limit = shift;
  foreach my $s (@_) {
    $s = printed_substr($s, $limit);
  }

  return (wantarray ? @_ : \@_);
}

use constant {
  ALIGN_LEFT => -1,
  ALIGN_CENTER => 0,
  ALIGN_RIGHT => +1,
  ALIGN_JUSTIFIED => -1
};

#
# padstring($string, $alignment, $desired_length_in_chars, 
#   $optional_padding_string_to_repeat, $fill_right_when_centered, $suffix):
#
# Pad a string to the desired length in characters by repeating the padding string (or
# a single space (" ") if no padding is specified) until the combined length of the string
# plus the padding is at least the desired length (it may be longer than this if the string's
# length already exceeds the desired length, in which case no padding will be used).
#
# This function works correctly even with strings containing embedded console escape
# codes  (e.g. for colors and attributes); see printed_length() for details on this. Only the
# string may contain escape codes; the pad must only contain spaces or printable characters.
#
# In cases where the string would normally contain such escape codes (and optionally more text
# after them), padstring() will be more efficient if the escape codes and any subsequent text
# (which should be the same length if padstring() is being used to align columns) are removed
# from $string and instead placed in the $suffix argument (whose length is *not* counted when
# determining how much padding to insert). This optimization allows the normal lengthof() to
# be used on $string without the overhead of having to first remove its control codes.
#
# (For convenience the padstring_with_suffix() function is equivalent to this but without
# having top pass undef for the intervening arguments before $suffix).
#
sub padstring($$;$$$$) {
  my ($width, $align, $pad, $fill_right_when_centered, $suffix) = @_[1..5];
  my $rs = undef;

  if (!defined $_[0]) { return '<undef>'; }

  $align //= -1;
  $pad //= ' ';
  $fill_right_when_centered //= 0;

  # Negative width means align to the right:
  if ($width < 0) { $width = -$width; $align = +1; }
  my $len = printed_length($_[0]);
  if (length($pad) > 1) { $pad = substr($pad, 0, 1); }

  if ($len > $width) {
    $rs = substr($_[0], 0, $width);
    $len = min(printed_length($rs), $width);
  }

  my $n = $width - $len;
  my $leftpad; my $rightpad;

  if ($align == 0) { 
    # (0 = centered):
    my $n2 = int($n / 2);
    my $leftover = $width - ($n2 + $len + $n2);
    $leftpad = $n2;
    $rightpad = ($fill_right_when_centered ? ($n2 + $leftover) : 0);
  } elsif ($align < 0) {
    # (-1 = left):
    $leftpad = 0;
    $rightpad = $n;
  } elsif ($align > 0) {
    $leftpad = $n;
    $rightpad = 0;
  }

  return (($pad x $leftpad) . ($rs // $_[0]) . ($suffix // '') . ($pad x $rightpad));
}

sub padstring_with_suffix($$$;$) {
  my ($string, $suffix, $width, $alignment) = @_;
  return padstring($string, $width, $alignment, undef, undef, $suffix);
}

sub padstrings(+$;$$) {
  my $array = shift;
  foreach $s (@$array) {
    $s = padstring($s, @_);
  }
  return $array;
}

sub format_hex($;$;$) {
  my ($value, $width, $pad) = @_;

  my $format = '%'.(((defined $width) && ($width < 0)) ? '-' : '').
    ($pad // '').((defined $width) ? abs($width) : '').'llx';

  return sprintf($format, $value);
}

#
# join_with_prefix_and_suffix($prefix, $suffix, $sep, @list): 
# wrap a $prefix and $suffix around each item in the list of arguments, 
# then return a string of these wrapped items separated by $sep. (This
# is essentially an enhanced version of perl's join() function):
#

sub add_prefix_and_suffix {
  my ($prefix, $suffix, $listref) = @_;
  # local (*prefix, *suffix, *listref) = \ (@_);

  if (!is_array_ref($listref)) { $listref = \@_[2..scalar(@_)-1]; }
  my @out = map { $prefix.$_.$suffix; } @$listref;
  return (wantarray ? @out : \@out);
}

sub add_prefix_and_suffix_in_place {
  my ($prefix, $suffix, $listref) = @_;
  # local (*prefix, *suffix, *listref) = \ (@_);

  if (!is_array_ref($listref)) { $listref = \@_[2..scalar(@_)-1]; }
  foreach $elem (@$listref) { $elem = $prefix.$elem.$suffix; }
  return (wantarray ? @$listref : $listref);
}

sub join_with_prefix_and_suffix {
  my ($prefix, $suffix, $separator, $listref) = @_;
  # local (*prefix, *suffix, *separator, *listref) = \ (@_);

  if (!is_array_ref($listref)) { $listref = \@_[3..scalar(@_)-1]; }
  if (! scalar @$listref) { return $always_fail_re; }
  return $prefix.join($suffix.$separator.$prefix, @$listref).$suffix;
}

#
# wrap($prefix, $suffix, $sep, @list): wrap a $prefix and $suffix around each item
# in the list of arguments, then return a string of these wrapped items separated
# by $sep. (This is essentially an enhanced version of perl's join() function):
#

sub wrap($$$;@) {
  my ($prefix, $suffix, $sep) = @_;
  # local (*prefix, *suffix, *sep) = \ (@_);

  die if (!all_defined($prefix, $suffix, $sep));

  my $out = '';
  foreach (my $i = 3; $i < scalar(@_); $i++) {
    $out .= $sep if ($i > 3);
    $out .= $prefix . $_[$i] . $suffix;
  }

  return $out;
}

#
# Alternative regexps for removing leading and trailing whitespace:
#
#   m/\A \s* (.*?) \s* \Z/oamsxg      or:      s/^\s+ | \s+$/oamsxg
#   (sets $1)                                  (replaces original)
#
#                                     or:      s/^\s+//oamsx;
#                                              s/\s+$/oamsx/;
#                                              (even more efficient)
#

my $leading_spaces_re = qr{^\s*+}oamsx;
my $trailing_spaces_re = qr{\s*+$}oamsx;

sub remove_with_regexp_and_return_removed_char_count {
  return undef if (!defined($_[0]));
  my $re = $_[1] // $trailing_spaces_re;
  my $n = length($_[0]);
  $_[0] =~ s{$re}{}oamsxg;
  return ($n - length($_[0]));
}

sub count_and_remove_leading_spaces {
  return remove_with_regexp_and_return_removed_char_count($_[0], $leading_spaces_re);
}

sub count_and_remove_trailing_spaces {
  return remove_with_regexp_and_return_removed_char_count($_[0], $trailing_spaces_re);
}

sub remove_leading_space {
  return undef if (!defined($_[0]));
  return ($_[0] =~ s/$leading_spaces_re//roamsxg);
}

sub remove_trailing_space {
  return undef if (!defined($_[0]));
  return ($_[0] =~ s{$trailing_spaces_re}{}roamsxg);
}

sub remove_leading_trailing_space($) {
  return undef if (!defined($_[0]));
  return ($_[0] 
          =~ s/$leading_spaces_re//roag
          =~ s/$trailing_spaces_re//roag);
}

sub remove_leading_trailing_space_and_undef_if_empty($) {
  return undef if (!defined($_[0]));
  my $s = ($_[0] 
           =~ s/$leading_spaces_re//roag
           =~ s/$trailing_spaces_re//roag);
  return (length($s) > 0) ? $s : undef;
}

sub sep_if_not_first($;$) {
  my $sep = $_[1] // ' ';
  return ((defined $_[0]) && ((length $_[0]) > 0)) ? $sep : '';
}

my $words_re = 
  qr{(?|
       (\n) | 
       (?> [\ \t]*+ ([^\s]++) [\ \t]++)
     )
    }oamsx;

sub join_and_wrap_long_lines(+;$$$$$) {
  #my ($list, $maxlength, $sep, $prefix, $suffix, $initial) = @_;
  local (*list, *maxlength, *sep, *prefix, *suffix, *initial) = \ (@_);

  $maxlength //= 78;
  $sep //= ' ';
  $prefix //= '';
  $suffix //= '';
  $initial //= '';

  my $sep_length = length($sep);
  my $prefix_length = printed_length($prefix);
  my $suffix_length = printed_length($suffix);
#  $maxlength = ($maxlength - $suffix_length) ? ($maxlength - $suffix_length) : 0;

  my $chars_so_far = printed_length($initial);
  my $out = '';
  my $word_in_line = 0;

  foreach $word (@$list) {
    my $force_nl = 0;
    if (!defined $word) { $force_nl = 1; $word = ''; }

    my $n = length($word);
    my $sepn = (($word_in_line > 0) ? $sep_length : 0);
    my $new_line_len = $chars_so_far + $sepn + $n;

    if (($new_line_len > $maxlength) || $force_nl) {
      $out .= $suffix.NL.$prefix;
      $chars_so_far = $prefix_length;
      $word_in_line = 0;
    }

    $out .= (($word_in_line > 0) ? $sep : '') . $word;
    $chars_so_far += $sepn + $n;
    $word_in_line++;
  }

  $out .= $suffix;

  return $out;
}

sub word_wrap_long_lines($;$$$$) {
  my ($s, $maxlength, $prefix, $suffix, $initial) = @_;
  # local (*s, *maxlength, *prefix, *suffix, *initial) = \ (@_);


  return join_and_wrap_long_lines(split(/\s+/oax, $s), $maxlength, ' ', $prefix, $suffix, $initial);
}

sub prepare_prefix_string_subst_regexp {
  my ($first) = @_;
  # local (*first) = \ (@_);

  my $listref = (is_hash_ref($first)) ? [ keys %$first ] : 
                (is_array_ref($first)) ? $first : \@_;

  my $re = generate_regexp_to_match_any_string_in_list($listref);

  use Regexp::Optimizer;
  my $optimizer = Regexp::Optimizer->new;
  $re = '\A('.$optimizer->optimize($re).')';
  $re = qr{$re}oamsx;
  return $re;
}

sub subst_prefix_strings_and_return_parts($+;$) {
  my ($prefix_strings_to_replacements, $re) = @_[1,2];

  $before_replacement //= '';
  $after_replacement //= '';
  $re //= prepare_prefix_string_subst_regexp($prefix_strings_to_replacements);
  if ($_[0] =~ /$re/oax) {
    my $prefix = $1;
    my $prefix_length = $+[0] - $-[0];
    my $replacement = $prefix_strings_to_replacements->{$prefix} // '<unknown>';
    return ($replacement, substr($_[0], $prefix_length, length($_[0])-$prefix_length));
  } else {
    return (undef, $_[0]);
  }
}

sub subst_prefix_strings($+$;$$) {
  my ($replacement, $remainder) = subst_prefix_strings_and_return_parts($_[0], $_[1], $_[2]);

  if (!defined $replacement) { return $_[0]; }
  return ($_[3] // '').$replacement.($_[4] // '').$remainder;
}

my $field_column_markup_re = 
  qr{\% \{ (field|column) (?> \= ([^\}]+))? \}}oax;

my $field_column_markup_nocap_re = 
  qr{\% \{ (?> field | column) [^\}]++ \}}oax;

noexport:; sub expand_fields_and_columns_in_line($;$) {
  my ($line, $field_columns) = @_;

  my $field_id_counter = 0;
  my @field_columns = ( );
  my $prev_field_rel_pos = 0;
  my $prev_markup_abs_end_pos = 0;

  while (my ($op, $id) = ($line =~ /$field_column_markup_re/oax)) {
    if ($op eq 'field') {
      $id //= $field_id_counter;
      $field_id_counter++;
      my $start = $-[0];
      my $end = $+[0];
      
      my $markup_length = $end - $start;
      #my $non_markup_length_so_far 
      my $prev_field_rel_pos = $-[0];

      $prev_markup_abs_end_pos = $+[0];

      if ($op eq 'field') { $field_id_counter++; }
    }
  }
}

#
# Print the specified array of arrays ($rows[...] = [column1, column2, ...])
# with properly aligned and padded columns so the longest string in each
# column will entirely fit within its respective printed column.
#
sub prep_to_format_columns(+) {
  my ($rows) = @_;
  my $DEBUG = 0;

  if (is_hash_ref($rows)) 
    { $rows = hash_to_array_of_pairs($rows); }

  my $row_count = scalar(@$rows);

  my @longest_in_column = ( );
  my @lengths = ( );
  prealloc(@lengths, $row_count + 1);

  while (my ($r, $row) = each @$rows) {
    my @col_lengths_in_row = ( );

    while (my ($c, $col) = each @$row) {
      my $n = printed_length($col // '');
      $col_lengths_in_row[$c] = $n;
      $longest_in_column[$c] //= 0;
      set_max($longest_in_column[$c], $n);
    }

    $lengths[$r] = \@col_lengths_in_row;
  }

  $lengths[$row_count] = \@longest_in_column;

  if ($DEBUG) {
    print(STDERR "Printed length map:".NL);
    foreach my $row (@lengths) {
      print(STDERR '  ');
      foreach my $col (@$row) {
        printf(STDERR '%-4d ', $col);
      }
      print(STDERR NL);
    }
  }

  return \@lengths;
}

sub format_columns(+;+$$+$+$) {
  my ($rows, $colseps, $row_prefix, $row_suffix, $alignments, $clip_to_length, $lengths, $fd) = @_;
  $colseps //= ' ';
  $row_prefix //= '';
  $row_suffix //= ''.NL;
  $alignments //= ALIGN_LEFT;

  if (is_hash_ref($rows)) 
    { $rows = hash_to_array_of_pairs($rows); }

  if (!is_array_ref($colseps)) { $colseps = [ $colseps ]; }
  if (!is_array_ref($alignments)) { $alignments = [ $alignments ]; }

  $lengths //= prep_to_format_columns($rows);

  my $longest_in_column = $lengths->[(scalar @$lengths)-1];
  my $column_count = scalar @$longest_in_column;

  pad_array($alignments, $column_count);

  pad_array($colseps, $column_count);
  my @colsep_lengths = map { printed_length($_) } @$colseps;
  
  my @out = ( );

  my $row_prefix_length = printed_length($row_prefix);
  my $row_suffix_length = printed_length($row_suffix);

  while (my ($r, $row) = each @$rows) {
    my $rowout = '';

    my $col_count_in_row = scalar @$row;
    my $col_lengths_in_row = $lengths->[$r];

    my $row_length_in_chars = 0;
    $rowout .= $row_prefix;
    $row_length_in_chars += $row_prefix_length;

    while (my ($c, $col) = each @$row) {
      my $text = $col // '';
      my $len = $col_lengths_in_row->[$c] // 0;
      my $colout = '';

      if ($c < $col_count_in_row-1) {
        my $padlen = max($longest_in_column->[$c] - $len, 0);
        my $padding = ' ' x $padlen;
        my $alignment = $alignments->[$c];
        $colout .= 
          ($alignment == ALIGN_LEFT) ? ($text . $padding) :
          ($alignment == ALIGN_RIGHT) ? ($padding . $text) :
          die("Invalid alignment $alignment");
        $row_length_in_chars += $padlen;
      } else {
        # Don't pad the last column, to avoid effectively double spacing every line
        # just because a few rows have really long last columns (e.g. variable length
        # strings like filenames, etc., which traditionally appear in the last column).
        $colout .= $text;
      }

      $row_length_in_chars += $len;

      $colout .= $colseps->[$c];
      $row_length_in_chars += $colsep_lengths[$c];

      $rowout .= $colout;
    }

    $rowout .= $row_suffix;
    $row_length_in_chars += $row_suffix_length;

    # if ((defined $clip_to_length) && ($row_length_in_chars > $clip_to_length))
    #  { $rowout = truncate_printed_string($rowout, $clip_to_length); }

    $out[$r] = $rowout;
  }

  if (defined $fd) { print($fd join('', @out)); }

  return (wantarray ? @out : (defined wantarray) ? join('', @out) : ( ));
}

sub print_columns($+;+$$+$+) {
  my ($fd, $rows, $colseps, $row_prefix, $row_suffix, $alignments, $clip_to_length, $lengths) = @_;
  format_columns($rows, $colseps, $row_prefix, $row_suffix, $alignments, $clip_to_length, $lengths, $fd);
}

sub delimited_strings_to_subarrays(+;$) {
  my ($rows, $delim) = @_;

  return [ map { [ split($delim, $_) ] } @$rows ];
}

sub format_delimited_columns(+;$+$$+$) {
  my ($rows, $delim, $colseps, $row_prefix, $row_suffix, $alignments, $clip_to_length) = @_;
  return format_columns([ map { [ split($delim, $_) ] } @$rows ], $colseps, $row_prefix, $row_suffix, $alignments, $clip_to_length);
}

sub test_format_columns() {
  my $table = [
    ['first',        'premier',       '1st'],
    ['second',       'sorry sekond',  '2nd'],
    ['third',        'trois place',   '3'],
    ['fourth',       'finale',        'four is more'],
  ];

  my $out = format_columns($table, ' | ', '<< ', ' >>'.NL, [ ALIGN_RIGHT, ALIGN_RIGHT, ALIGN_LEFT ]);
  print($out);

  my $tab_delim_array = [
    "first\tpremier\t1st",
    "second\tsorry sekond\t2nd",
    "third\ttrois place\t3",
    "fourth\tfinale\tfour is more",
  ];

  $out = format_delimited_columns($tab_delim_array, "\t", ' | ', '{{ ', ' }}'.NL, [ ALIGN_LEFT, ALIGN_RIGHT, ALIGN_LEFT ]);
  print($out);
}

my $placeholder_re = qr{(?! \\) % ((?| ([^\{]) | \{ ([^\}]++) \}))}oax;

sub substitute_placeholders($+) {
  my ($format, $placeholder_to_var_ref) = @_;

  return ($format =~ s{$placeholder_re}{
      my $valueref = $placeholder_to_var_ref->{$2};
      my $value = (is_code_ref $valueref) ? $valueref->($2, $1) : $$valueref;
      $value;
    }roaxge);
}

my $comma_colon_equals_re = qr{[\,\:\=]}oax;

sub parse_list_of_key_equals_value_into_hash($) {
  return { split(/$comma_colon_equals_re/, $_[0]) };
}

my $groups_of_3_digits_re = qr{\d\d\d \K (?= \d)}oax;

sub insert_thousands_separators($;$) {
  my ($s, $sep) = @_;
  $sep //= ',';

  my $n = length($s);
  if ($n <= 3) { return $s; }

  my $mod = $n % 3;
  return 
    substr($s, 0, $mod).
    (($mod > 0) ? $sep : '').
      (substr($s, $mod) =~ s{$groups_of_3_digits_re}{$sep}roaxg);
}

sub length_with_thousands_separators($;$) {
  my ($s, $sep) = @_;
  $s = "$s";
  $sep //= ',';

  my $n = length($s);
  return $n + (($n <= 3) ? 0 : ((($n - 1) / 3) * length($sep)));
}

our @powers_of_1024_unit_names = (' ', 'K', 'M', 'G', 'T', 'P', 'E');

sub format_size_with_units($;$$$$$) {
  my ($size, $max_decimal_digits, $separator, $units_prefix, $units_suffix, $custom_powers_of_1024_unit_names) = @_;
  $max_decimal_digits //= 7;
  $separator //= ',';
  $units_prefix //= ' ';
  $units_suffix //= 'b';
  $custom_powers_of_1024_unit_names //= \@powers_of_1024_unit_names;

  my $powers_of_1024 = 0;
  my $n = $size;

  while (length("$n") > $max_decimal_digits) {
    $n = ($n + 512) >> 10; 
    $powers_of_1024++;
  }

  my $sizestr = (is_there($separator)) ? insert_thousands_separators($n, $separator) : "$n";

  if ($powers_of_1024 > 0) {
    $sizestr .= $units_prefix.
      ($powers_of_1024_unit_names[$powers_of_1024] // '?').$units_suffix;
  }

  return $sizestr;
}

1;
