#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Common::Strings
#
# Character string and text related utility functions
# (except for regular expressions, which are in MTY::RegExp::*)
#
# Copyright 1997 - 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Common::Strings;

use integer; use warnings; use Exporter qw(import);

use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Common::PrintDebug;
use MTY::RegExp::Define;
use MTY::RegExp::Strings;
use MTY::RegExp::Blocks;
use MTY::Display::ANSIColorREs;

#pragma end_of_includes

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(contains ends_with hexstring maxlength padstring ALIGN_LEFT padstrings
     ALIGN_RIGHT count_lines expand_tabs join_around join_undefs starts_with
     ALIGN_CENTER %boolean_words printed_length ALIGN_JUSTIFIED
     append_with_sep hex_digit_count remove_from_end wrap_long_lines
     sep_if_not_first $control_chars_re remove_from_start decimal_digit_count
     count_matching_chars join_undefs_with_sep remove_leading_space
     word_wrap_long_lines add_prefix_and_suffix padstring_with_suffix
     remove_trailing_space replace_unicode_chars format_size_with_units
     substitute_placeholders truncate_printed_string count_non_matching_chars
     truncate_printed_strings interpolate_control_chars
     @powers_of_1024_unit_names insert_thousands_separators
     join_with_prefix_and_suffix recursively_process_strings
     remove_leading_trailing_space add_prefix_and_suffix_in_place
     chop_off_start_and_end_markers delimited_strings_to_subarrays
     relative_tab_stops_to_absolute count_and_remove_leading_spaces
     count_and_remove_trailing_spaces length_with_thousands_separators
     split_into_words_and_line_breaks printed_length_with_expanded_tabs
     parse_list_of_key_equals_value_into_hash
     remove_leading_trailing_space_and_undef_if_empty
     remove_with_regexp_and_return_removed_char_count);

# Re-export these from PrintDebug package for convenience:
push @EXPORT, @MTY::Common::PrintDebug::EXPORT;

sub contains($$) {
  return (index($_[0], $_[1]) >= 0) ? 1 : 0;
}

sub starts_with($$) {
  my ($s, $prefix) = @_;
  return (((length $s) >= (length $prefix)) && (substr($s, 0, length($prefix)) eq $prefix)) ? 1 : 0;
}

sub ends_with($$) {
  my ($s, $suffix) = @_;
  return (((length $s) >= (length $suffix)) && (substr($s, -length($suffix), length($suffix)) eq $suffix)) ? 1 : 0;
}

sub remove_from_start($$) {
  my ($s, $prefix) = @_;
  my $n = length($prefix);
  return (((length $s) >= $n) && (substr($s, 0, $n) eq $prefix)) ? substr($s, $n) : $s;
}

sub remove_from_end($$) {
  my ($s, $suffix) = @_;
  my $n = length($suffix);
  return (((length $s) >= $n) && (substr($s, -$n, $n) eq $suffix)) ? substr($s, 0, (length $s) - $n) : $s;
}

sub join_undefs_with_sep($@) {
  my ($sep, @list) = @_;

  return join($sep, (map { $_ // $undef_placeholder } @list));
}

sub join_undefs {
  return join('', (map { $_ // $undef_placeholder } @_));
}

our %boolean_words = (
  '0' => 0,
  'no' => 0,
  'n' => 0,
  'false' => 0,
  'f' => 0,
  'off' => 0,
  'disable' => 0,
  'disabled' => 0,
  'without' => 0,
  'skip' => 0,
  'exclude' => 0,
  '-' => 0,

  'not' => -1,
  '~' => -1,
  '^' => -1,

  '1' => 1,
  'yes' => 1,
  'y' => 1,
  'true' => 1,
  't' => 1,
  'on' => 1,
  'enable' => 1,
  'enabled' => 1,
  'with' => 1,
  'use' => 1,
);

sub append_with_sep($$$) {
  $_[0] .= $_[2] if (length($_[0]) > 0);
  $_[0] .= $_[1];
  return $_[0];
}

#
# count_matching_chars($string_to_search, $chars_to_match):
#
# Given the set of individual characters in <$chars_to_match>, return the total
# number of characters in <string_to_search> that appear in this set (multiple
# appearances of any character(s) in <string_to_search> are counted each time
# they appear).
#

sub count_matching_chars($$) {
  return ($_[0] =~ tr/$_[1]//);
}

sub count_non_matching_chars($$) {
  return ($_[0] =~ tr/$_[1]//c);
}

sub count_lines($) {
  my $n = 0;
  foreach my $arg (@_) { $n += ($_[0] =~ tr/\n//s); }
  return $n;
}

our $control_chars_re = compile_regexp
  (qr{\\([abentrf])}oamsx, 'control_chars');

my %control_char_escapes_to_chars = 
  ('a' => "\a",
   'b' => "\b",
   'e' => "\e",
   'n' => "\n",
   't' => "\t",
   'r' => "\r",
   'f' => "\f");

sub interpolate_control_chars($) {
  return $_[0] =~ 
    s{$control_chars_re}
     {$control_char_escapes_to_chars{$1} // ('\\'.$1)}roamsxge;
}

#
# $outstring = chop_off_start_and_end_markers($instring, $startchar, $endchar):
#
sub chop_off_start_and_end_markers($$$) {
  local (*s, *startchar, *endchar) = \ (@_);

  my $ec = chop($s);
  if ((ord($ec) ne ord($endchar)) || (ord($s) != ord($startchar))) {
    die('chop_off_start_and_end_markers('.$s.', '.$startchar.', '.$endchar.'): '.
        'real start was '.chr(ord($s)).' and end was '.$ec."\n");
  }
  return substr($s, 1, length($s)-1);
}

#
# maxlength($string1, $string2, ...):
# 
# Returns the length in characters of the longest string in the specified list.
#
# NOTE: This finds the raw length in characters; if you want the visual appearance 
# based printed length (taking into account control codes, special glyphs and tabs),
# use printed_length() instead (see below).
#

sub maxlength {
  my $m = 0;
  foreach my $s (@_) { set_max($m, length($s // '')); }
  return $m;
}

#
# Convert the argument list comprising absolute and/or relative tab stop
# positions into the returned list of only absolute positions. Relative
# offsets are specified using negative integers: e.g. -10 will produce
# a tab stop at (the previous absolute position) + 10. (Negative offsets
# obviously cannot even be represented using this scheme). The special
# value of 0 will create a new tab stop at the same position as the
# previous tab stop; it will *not* return it to absolute position 0.
#
# The first entry in the input list should be non-zero, i.e. given a
# string whose first character is a tab, this first entry should be
# the absolute position to which that initial tab should jump.
#
# If the input list contains only absolute tab stops, they may appear in
# any order, but if relative tab stops are specified, the list must be
# sorted in ascending order. The returned list will always be sorted in
# ascending order.
#
sub relative_tab_stops_to_absolute {
  my ($positions) = &array_args;

  my $pos = 0;
  return (sort map {
    $pos = ($_ > 0) ? $_ : ($pos + (-$_));
  } @$positions);
}

#
# Expand tab characters ("\t", i.e. character code 0x09)
# within the specified input string according to the
# provided array of tab stop positions, which should be
# absolute positions in ascending order (if not, use the
# relative_tab_stops_to_absolute() function first). 
#
# If a single integer N is provided instead of an array,
# this function will assume a tab stop should occur
# every N characters. 
#
# If the provided array is smaller than the number of
# tabs in the input string, additional tab stops will
# be assumed to exist beyond the last array element
# with a spacing equal to the difference between the
# last two real tab stops (i.e. as returned by the
# infinite_array_using_final_stride function above).
#
# If the input string is the only argument, tab stops
# every 8 characters will be used (this may be changed
# by setting the $default_tab_stops package variable to
# reference a different array of tab stops).
#
# Each tab character within the input string will cause
# the output position to jump to the nearest tab stop
# position greater than the current position. The string
# returned by this function will be padded with spaces
# (or the character(s) in $replace_with if specified)
# whenever the position jumps to a tab stop.
# 
# If the $pos argument is specified, this function will
# assume the first character of the input string is
# actually at position $already_at_pos. This is useful
# for on-screen output when part of a line (before the
# provided string's text) has already been printed, 
# and the tab expanded result should line up properly
# if printed immediately after this initial output.
#

my $default_tab_stops = [ 8 ];

my $text_or_tab_or_nl_re = qr{((?> [^\t\n]++ | [\t\n]))}oamsx;

sub expand_tabs($;+$$$) {
  my ($input, $tab_stops, $replace_with, $pos, $only_return_length) = @_;
  $only_return_length //= 0;

  #
  # Fast path: if input only contains straight printable ASCII characters
  # without any tabs, newlines, ANSI color escapes, control characters or
  # multi-byte UTF-8 characters, simply return the input:
  #
  my $nonprinted_or_unicode_count = ($input =~ tr{\x00-\x1f\x80-\xff}{});
  if (!$nonprinted_or_unicode_count) 
    { return ($only_return_length ? length($input) : $input) };

  $tab_stops //= $default_tab_stops;
  if (!is_array_ref $tab_stops) { $tab_stops = [ $tab_stops ]; }
  $replace_with //= ' ';
  $pos //= 0;

  my $n = scalar @$tab_stops;

  my $stopped_at_pos = 0;
  my $tab_stop_index = 0;

  my $last = $tab_stops->[$n-1] // 0;
  my $next_to_last = (($n >= 2) ? $tab_stops->[$n-2] : 0);
  $stride //= ($last - $next_to_last);

  if (!$stride) {
    warning('expand_tabs: stride between last two tab stops is zero; '.
            'forcing to default of 8 to avoid infinite loop');
    $stride = 8;
  }

  my $out = '';

  while ($input =~ /$text_or_tab_or_nl_re/oamsxg) {
    my $chunk = $1;
    if ($chunk eq TAB) {
      # First scan forward to the largest tab stop no larger than $pos:
      while ($stopped_at_pos <= $pos) {
        $stopped_at_pos = ($tab_stop_index < $n) 
          ? $tab_stops->[$tab_stop_index]
          : $last + (($tab_stop_index - ($n-1)) * $stride);
        $tab_stop_index++;
      }

      my $spaces = ($stopped_at_pos - $pos);
      $out .= ($replace_with x $spaces) if (!$only_return_length);
      $pos = $stopped_at_pos;
    } elsif ($chunk eq NL) {
      # Reset to the start of the line:
      $pos = 0;
      $stopped_at_pos = 0;
      $tab_stop_index = 0;
    } else {
      # Append a regular string chunk. The tab stop position will be 
      # adjusted and padding added after the next a tab character.
      my $printed_char_count = length($chunk);

      my $nonprinted_or_unicode_count = ($chunk =~ tr{\x00-\x1f\x80-\xff}{});

      if ($nonprinted_or_unicode_count > 0) {
        my $stripped = $chunk
          =~ s{$utf8_re}{?}roamsxg
          =~ s{$ansi_console_escapes_and_nonprinted_characters_re}{}roamsxg;
        $printed_char_count = length($stripped);
      }

      $out .= $chunk if (!$only_return_length);
      $pos += $printed_char_count;
    }
  }

  return ($only_return_length ? $pos : $out);
}

sub printed_length_with_expanded_tabs($;+$$) {
  my ($input, $tab_stops, $replace_with, $pos) = @_;
  return expand_tabs($input, $tab_stops, $replace_with, $pos, 1);
}

#
# printed_length($string1, $string2, ...):
#
# This function finds the true length of a string in printable characters:, even with 
# strings containing embedded console escape codes (e.g. for colors and attributes), 
# since it doesn't count those escapes when it calculates the true length of the string
# (unlike perl's length() function). It also expands each tab (\t) into 8 spaces.
#
# If multiple strings are specified as a list, printed_length() returns the length
# of the longest string in the list (*not* the sum of the lengths).
#

my %printed_length_cache = ( );

sub printed_length {
  my $maxlength = 0;
  foreach my $s (@_) {
    next if (!defined $s);
    set_max($maxlength, printed_length_with_expanded_tabs($s));
  }
  return $maxlength;
}

sub truncate_printed_string($$) {
  my ($s, $limit) = @_;

  return '' if ((!defined($_[0])) || ((length $_[0]) == 0) || ($_[1] == 0));
  # fast path: avoid the following unless string has control chars:
  if ($_[0] !~ tr/\x00-\x1F//s) { return substr($_[0], 0, $_[1]); }

  if ($s =~ tr/\t//s) { $s = expand_tabs($s); }

  #
  # The upper bound on the length is the raw number of bytes,
  # since removing ANSI escapes and counting multi-byte UTF-8
  # characters as a single character can only make the printed
  # length smaller, never larger.
  #
  set_min($limit, length($s));
  pos($s) = 0;
  my $n = 0;

  while ($n < $limit) {
    if ($s =~ /$ansi_console_escapes_and_nonprinted_characters_re/oamsxg) {
      ; # no action needed - just skip over these char(s), since they aren't printable
    } elsif ($s =~ /$printable_chars_re/oamsxg) {
      my $span_length = ($+[0] - $-[0]);
      my $over_length = ($n + $span_length) - $limit;
      if ($over_length > 0) { 
        $span_length -= $over_length;
        pos($s) = pos($s) - $over_length;
        $n = $limit;
        last;
      }
      $n += $span_length;
    }
  }

  return substr($s, 0, pos($s));
}

sub truncate_printed_strings {
  my $limit = shift;
  foreach my $s (@_) {
    $s = truncate_printed_string($s, $limit);
  }

  return (wantarray ? @_ : \@_);
}

sub recursively_process_strings {
  my ($obj, $callback, @extra_args) = @_;

  my $type = typeof($obj);
  if ($type == STRING) {
    $_[0] = $callback->($obj, @extra_args);
  } elsif ($type == STRING_REF) {
    ${$obj} = $callback->(${$obj}, @extra_args);
  } elsif (($type == ARRAY_REF) || ($type == HASH_REF)) {
    foreach my $elem (($type == HASH_REF) ? %$obj : @$obj) {
      if (is_string($elem)) {
        $elem = $callback->($elem, @extra_args);
      } elsif (is_scalar($elem)) {
        next; # no need to recurse into it
      } else { # must be nested array ref or hash ref (or anything else we just ignore)
        recursively_process_strings($elem, $callback, @extra_args);
      }
    }
  }
}

sub replace_unicode_chars(+) {
  my ($arg) = @_;
  
  my $type = typeof($arg);
#  if ($type == ARRAY_REF) {
#    return map { ppreplace_unicode_chars
#++MTY TODO
}

use constant {
  ALIGN_LEFT => -1,
  ALIGN_CENTER => 0,
  ALIGN_RIGHT => +1,
  ALIGN_JUSTIFIED => -1
};

#
# padstring($string, $alignment, $desired_length_in_chars, 
#   $optional_padding_string_to_repeat, $fill_right_when_centered, $suffix):
#
# Pad a string to the desired length in characters by repeating the padding string (or
# a single space (" ") if no padding is specified) until the combined length of the string
# plus the padding is at least the desired length (it may be longer than this if the string's
# length already exceeds the desired length, in which case no padding will be used).
#
# This function works correctly even with strings containing embedded console escape
# codes  (e.g. for colors and attributes); see printed_length() for details on this. Only the
# string may contain escape codes; the pad must only contain spaces or printable characters.
#
# In cases where the string would normally contain such escape codes (and optionally more text
# after them), padstring() will be more efficient if the escape codes and any subsequent text
# (which should be the same length if padstring() is being used to align columns) are removed
# from $string and instead placed in the $suffix argument (whose length is *not* counted when
# determining how much padding to insert). This optimization allows the normal lengthof() to
# be used on $string without the overhead of having to first remove its control codes.
#
# (For convenience the padstring_with_suffix() function is equivalent to this but without
# having top pass undef for the intervening arguments before $suffix).
#
sub padstring($$;$$$$) {
  my ($width, $align, $pad, $fill_right_when_centered, $suffix) = @_[1..5];
  my $rs = undef;

  if (!defined $_[0]) { return '<undef>'; }

  $align //= -1;
  $pad //= ' ';
  $fill_right_when_centered //= 0;

  # Negative width means align to the right:
  if ($width < 0) { $width = -$width; $align = +1; }
  my $len = printed_length($_[0]);
  if (length($pad) > 1) { $pad = substr($pad, 0, 1); }

  if ($len > $width) {
    $rs = substr($_[0], 0, $width);
    $len = min(printed_length($rs), $width);
  }

  my $n = $width - $len;
  my $leftpad; my $rightpad;

  if ($align == 0) { 
    # (0 = centered):
    my $n2 = int($n / 2);
    my $leftover = $width - ($n2 + $len + $n2);
    $leftpad = $n2;
    $rightpad = ($fill_right_when_centered ? ($n2 + $leftover) : 0);
  } elsif ($align < 0) {
    # (-1 = left):
    $leftpad = 0;
    $rightpad = $n;
  } elsif ($align > 0) {
    $leftpad = $n;
    $rightpad = 0;
  }

  return (($pad x $leftpad) . ($rs // $_[0]) . ($suffix // '') . ($pad x $rightpad));
}

sub padstring_with_suffix($$$;$) {
  my ($string, $suffix, $width, $alignment) = @_;
  return padstring($string, $width, $alignment, undef, undef, $suffix);
}

sub padstrings(+$;$$) {
  my $array = shift;
  foreach my $s (@$array) {
    $s = padstring($s, @_);
  }
  return $array;
}

sub hexstring($;$;$) {
  my ($value, $width, $pad) = @_;
  my $format = '0x%'.((($width // 0) < 0) ? '-' : '').
    ($pad // '').((defined $width) ? abs($width) : '').'llx';

  return sprintf($format, $value);
}

#
# join_with_prefix_and_suffix($prefix, $suffix, $sep, @list): 
# wrap a $prefix and $suffix around each item in the list of arguments, 
# then return a string of these wrapped items separated by $sep. (This
# is essentially an enhanced version of perl's join() function):
#

sub add_prefix_and_suffix {
  my ($prefix, $suffix, $listref) = @_;

  if (!is_array_ref($listref)) { $listref = \@_[2..scalar(@_)-1]; }
  my @out = map { $prefix.$_.$suffix; } @$listref;
  return (wantarray ? @out : \@out);
}

sub add_prefix_and_suffix_in_place {
  my ($prefix, $suffix, $listref) = @_;

  if (!is_array_ref($listref)) { $listref = \@_[2..scalar(@_)-1]; }
  foreach my $elem (@$listref) { $elem = $prefix.$elem.$suffix; }
  return (wantarray ? @$listref : $listref);
}

sub join_around($$$@) {
  my ($left, $sep, $right, @list) = @_;
  return $left.join($right.$sep.$left, @list).$right;
}

sub join_with_prefix_and_suffix {
  my ($prefix, $suffix, $separator, $listref) = @_;

  if (!is_array_ref($listref)) { $listref = \@_[3..scalar(@_)-1]; }
  if (!@$listref) { return $always_fail_re; }
  return $prefix.join($suffix.$separator.$prefix, @$listref).$suffix;
}

#
# Alternative regexps for removing leading and trailing whitespace:
#
#   m/\A \s* (.*?) \s* \Z/oamsxg      or:      s/^\s+ | \s+$/oamsxg
#   (sets $1)                                  (replaces original)
#
#                                     or:      s/^\s+//oamsx;
#                                              s/\s+$/oamsx/;
#                                              (even more efficient)
#

my $leading_spaces_re = qr{^\s*+}oamsx;
my $trailing_spaces_re = qr{\s*+$}oamsx;

sub remove_with_regexp_and_return_removed_char_count {
  return undef if (!defined($_[0]));
  my $re = $_[1] // $trailing_spaces_re;
  my $n = length($_[0]);
  $_[0] =~ s{$re}{}oamsxg;
  return ($n - length($_[0]));
}

sub count_and_remove_leading_spaces {
  return remove_with_regexp_and_return_removed_char_count($_[0], $leading_spaces_re);
}

sub count_and_remove_trailing_spaces {
  return remove_with_regexp_and_return_removed_char_count($_[0], $trailing_spaces_re);
}

sub remove_leading_space {
  return undef if (!defined($_[0]));
  return ($_[0] =~ s/$leading_spaces_re//roamsxg);
}

sub remove_trailing_space {
  return undef if (!defined($_[0]));
  return ($_[0] =~ s{$trailing_spaces_re}{}roamsxg);
}

sub remove_leading_trailing_space($) {
  return undef if (!defined($_[0]));
  return ($_[0] 
          =~ s/$leading_spaces_re//roag
          =~ s/$trailing_spaces_re//roag);
}

sub remove_leading_trailing_space_and_undef_if_empty($) {
  return undef if (!defined($_[0]));
  my $s = ($_[0] 
           =~ s/$leading_spaces_re//roag
           =~ s/$trailing_spaces_re//roag);
  return (length($s) > 0) ? $s : undef;
}

sub sep_if_not_first($;$) {
  my $sep = $_[1] // ' ';
  return ((defined $_[0]) && ((length $_[0]) > 0)) ? $sep : '';
}

my $spaces_or_tabs_or_newline_re = qr{(\n | [\ \t]++)}oamsx;

my $split_into_words_and_line_breaks_re = 
  qr{[\ \t]*+ (\S++ | \n)}oamsx;

sub split_into_words_and_line_breaks(+) {
  my ($s) = @_;
  my @a = ( );
  while ($s =~ /$split_into_words_and_line_breaks_re/oamsxg) 
    { push @a, (($1 eq NL) ? undef : $1); }
  return (wantarray ? @a : \@a);
}

sub wrap_long_lines(+;$$$$$$) {
  my ($list_or_string, $maxlength, $sep, $first_line_prefix, $subsequent_line_prefix, $suffix, $initial) = @_;

  $maxlength //= 78;
  $sep //= ' ';
  $subsequent_line_prefix //= ($first_line_prefix // '  ');
  $first_line_prefix //= '';
  $suffix //= '';
  $initial //= '';

  my $list = is_array_ref($list_or_string) ? $list_or_string : 
    split_into_words_and_line_breaks($list_or_string);

  my $sep_length = length($sep);
  my $first_line_prefix_length = printed_length($first_line_prefix);
  my $subsequent_line_prefix_length = printed_length($subsequent_line_prefix);

  my $accum_line = $first_line_prefix;
  my $char_count_so_far = printed_length($initial) + $first_line_prefix_length;
  my $word_in_line = 0;
  my @out = ( );

  foreach my $word (@$list) {
    my $force_nl = 0;
    if (!defined $word) { $force_nl = 1; $word = ''; }
    my $n = printed_length($word);
    my $sepn = (($word_in_line > 0) ? $sep_length : 0);

    if ((($char_count_so_far + $sepn + $n) > $maxlength) || $force_nl) {
      $accum_line .= $suffix;
      push @out, $accum_line;
      $accum_line = $subsequent_line_prefix;
      $sepn = 0; # no word separator at start of new line
      $char_count_so_far = $subsequent_line_prefix_length;
      $word_in_line = 0;
    }

    $accum_line .= (($word_in_line > 0) ? $sep : '') . $word;
    $char_count_so_far += $sepn + $n;
    $word_in_line++;
  }

  if (length $accum_line) {
    $accum_line .= $suffix;
    push @out, $accum_line; 
  }

  return (wantarray ? @out : join(NL, @out));
}

sub word_wrap_long_lines($;$$$$) {
  my ($s, $maxlength, $first_line_prefix, $subsequent_line_prefix, $suffix, $initial) = @_;

  return wrap_long_lines($s, $maxlength, ' ', $first_line_prefix, $subsequent_line_prefix, $suffix, $initial);
}

sub delimited_strings_to_subarrays(+;$) {
  my ($rows, $delim) = @_;

  return [ map { [ split($delim, $_) ] } @$rows ];
}

my $placeholder_re = qr{(?! \\) % ((?| ([^\{]) | \{ ([^\}]++) \}))}oamsx;

sub substitute_placeholders($+) {
  my ($format, $placeholder_to_var_ref) = @_;

  return ($format =~ s{$placeholder_re}{
    my $valueref = $placeholder_to_var_ref->{$2};
    my $value = (is_code_ref $valueref) ? $valueref->($2, $1) : 
      (is_ref $valueref) ? $$valueref : $valueref;
    $value;
  }roamsxge);
}

sub parse_list_of_key_equals_value_into_hash($;+$) {
  my ($s, $hash, $default_value) = @_;
  $hash //= { };
  $default_value //= undef;

  while ($s =~ /$key_equals_or_colon_value_comma_re/oamsxg) {
    my ($key, $value) = ($1, $2);
    $hash->{$key} = $value // $default_value;
  }

  return $hash;
}

my $groups_of_3_digits_re = qr{\d\d\d \K (?= \d)}oax;

sub insert_thousands_separators($;$) {
  my ($s, $sep) = @_;
  $sep //= ',';

  my $n = length($s);
  if ($n <= 3) { return $s; }

  my $mod = $n % 3;
  return 
    substr($s, 0, $mod).
    (($mod > 0) ? $sep : '').
      (substr($s, $mod) =~ s{$groups_of_3_digits_re}{$sep}roaxg);
}

sub decimal_digit_count($) {
  my ($n) = @_;
  my $d = 0;

  while ($n >= 1000000) { $n /= 1000000; $d += 6; }

  $d += (
    ($n >= 1000) ? (
      ($n >= 100000) ? 6 :   # 100000 - 999999
      ($n >= 10000) ? 5 :    #  10000 -  99999
      4                      #   1000 -   9999
    ) : (
      ($n >= 100) ? 3 :      #    100 -    999
      ($n >= 10) ? 2 :       #     10 -     99
      1                      #      0 -      9
    ));
  
  return $d;
}

sub hex_digit_count($) {
  my ($v) = @_;

  return 1 if (!$v); # one digit ("0") required for no bits being set

  # This is trivial compared to counting decimal digits...
  my $bits = highest_set_bit_index($v) + 1;
  my $nibbles = ($bits + 3) >> 2;

  return $nibbles;
}

sub length_with_thousands_separators($) {
  my ($s) = @_;
  $s = "$s";

  my $n = decimal_digit_count($s);
  return $n + (($n <= 3) ? 0 : (($n - 1) / 3));
}

our @powers_of_1024_unit_names = (' ', 'K', 'M', 'G', 'T', 'P', 'E');

sub format_size_with_units($;$$$$$) {
  my ($size, $max_decimal_digits, $separator, $units_prefix, $units_suffix, $custom_powers_of_1024_unit_names) = @_;
  $max_decimal_digits //= 7;
  $separator //= ',';
  $units_prefix //= ' ';
  $units_suffix //= 'b';
  $custom_powers_of_1024_unit_names //= \@powers_of_1024_unit_names;

  my $powers_of_1024 = 0;
  my $n = $size;

  while (length("$n") > $max_decimal_digits) {
    $n = ($n + 512) >> 10; 
    $powers_of_1024++;
  }

  my $sizestr = (is_there($separator)) ? insert_thousands_separators($n, $separator) : "$n";

  if ($powers_of_1024 > 0) {
    $sizestr .= $units_prefix.
      ($powers_of_1024_unit_names[$powers_of_1024] // '?').$units_suffix;
  }

  return $sizestr;
}

1;
