#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Common::CommandLine
#
# Command Line Parsing
#
# Copyright 1997 - 2014 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Common::CommandLine;

use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Filesystem::Files;
use MTY::Common::Strings;
use MTY::Display::Colorize;
use MTY::Display::ColorizeErrorsAndWarnings;
use MTY::Display::PrintableSymbols;
use MTY::Display::PrintableSymbolTools;
use MTY::Display::TextInABox;
use MTY::Display::Scrollable;
use MTY::RegExp::Define;
use MTY::RegExp::Tools;
use MTY::RegExp::Blocks;
use MTY::RegExp::Numeric;
use MTY::RegExp::FilesAndPaths;
use MTY::RegExp::Strings;

use integer; use warnings; use Exporter::Lite;
#pragma end_of_includes

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($command_line_option_re $key_value_option_re INVALID_OPTION
     NO_VAR_FOR_OPTION OPTION_ACTION_BASE OPTION_ACTION_COUNT
     OPTION_ACTION_MASK OPTION_APPEND_REPEATS OPTION_ASSIGN_BOOL OPTION_BOOL
     OPTION_COMMA_SEP_LISTS OPTION_DATA_TYPE_AUTO OPTION_DATA_TYPE_BASE
     OPTION_DATA_TYPE_COUNT OPTION_DATA_TYPE_MASK OPTION_FILE
     OPTION_FILE_WRITABLE OPTION_FLAGS_BASE OPTION_FLAGS_COUNT
     OPTION_FLAGS_MASK OPTION_FLOAT OPTION_HASH_MANIPULATION OPTION_INTEGER
     OPTION_MATCH_NAME_PREFIX OPTION_MATCH_NAME_SUBSTR
     OPTION_NO_SEPARATOR_BEFORE_VALUE OPTION_SINGLE_CHAR_COMBINABLE
     OPTION_SPEC_SLOT_ACTION_AND_FLAGS OPTION_SPEC_SLOT_ALIASES
     OPTION_SPEC_SLOT_DEF_VALUE_ON_RESET OPTION_SPEC_SLOT_DEF_VALUE_TO_SET
     OPTION_SPEC_SLOT_VARIABLE_REFERENCE OPTION_STRING OPTION_TOGGLE_BOOL
     OPTION_TOGGLE_BOOL_ON_EVERY_REPEAT OPTION_VALUE_OPTIONAL
     OPTION_VALUE_REQUIRED SINGLE_CHAR_OPTION_COMBINABLE
     SINGLE_CHAR_OPTION_DEFAULT SINGLE_CHAR_OPTION_NO_VALUE_SEP
     parse_and_check_command_line parse_command_line preprocess_option_specs
     preprocess_option_specs_if_needed print_command_line_options_help
     print_current_option_settings print_invalid_options);

# 
#  Option Specification Array
#
#                    Option Specification Array:
#                    ---------------------------
#
# The properties of each valid option are specified by an array comprising the
# slots described below. The parse_command_line() function must be passed a
# hash which maps each option name (without the leading '-', as in '-option1')
# to a reference to its associated spec array. (Note that parse_command_line()
# may add its own internal entries to this hash to speed up subsequent parsings;
# the keys of these entries may include the names of any options or aliases).
#
# my %command_line_options = {
#   '-optionname' => [
#      <slot 0>         \$ref_to_scalar_or_array_or_hash_to_receive_option_value,
#      <slot 1>         OPTION_xxx (action) | (optional) OPTION_fff flags,
#      <slot 2>         (optional) alias name or ref to list of alias names
#      <slot 3>         (optional for some actions) default value to set,
#      <slot 4>         (optional) default value to set if option is negated
#                     ], ...
#
# Except for the refernece to the variable, all of the fields above are optional;
# if they are omitted, default values (described below) are automatically used.
#
# Alternatively, for the most common case of a simple boolean scalar option,
# the option spec array may be omitted entirely, and the value in the hash
# may instead be a direct reference to the variable to set or clear if that
# option (i.e. the hash key with a '-' prefix) appears on the command line.
#
#                             Actions:
#                             --------
#
# The following constants should be placed in the low 8 bits of slot [1]
# of the option specification array, along with various optional flags
# in the higher bits if desired. The subsequent slots [2] and [3] are
# used by some types of actions as well.
#
# OPTION_ASSIGN_BOOL:
#
#   Sets the referenced scalar to the value in slot [2] of the spec, or if
#   slot [2] is omitted, uses an integer value of 1 by default. 
#
#   If the option as provided on the command line is of the form "-no-<option>',
#   the "reset" value in slot [3] will be written to the variable instead (if
#   slot [3] is also omitted, the default reset value will be 0 and the default
#   set value will be 1.
#
#   If slot [1] (the actions and flags slot) is also omitted, or if a simple
#   reference to a scalar is given as the option's spec instead of providing
#   any spec array at all, the default action will be OPTION_ASSIGN_BOOL
#   with a set constant of "1" and a reset constant of "0".
#
# OPTION_TOGGLE_BOOL:
#
#   Interpret the referenced scalar as a boolean value, which is then logically
#   inverted and written back to the scalar. 
#
#   The three values (0 | '' | undef) are all considered a boolean "0" (i.e. 
#   the same semantics as Perl itself), and thus write the value 1 into the
#   that scalar variable. 
#
#   On the other hand, any properly defined non-zero integers, non-empty strings
#   or references to any other sort of object are interpreted as a boolean "1", 
#   so this option will clear the scalar back to 0 (unless the previous value was
#   a reference to some other object; in this case the scalar is set to undef).
#
#   If an inverting option is specified multiple times on the same command line, 
#   by default all subsequent repeats are ignored, since processing the later
#   inversions would be very confusing to the user; hence only the pre-initialted
#   default value in the variable is inverted once and only once. If you want the
#   value to invert every time the option appears on the command line, set the
#   OPTION_TOGGLE_BOOL_ON_EVERY_REPEAT bit in slot [1] (see below).
#
# OPTION_VALUE_REQUIRED:
#
#   The option requires an explicit value (<value>) to be specified on the command 
#   line in one of the following three ways:
#
#   - within the same argument as the option, by following it with an equals sign
#     ("=") and then the value (with no intervening spaces), e.g. "-option=<value>"
#
#   - within the same argument without any equals sign or other spearator after the
#     option name, only if the OPTION_NO_SEP_BEFORE_VALUE bit is set in slot [1]
#     (see below for details).
#
#   - as the next argument following the option, which can be given as just "-optname" 
#     without any equals sign or other indication that a value must follow it.
#
#   If the "-option=<value>" form is not used, and the option itself is either followed
#   by another option (starting with -...) as the next argument, or the option itself
#   is the final argument on the command line, an error will be returned to the caller.
#
# OPTION_VALUE_OPTIONAL:
#
#   Some types of options remain both useful and conceptually intuitive even if no value
#   is provided, yet a value can still be provided to override the default value. For
#   example, a hypothetical option called "-list" might be used to print an item specified
#   by the option's value, yet if "-list" is specified without a value, most programs would
#   simply list all known items, rather than returning an error.
#
#   To enable these semantics, the OPTION_VALUE_OPTIONAL action can be specified. If an
#   option specifying this action appears on the command line without any associated value, 
#   the default value in the option's spec array slot [3] is written into the referenced 
#   variable to inform the program that the user is invoking that option's more general
#   default behavior in the absence of a specific value.
#
#   If slot [3] is omitted, the default integer value 1 is written to the referenced variable.
#   (This value of 1 is preferable to using undef as a default value, since undef is normally
#   the initial state of these sorts of variables when they have never been modified by any
#   command line options at all.)
#
#                                 Special Bit Flags:
#                                 ------------------
#
# Along with the aforementioned actions, each variable's option spec can also set 
# several bit flags in the spec array's slot [1] to fine tune the handling of that
# option (some of the applicable bit flags depend on which action is selected).
#
# OPTION_APPEND_REPEATS:
#
#   IF a given option with the OPTION_VALUE_REQUIRED action is specified multiple times on the
#   command line, each subsequent repetition overwrites the referenced variable with the
#   value provided by the last instance of that option on the command line.
#
#   However, these semantics may be undesirable in situations where a given variable holds an
#   ordered list of multiple values specified on the command line. The OPTION_APPEND_REPEATS
#   bit flag facilitates this usage by concatenating all the values specified by all repeats
#   of the associated option; the referenced variable's value is then set to this combined 
#   value (in the form of an array or a string).
#
#   If the variable reference (specified by option spec slot [0]) points to an array, this 
#   array is simply set to the list of values provided for that option on the command line
#   in the order they originally appeared. (If the relevant option never appears even once,
#   the variable will never be overwritten; typically it would remain an empty array).
#
#   If the referenced variable is a scalar, it is assumed to be a text string, and is set to
#   the result of joining all provided values with spaces between them (if this is undesirable,
#   an array should be used instead, since this avoids any ambiguity over separator characters).
#
# OPTION_COMMA_SEP_LISTS:
#
#   If the OPTION_COMMA_SEP_LISTS bit flag is set in option spec slot [1], and the referenced
#   variable is an array or a hash (this flag has no effect on scalars, booleans or other types),
#   and an option with this flag appears on the command line with a value containing ',' or ':',
#   these characters are treated as separators between discrete list elements, and each element
#   is appended to the referenced variable (even if the OPTION_APPEND_REPEATS flag is not set).
#
#   However, unless OPTION_APPEND_REPEATS is also set, a subsequent use of the same option which
#   specifies either a single item or another list of items will cause that later option's list
#   of values to replace any existing list already in the referenced variable. By setting both
#   the OPTION_APPEND_REPEATS and OPTION_COMMA_SEP_LISTS flags for the option, the user is free
#   to mix and match list construction techniques, as shown in the example below:
#
#      programname -option1 ... -listopt a -listopt b,c,d -listopt -e -listopt f
#      programname -option1 ... -listopt a,b,c,d,e,f
#
#   Both of these command lines will result in the variable associated with the option "listopt"
#   containing the array [a, b, c, d, e, f] after the command line has been parsed. These semantics
#   are highly preferable in cases where some command line options may be defined in an environment
#   variable (as in how compiler flags are typically specified by Makefiles), whille others may
#   be specified later on. In these scenarios, it is physically impossible to construct a single
#   comma delimited list of all intended items, so letting the command line parser concatenate
#   several shorter lists of items is the best strategy here.
#
# OPTION_HASH_MANIPULATION:
#
#   If OPTION_HASH_MANIPULATION is set in slot [1] of the option spec array, 
#   for each entry in the list for -option=x,y,...,
#
#   - if the entry is '+x' or just 'x', add a new key 'x' => value 1
#   - if the entry is '-x' or '!x', remove the key 'x' from the hash
#   - if the entry is 'x=y', add a new key 'x' => value 'y'
#
#   If OPTION_HASH_MANIPULATION is not present in the option spec list,
#   the entire value of the option is added to the hash as both the
#   key and the value.
#
# OPTION_NO_SEPARATOR_BEFORE_VALUE:
#
#    If the OPTION_NO_SEPARATOR_BEFORE_VALUE bit flag is set, the affected option will expect to
#    find its value directly after the last character in the option name, without an "=" separating
#    the option name from the value. This can be desirable for both shorthand convenience as well
#    as compatibility with other tools like many compilers (which traditionally use "-Iincludedir"
#    instead of the much less intuitive "-I=includedir" to specify header file directories). 
#
#    Note that this flag will malfunction if it creates any ambiguity, e.g. where "-OptionArgument"
#    (for an option called "-Option" but not requiring the "=" separator) could be misinterpreted as
#    another option genuinely called "-OptionArgument". 
#
#    In these cases, the user should either be instructed to avoid the ambiguity themselves by using 
#    the "-Option=Argument" or "-Option Argument" alternative forms (which are still perfectly valid 
#    even when the OPTION_NO_SEPARATOR_BEFORE_VALUE bit is set) if there is any chance of confusion,
#    or by simply avoiding ambiguity altogether, for instance by refraining from having any other
#    options which begin with the prefix '-Ixxx" if an option named '-I' (with no '=' separator)
#    has also been defined.
#
# OPTION_TOGGLE_BOOL_ON_EVERY_REPEAT:
#
#   When applied to a boolean option, this flag causes the referenced variable to be inverted
#   every time the option is repeatedly listed on the command line (even though this behavior
#   is discouraged since it invariably confuses users compared to the default of only honoring
#   the first inversion, as explained above). This bit is ignored for non-boolean variables.
#

use constant {
  OPTION_SPEC_SLOT_VARIABLE_REFERENCE => 0,
  OPTION_SPEC_SLOT_ACTION_AND_FLAGS   => 1,
  OPTION_SPEC_SLOT_ALIASES            => 2,
  OPTION_SPEC_SLOT_DEF_VALUE_TO_SET   => 3,
  OPTION_SPEC_SLOT_DEF_VALUE_ON_RESET => 4,
};

# Constants that can be ORed into spec slot 1 (see above for descriptions):

use constant {
  OPTION_ACTION_BASE    => 0,
  OPTION_ACTION_COUNT   => 4,
  OPTION_ACTION_MASK    => 0xff,

  OPTION_DATA_TYPE_BASE => 24,
  OPTION_DATA_TYPE_COUNT => 6,
  OPTION_DATA_TYPE_MASK => 0xf000,

  OPTION_FLAGS_BASE       => 16,
  OPTION_FLAGS_COUNT      => 8,
  OPTION_FLAGS_MASK       => 0x00ffff00,
};

use constant {
  # Actions (in low 8 bits of spec slot 1):
  OPTION_ASSIGN_BOOL     => 0,
  OPTION_TOGGLE_BOOL     => 1,
  OPTION_VALUE_REQUIRED  => 2,
  OPTION_VALUE_OPTIONAL  => 3,
    
  # Allow the value to be in one or more of these data types (may be ORed together)
  # Types (in bits 15:8 of spec slot 1):
  OPTION_DATA_TYPE_AUTO  => 0, # (the implied default of either bool or string dpeending on whether a value is expected or required)
  OPTION_STRING          => 1 << (OPTION_DATA_TYPE_BASE + 0),
  OPTION_BOOL            => 1 << (OPTION_DATA_TYPE_BASE + 1),
  OPTION_INTEGER         => 1 << (OPTION_DATA_TYPE_BASE + 2), # in decimal (+/- 123), hex (0xabc123..), octal (076543210) or binary (0b101101101...)
  OPTION_FLOAT           => 1 << (OPTION_DATA_TYPE_BASE + 3), # e.g. 1.234, -4.5678, 123.456e10-23, etc.
  OPTION_FILE            => 1 << (OPTION_DATA_TYPE_BASE + 4), # must be a valid filename (will check if it exists and is readable)
  OPTION_FILE_WRITABLE   => 1 << (OPTION_DATA_TYPE_BASE + 5), # must be a valid filename (will check if it exists and is writable, and/or its parent dir exists and it can be created)

  # Flags (in bits 15:8 of spec slot 1):
  OPTION_APPEND_REPEATS    => (1 << 8),
  OPTION_COMMA_SEP_LISTS   => (1 << 9),
  OPTION_HASH_MANIPULATION => (1 << 10),
  OPTION_NO_SEPARATOR_BEFORE_VALUE => (1 << 11),
  OPTION_TOGGLE_BOOL_ON_EVERY_REPEAT => (1 << 12),
  OPTION_SINGLE_CHAR_COMBINABLE => (1 << 13),
  OPTION_MATCH_NAME_PREFIX => (1 << 14),
  OPTION_MATCH_NAME_SUBSTR => (1 << 15)
};

our $command_line_option_re = compile_regexp(
  qr{^ - -? (?: (no | disable | enable | not) -)?
      ([^\=\:]*) 
      (?: [\=\:] (.*))? 
      $}oax,
  'Command line option X in one of the forms "-X", "--X", "-<modifier>-X", "-X=<V>", '.
  'or "-X:<V>", where V is a value string, and the optional <modifier> may be '.
  '"no", "disable", "enable" or "not", which imply a V of 0, 0, 1 or the logical '.
  'negation of a user-defined default value, respectively.');

our $key_value_option_re = 
  qr{\G ([^\=\:]++) 
     (?> 
       [\=\:] 
       ((?: \\ . | [^,])*+)
     )? 
     (?> , | \Z)}oax;

#
# The $invalid_option_indicator variable and the INVALID_OPTION constant sub
# (which merely returns a const refernece to $invalid_option_indicator) exist 
# solely to let option handler callbacks return a reference to this uniquely 
# defined object to signal that the provided value was invalid. If the callback 
# returns anything else, we assume the option's value was valid.
#
# This lets callers avoid having to explicitly end each and every callback with 
# an explicit return statement (unless the option's value was bogus, of course).
#
# Callbacks should execute "return INVALID_OPTION;" if they decide the provided
# value was invalid; this will mark the option as invalid and force it to be
# listed in the resultant error message.
#

my $invalid_option_indicator = '<invalid>';

sub INVALID_OPTION { return \$invalid_option_indicator; }

#
# The $no_var_for_option_indicator and NO_VAR_FOR_OPTION constant sub
# (which merely returns a const refernece to $no_var_for_option_indicator) are
# used to indicate that a given option name is valid despite not being associated
# with any particular variable - its value will only be accessible through the
# $option_names_to_values hash returned by parse_command_line(). 
#
# Note that this facility can only be used for scalars, since we can't query the
# type of a referenced variable when that "variable" solely exists in a hash
# (because all values in perl hashes are scalars, i.e. strings, numbers or refs).
#
# Callers can use this facility by specifying "NO_VAR_FOR_OPTION" in place of
# the usual reference to a variable. Here's an example:
#
# my $var1;
# my %options = (
#   ...
#   'opt1' => NO_VAR_FOR_OPTION,  # 'opt1' only stored in returned hash
#   'opt2' => \$var1,             # 'opt2' stored in both $var1 and the hash
#   ...);
#

my $no_var_for_option_indicator = '<novariable>';

sub NO_VAR_FOR_OPTION { return \$no_var_for_option_indicator; }

my %option_name_modifier_to_implied_value = (
  'no' => 0,
  'disable' => 0,
  'disabled' => 0,
  'without' => 0,
  'skip' => 0,
  'exclude' => 0,

  'enable' => 1,
  'enabled' => 1,
  'yes' => 1,
  'do' => 1,
  'use' => 1,
  'with' => 1,

  'not' => -1
);

#
# We add a reference to this string to the hash of options to indicate
# we've already expanded any alises and otherwise preprocessed the specs:
#
my $already_preprocesed_option_specs_indicator = '.<preprocessed-options>';

#
# If it's a literal string instead of a reference to the variable to set,
# it means this is an alias from the key ($name) to the real option
# name in $v, so we'll re-check the hash for the option named $v. This
# can be repeated several times if one alias chains to another alias
# before finally terminating in a reference to a variable or an array
# of option attributes (which will include the variable reference).
# (You are responsible for avoiding infinite loops if you chain aliases).
#

#
# Values in the @single_char_option_hints[] array 
# (where undef or 0 indicates neither of these are applicable;
# a given option may either have one or the other (not both),
# or simply have neither of these properties:
#
use constant {
  SINGLE_CHAR_OPTION_DEFAULT       => 1,
  SINGLE_CHAR_OPTION_COMBINABLE    => 2,
  SINGLE_CHAR_OPTION_NO_VALUE_SEP  => 3,
};

sub preprocess_option_specs(+) {
  my ($origspecs) = @_;

  my %expanded_specs = ( );
  
  my $aliases = { };

  while (my ($name, $specs) = each %$origspecs) {
    if ($name =~ /^-/oax) 
      { die('Option "'.$name.'" should not include a leading dash ("-")'); }
   
    if ($name =~ /^\.(.+)$/oax) {
      # Flags or other parameters for parse_options (not a real user visible option):
      $expanded_specs{$name} = $specs;
      next;
    }

    if (!defined $specs) {
      # expand form without explicit variable: 'name' => undef,
      # where option's value is placed only in the returned hash
      $specs = [ NO_VAR_FOR_OPTION ];
    } elsif (is_scalar_ref($specs)) {
      # expand short form: 'name' => \$scalar_var_name
      $specs = [ $specs ];
    } elsif (!is_array_ref($specs)) {
      die("Option '$name' must be either a ref to a scalar variable ".
            "or a ref to an option specification array");
    }

    my ($varref, $action_and_flags, $alias_list, $default_value_to_set, $default_value_to_reset);

    # $specs is now in array form, but may not have all fields filled in
    if ((defined $specs->[1]) && (!is_numeric($specs->[1]))) {
      # abbreviated format that skips the flags and instead
      # uses that slot for the alias string or list of strings:
      ($varref, $alias_list, $default_value_to_set, $default_value_to_reset) = @$specs;
    } else {
      ($varref, $action_and_flags, $alias_list, $default_value_to_set, $default_value_to_reset) = @$specs;
    }

    my $vartype = typeof $varref;
    $action_and_flags //= (OPTION_ASSIGN_BOOL | OPTION_COMMA_SEP_LISTS);
    my $action = $action_and_flags & OPTION_ACTION_MASK;
    my $flags = $action_and_flags & ~OPTION_ACTION_MASK;
    $alias_list //= [ ];
    $alias_list = (defined $alias_list) ? (is_string($alias_list) ? [ $alias_list ] : $alias_list) : [ ];
    
    if ($vartype == SCALAR_REF) {
      if (($flags & OPTION_APPEND_REPEATS) &&
            (($action == OPTION_ASSIGN_BOOL) || 
             ($action == OPTION_TOGGLE_BOOL))) { 
        die("Option '$name': ASSIGN_BOOL and TOGGLE_BOOL options ".
              "cannot also use the OPTION_APPEND_REPEATS flag"); 
      }

      $default_value_to_set //= 1;
      $default_value_to_reset //= 0;
    } elsif ($vartype == ARRAY_REF) {
      if (($action == OPTION_ASSIGN_BOOL) || ($action == OPTION_TOGGLE_BOOL))
        { die("ASSIGN_BOOL and TOGGLE_BOOL actions cannot be used on arrays"); }
      $default_value_to_set //= [ 1 ];
      $default_value_to_reset //= [ ];
    } elsif ($vartype == HASH_REF) {
      if (($action == OPTION_ASSIGN_BOOL) || ($action == OPTION_TOGGLE_BOOL))
        { die("ASSIGN_BOOL and TOGGLE_BOOL actions cannot be used on hashes"); }
      $default_value_to_set //= { 'default' => 1 };
      $default_value_to_reset //= { };
    } elsif ($vartype == CODE_REF) {
      # (defaults are decided by the called code)
      $default_value_to_set //= [ ];
      $default_value_to_reset //= [ ];
    } else {
      die("Option '$name': spec references unsupported variable type");
    }

    $specs = [ $varref, $action_and_flags, $alias_list, $default_value_to_set, $default_value_to_reset ];
    $expanded_specs{$name} = $specs;
        
    foreach my $alias ($name, @$alias_list) {
      my $old_alias_specs = $aliases->{$alias};
      if ((defined $old_alias_specs) && ($old_alias_specs != $specs))
        { die('Duplicate option name or alias "'.$alias.'"'); }
      
      $aliases->{$alias} = $specs;
    }
  }

  #
  # Add a '-help' option (aliased to '-?') to simply show the supported options 
  # without printing an error message about any invalid options:
  #
  # (NOTE: this is skipped if ('h', 'e', 'l' 'p') are all valid single character
  # combinable options, since adding 'help' will be ambiguous.)
  #

  my $help_spec = [ undef, 0, [ '?' ], 1, 0 ];

  if ((!exists $aliases->{'help'}) && (!hash_contains_all_keys($aliases, 'h', 'e', 'l', 'p'))) {
    $expanded_specs{'help'} = $help_spec;
    $aliases->{'help'} = $help_spec;
  }

  if (!exists $aliases->{'?'}) {
    $aliases->{'?'} = $help_spec;
  }

  $expanded_specs{'.aliases'} = $aliases;

  #
  # Process each alias with a single character name and a spec which sets
  # either OPTION_SINGLE_CHAR_COMBINABLE or OPTION_NO_SEPARATOR_BEFORE_VALUE:
  #

  my $single_char_option_hints = [ ];

  while (my ($name, $specs) = each %$aliases) {
    my $flags = $specs->[OPTION_SPEC_SLOT_ACTION_AND_FLAGS];

    #
    # It's perfectly valid for single char options to have longer
    # non-abbreviated aliases; in these cases we only consider the 
    # single character variants:
    #
    next if (length($name) != 1);

    if (($flags & OPTION_SINGLE_CHAR_COMBINABLE) && ($flags & OPTION_NO_SEPARATOR_BEFORE_VALUE)) {
      #
      # These two flags are mutually exclusive: if an option lacks any separator 
      # before its value, by definition it must also specify OPTION_VALUE_REQUIRED,
      # which implies it could not be parsed properly if it also claimed to be
      # OPTION_SINGLE_CHAR_COMBINABLE, so this pointless combination is not allowed:
      #
      die("Option or alias '$name' cannot specify both OPTION_SINGLE_CHAR_COMBINABLE and ".
           "OPTION_NO_SEPARATOR_BEFORE_VALUE");
    }

    $single_char_option_hints->[ord($name)] =
      ($flags & OPTION_SINGLE_CHAR_COMBINABLE) ? SINGLE_CHAR_OPTION_COMBINABLE :
        ($flags & OPTION_NO_SEPARATOR_BEFORE_VALUE) ? SINGLE_CHAR_OPTION_NO_VALUE_SEP :
        SINGLE_CHAR_OPTION_DEFAULT;
  }

  if (scalar @$single_char_option_hints) {
    #
    # Sanity check to make sure the caller didn't accidentally
    # define any longer non-single-character options which
    # would be ambiguous because they solely comprise other
    # single character options:
    #
    my @all_option_names = ((keys %$origspecs), (keys %$aliases));
    # print('all_option_names = '.join(' ', sort keys %$aliases).NL);
    foreach my $name (sort keys %$aliases) {
      next if (length($name) <= 1);
      my @chars = split(//, $name);
      my $single_char_combinable_opts = 0;
      # print($name.':'.NL);
      foreach my $c (@chars) {
        # print('  ['.$c.'] => '.($single_char_option_hints->[ord($c)] // ' ').NL);
        my $hint = $single_char_option_hints->[ord($c)] // 0;
        $single_char_combinable_opts += ($hint & SINGLE_CHAR_OPTION_COMBINABLE) ? 1 : 0;
      }

      if ($single_char_combinable_opts == length($name)) {
        die('Option "'.$name.'" is ambiguous because it only contains other single letter options');
      }
    }
  }

  $expanded_specs{'.single-char-option-hints'} = $single_char_option_hints;    

  # This modifies the original specs hash the caller passed to parse_command_line():
  %$origspecs = %expanded_specs;

  return ($origspecs, $aliases, $single_char_option_hints);
}

sub preprocess_option_specs_if_needed(+) {
  my ($specs) = @_;

  if (exists $specs->{'.aliases'}) 
    { return ($specs, $specs->{'.aliases'}, $specs->{'.single_char_option_hints'}); }

  return preprocess_option_specs($specs);
}

#-----------------------------------------------------------------------------
# parse_command_line(%option_specs, @args):
#
sub parse_command_line(+;+) {
  my ($orig_option_specs, $orig_args) = @_;

  $orig_args //= \@ARGV;

  if (!scalar $orig_args) { return ([ ], { }, { }); }

  my ($option_specs, $aliases, $single_char_option_hints) = preprocess_option_specs_if_needed($orig_option_specs);

  # returns a list comprising a reference to each of these three structures:
  my $filenames = $option_specs->{'.list'} // [ ];
  my $option_names_to_values = $option_specs->{'.all'} // { };
  my $invalid_arg_indexes = $option_specs->{'.invalid'} // { };
  
  die if ((!defined $aliases) || (!defined $single_char_option_hints));
    
  #
  # Pre-process the argument list to find any single character options
  # (with the flag OPTION_SINGLE_CHAR_COMBINABLE), which we expand into
  # distinct options in the real array of arguments we'll process:
  #

  my @args = ( );

  foreach (@$orig_args) {
    if (/$command_line_option_re/oax) {
      my $name = $2;
      if (exists $aliases->{$name}) 
        { push @args, $_; next; }

      my $firstchar = substr($name, 0, 1);
      my $h = $single_char_option_hints->[ord($firstchar)] // SINGLE_CHAR_OPTION_DEFAULT;
      if (($h == SINGLE_CHAR_OPTION_NO_VALUE_SEP) && (exists $aliases->{$firstchar})) {
        push @args, '-'.$firstchar.'='.substr($name, 1, length($name)-1);
      } else {
        #
        # Check if each character of the unknown option name is in fact an
        # option with the OPTION_SINGLE_CHAR_COMBINABLE flag (using the
        # $valid_single_char_combinable_options array to simplify this):
        #
        my @subopts = split(//, $name);
        my @expanded = ( );
        my $all_subopts_are_single_char_combinable = 1;
        foreach $subopt (@subopts) {
          $h = $single_char_option_hints->[ord($subopt)] // SINGLE_CHAR_OPTION_DEFAULT;
          next if (!defined $h);
          if ($h != SINGLE_CHAR_OPTION_COMBINABLE)
            { $all_subopts_are_single_char_combinable = 0; last; }
          $subopt = '-'.$subopt;
        }
        
        if ($all_subopts_are_single_char_combinable) {
          # append the sub-options, e.g. '-wxyz' => [ '-w', '-x', '-y', '-z' ]:
          push @args, @subopts;
        } else {
          # If any sub-option characters were not recognized, just let the
          # code below report an error for the bogus combination as a whole:
          push @args, $_;
        }
      }
    } else {
      # pass through filenames and other non-option arguments:
      push @args, $_;
    }
  }

  my $remaining_args_are_filenames = 0;
  my $n = scalar @args;
  my $v = undef;

  for (my $i = 0; $i < $n; $i++) {
    my $arg = $args[$i];
    my $argindex = $i;

    if ((!$remaining_args_are_filenames) && ($arg =~ /$command_line_option_re/oax)) {
      if ($arg eq '--') {
        $remaining_args_are_filenames = 1;
        next;
      }

      my ($modifier, $name, $value) = ($1, $2, $3);

      if (!exists $aliases->{$name}) {
        $invalid_arg_warning_message = 'Unknown option '.format_quoted($name);
        goto invalid_option;
      }

      my $specs = $aliases->{$name};

      my ($varref, $action_and_flags, $alias_list, $default_value_to_set, $default_value_to_reset) = @$specs;
      my $action = $action_and_flags & OPTION_ACTION_MASK;
      my $flags = $action_and_flags & ~OPTION_ACTION_MASK;

      my $named_value_to_internal_value_map = (($action == OPTION_VALUE_REQUIRED) && 
                                               is_hash_ref($default_value_to_set)) ?
                                                 $default_value_to_set : undef;

      # Only store this option's value in the hash we'll return:
      if ($varref == NO_VAR_FOR_OPTION) { 
        $option_names_to_values->{$name} = undef;
        $varref = \ {$option_names_to_values->{$name}};
      }

      my $implied_value = $option_name_modifier_to_implied_value{$modifier // 'enable'} // 1;

      $implied_value = ($implied_value < 0) ? -1 : 
        (($implied_value) ? $default_value_to_set : $default_value_to_reset);

      $invalid_arg_warning_message = undef;

      my $next_arg_is_value = ($i < $n-1) && ($args[$i+1] !~ /^-/oax);

      my $type = typeof $varref;
        
      # direct reference to boolean option with implied 0 or 1 value
      if (($action == OPTION_ASSIGN_BOOL) || ($action == OPTION_TOGGLE_BOOL)) {
        my $toggle = ($action == OPTION_TOGGLE_BOOL);

        if ($type != CODE_REF) {
          if ($type != SCALAR_REF) {
            $invalid_arg_warning_message = 
              'Cannot negate the default value since this option '.
                'is not a scalar ref to a boolean value';
            goto invalid_option;
          }

          my $initial_value = ${$varref};
          $initial_value = (!is_there($initial_value) || (is_numeric($initial_value) && ($initial_value == 0))) ? 0 : 1;

          $value = ($toggle) ? (($initial_value) ? 0 : 1) : $implied_value;
        } else { # $type == CODE_REF
          $value = 0;
        }
      } elsif ($action == OPTION_VALUE_REQUIRED) {
        if (!defined $value) {
          # if the next argument (if any) is an option (i.e. -xxx), this 
          # implies no value has been provided for this optional argument:
          if ($next_arg_is_value) {
            $value = $args[++$i];
          } else {
            $invalid_arg_warning_message = 
              'Option requires a value, specified either through '.
                $G.'-'.$name.'='.$Y.$U.'value'.$X.$R.' or '.
                  $G.'-'.$name.' '.$Y.$U.'value'.$X;
          }
        } # endif (!defined $value)
      } elsif ($action == OPTION_VALUE_OPTIONAL) {
        if (!defined $value) {
          # if the next argument (if any) is an option (i.e. -xxx), this 
          # implies no value has been provided for this optional argument:
          $value = ($next_arg_is_value) ? $args[++$i] : $default_value_to_set;
        }
      }
      
      invalid_option:

      if (defined $invalid_arg_warning_message) {
        $invalid_arg_warning_message = 
            $invalid_arg_warning_message.$X.$K.'; '.$R.'ignoring argument '.$B.'#'.
              $argindex.$R.' ('.$Y.$arg.$R.')'.$X;
        $invalid_arg_indexes->{$argindex} = $invalid_arg_warning_message;
        next;
      }

      if ((defined $named_value_to_internal_value_map) && (defined $value) &&
        (exists $named_value_to_internal_value_map->{$value} ||
         exists $named_value_to_internal_value_map->{lc($value)})) {
        $value = $named_value_to_internal_value_map->{$value} // $named_value_to_internal_value_map->{lc($value)};;
      }

      if ($type == SCALAR_REF) {
        $value //= '';
        if ($flags & OPTION_APPEND_REPEATS) {
          ${$varref} .= sep_if_not_first(${$varref}).$value;
        } else {
          # if we're toggling a boolean value, $value was already set above 
          # to the inverse of the existing value in the variable:
          ${$varref} = $value;
        }
        $option_names_to_values->{$name} = ${$varref};
      } elsif ($type == ARRAY_REF) {
        if (!defined $value) { 
          die('Invalid option specifications: '.
                'array options must require values (option '.$arg.')'); 
        }

        my @values = ($flags & OPTION_COMMA_SEP_LISTS) ? 
          split(/,/oax, $value) : ( $value );

        if ($flags & OPTION_APPEND_REPEATS) {
          push @{$varref}, @values;
        } else {
          @{$varref} = @values;
        }
        $option_names_to_values->{$name} = $varref;
      } elsif ($type == HASH_REF) {
        if (!defined $value) { 
          die('Invalid option specifications: '.
                'array options must require values (option '.$arg.')'); 
        }
        
        my $values = parse_list_of_key_equals_value_into_hash($value);

        if ($flags & OPTION_APPEND_REPEATS) {
          merge_hashes($varref, $values);
        } else {
          %{$varref} = %{$values};
        }
        $option_names_to_values->{$name} = $varref;
      } elsif ($type == CODE_REF) {
        my @extra_callback_args;
        @extra_callback_args = @$default_value_to_set if (defined $default_value_to_set);

        my $rc = $varref->($value, $name, $arg, $argindex, @extra_callback_args);
        if ((defined $rc) && is_ref($rc) && ($rc == INVALID_OPTION)) {
          $invalid_arg_indexes->{$argindex} = 1;
          next;
        }
        $option_names_to_values->{$name} = $rc;
      }
    } else {
      push @$filenames,$arg;
    }
  }

  return ($filenames, 
          ((scalar %$invalid_arg_indexes) ? $invalid_arg_indexes : undef),
          $option_names_to_values);
}

sub print_command_line_options_help(+;+) {
  my ($orig_options, $help_strings, $fd) = @_;
  $help_strings //= { };
  $fd //= STDOUT;

  my ($options, $aliases, $single_char_option_hints) =
    preprocess_option_specs_if_needed($orig_options);

  my @option_names = sort keys %$options;

  my @help = ( );

  my $option_alias_color = fg_color_rgb(scale_rgb(rgbC, 0.75));
  my $option_alias_separator = B.' '.dashed_vert_bar_3_dashes.' '.$option_alias_color.'-';
  # my $option_alias_separator = B.dashed_vert_bar_3_dashes.$option_alias_color; # (condensed form)

  foreach my $option (@option_names) {
    next if ($option =~ /^\./oax); # skip metadata we added (i.e. .aliases, etc.)

    my $specs = $options->{$option};

    my ($varref, $action_and_flags, $alias_list, $default_value_to_set, $default_value_to_reset) = @$specs;
    my $action = $action_and_flags & OPTION_ACTION_MASK;
    my $flags = $action_and_flags & ~OPTION_ACTION_MASK;

    my $named_value_to_internal_value_map = (($action == OPTION_VALUE_REQUIRED) && 
                                               is_hash_ref($default_value_to_set)) ?
                                                 $default_value_to_set : undef;
    my @line = ( );
    push @line, C.'-'.$option.((scalar(@$alias_list) > 0) ? $option_alias_separator : '').
      join($option_alias_separator, @$alias_list);

    my $arg_help = (($action == OPTION_VALUE_REQUIRED) ? M_2_3.double_left_angle_bracket.M.'value'.M_2_3.double_right_angle_bracket :
                   ($action == OPTION_VALUE_OPTIONAL) ? R_2_3.wide_left_square_bracket.R.'value (optional)'.R_2_3.wide_right_square_bracket :
                   '');
    if (is_array_ref($varref) && ($flags & OPTION_COMMA_SEP_LISTS)) { $arg_help .= B.',...'; }

    push @line, $arg_help;
    my $help_string = $help_strings->{$option};
    if (defined $help_string) { push @line,X.$help_string; }

    push @help, [ @line ];

    #if ((defined $alias_list) && (sizeof($alias_list) > 0)) {
    #my $alias_help = $B.'Aliases: '.$Y.'-'.join(' -', @$alias_list);
    #push @help, [ '', '', $alias_help ];
    #}
  }

  my $use_pager = (scalar(@help) + 3) >= get_terminal_height_in_lines();
  my $pagerfd = ($use_pager) ? (open_scrollable_stream() // $fd) : $fd;

  print($pagerfd print_folder_tab(Y.'Command Line Options Help:', R, ALIGN_LEFT));
  print($pagerfd format_columns(@help, '  ', '  '));
  print($pagerfd format_horiz_line(R_1_2, 'dashed'));
  print($pagerfd NL);
  close($pagerfd) if ($use_pager);
  return \@help;
}

sub print_invalid_options(+;$) {
  my ($invalid_options, $fd) = @_;

  $fd //= STDERR;

  my @invalid_option_indexes = sort keys %$invalid_options;
  my $n = (scalar @invalid_option_indexes);
  if (!$n) { return 0; }

  my $m = Y.warning_sign.' '.U.fg_color_rgb(255, 192, 0).'ERROR:'.UX.
    R.' command line contained '.$n.' invalid options:'.NL.
    '%{div=dashed}'.NL;

  my $prefix = $K.' '.dot.' argument #'.$B;
  my $prefix_length = printed_length($prefix) + 4 + 1;
  my $prefix_padding = ' ' x $prefix_length;

  foreach my $i (@invalid_option_indexes) {
    my $argmsg = $invalid_options->{$i};
    $argmsg =~ s{\n (?! \Z)}{$prefix_padding}oamsxg;
    $argmsg =~ s{\n$}{}oamsx;
    $m .= $K.' '.dot.' argument #'.$B.padstring($i.':', 4).' '.$R.$argmsg.$X.NL;
  }

  $m = text_in_a_box($m, ALIGN_LEFT, $R, 'double');

  print($fd $m);

  return $n;
}

sub parse_and_check_command_line(+;+&) {
  my ($options, $args, $help_func_or_strings) = @_;
  $args //= \@ARGV;
  
  my ($filenames, $invalid_arg_indexes, $option_names_to_values) = 
    parse_command_line($options, $args);
  
  my $invalid = (scalar keys %$invalid_arg_indexes) || 
    ((exists $options->{'.arguments_required'}) && (!scalar @$args));

  if ($invalid) {
    if (hash_is_missing_all_keys($option_names_to_values, 'help', '?') &&
      (scalar keys %$invalid_arg_indexes))
      { print_invalid_options($invalid_arg_indexes, STDERR); }

    if (is_code_ref($help_func_or_strings)) {
      $help_func_or_strings->($args); 
    } else { 
      print_command_line_options_help($options, $help_func_or_strings); 
    }

    exit(255);
  }

  return ($filenames, $invalid_arg_indexes, $option_names_to_values); 
}

sub print_current_option_settings(+;$) {
  my ($options, $fd) = @_;

  my @option_names = sort keys %$options;
  my $longest_option_name = printed_length(@option_names);

  my $out = '';

  foreach my $option (@option_names) {
    # skip over internal pseudo-options:
    next if ($option =~  /^[\.\<]/oamsx);

    my $spec = $options->{$option};
    my $ref = is_array_ref($spec) ? $spec->[0] : $spec;

    next if (!is_ref($ref)); # skip aliases to other options

    $out .= $K.' '.dot.' '.$Y.'-';
    $out .= padstring($option.' '.fg_color_rgb(64,64,64), 
              $longest_option_name + 4, 
              ALIGN_LEFT, heavy_dashed_horiz_bar_2_dashes).
              $G.(is_code_ref($ref) ? $K.' n/a' : format_var(undef, $ref)).$X.NL;
  }

  if (defined $fd) { print($fd $out); }

  return $out;
}

#
# Example:
#
# my %command_line_options = (
#   # (optional: array of non-option arguments also returned as first return value)
#   '<list>'   => \@file_name_list,
#   # (optional: hash that maps all defined option names 
#   # (without '-' or '-no-...' prefixes) to their values)
#   '<all>'    => \%all_names_to_values,
#   # (optional: array of indexes of any invalid options)
#   '<errors>' => \@invalid_arg_indexes,
#   # defined options (without '-' or '-no-...' prefixes):
#   'files'    => \$process_files_mode,  # simple boolean scalar args
#   'dirs'     => \$process_dirs_mode,   # simple boolean scalar args
#   'basedir'  => [\$basedir, OPTION_VALUE_REQUIRED],  # required value
#   'runthis'  => [\callback_sub, ...],  # sub to call to process this argument
#  );
# 
# my ($filename_list, $option_names_to_values, $invalid_arg_indexes) =
#  parse_command_line(%command_line_options);
#
# if (defined $invalid_arg_indexes) { die('Invalid arguments; aborting'); }
#

1;

