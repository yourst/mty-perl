#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Common::CommandLine
#
# Command Line Parsing
#
# Copyright 1997 - 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Common::CommandLine;

use MTY::System::POSIX;
use MTY::Common::Common;
use MTY::Common::Strings;
use MTY::Common::Hashes;
use MTY::Filesystem::Files;
use MTY::Filesystem::CurrentDir;
use MTY::Common::Strings;
use MTY::Display::Colorize;
use MTY::Display::ColorizeErrorsAndWarnings;
use MTY::Display::PrintableSymbols;
use MTY::Display::PrintableSymbolTools;
use MTY::Display::StringFormats;
use MTY::Display::Table;
use MTY::Display::TextInABox;
use MTY::Display::Scrollable;
use MTY::RegExp::Define;
use MTY::RegExp::Tools;
use MTY::RegExp::Blocks;
use MTY::RegExp::Numeric;
use MTY::RegExp::FilesAndPaths;
use MTY::RegExp::Strings;
use MTY::System::Misc;

use integer; use warnings; use Exporter qw(import);
#pragma end_of_includes

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(OPTION_OPT OPTION_REP OPTION_REQ OPTION_SET META_OPTION OPTION_BOOL
     OPTION_CHAR OPTION_FILE OPTION_HASH OPTION_LIST OPTION_FLOAT
     OPTION_COMMAS OPTION_NO_SEP OPTION_PREFIX OPTION_REGEXP OPTION_STRING
     OPTION_SUBSTR OPTION_TOGGLE INVALID_OPTION OPTION_INTEGER is_meta_option
     include_options OPTION_HASH_EDIT NO_VAR_FOR_OPTION OPTION_FLAGS_BASE
     OPTION_FLAGS_MASK OPTION_REP_TOGGLE OPTION_ACTION_BASE OPTION_ACTION_MASK
     OPTION_ASSIGN_BOOL OPTION_FLAGS_COUNT OPTION_HELP_BANNER
     OPTION_HELP_SPACER OPTION_HELP_SYNTAX OPTION_TOGGLE_BOOL
     parse_command_line META_OPTION_INCLUDE OPTION_ACTION_COUNT
     OPTION_HELP_DEFAULT OPTION_HELP_INCLUDE OPTION_HELP_LITERAL
     OPTION_HELP_SECTION OPTION_HELP_WRAPPED OPTION_INCLUDE_FILE
     expand_option_specs expand_options_help $key_value_option_re
     OPTION_FILE_WRITABLE OPTION_HELP_BULLETED OPTION_HELP_CATEGORY
     OPTION_APPEND_REPEATS OPTION_DATA_TYPE_AUTO OPTION_DATA_TYPE_BASE
     OPTION_DATA_TYPE_MASK OPTION_VALUE_OPTIONAL OPTION_VALUE_REQUIRED
     print_invalid_options OPTION_COMMA_SEP_LISTS OPTION_DATA_TYPE_COUNT
     $command_line_option_re preprocess_option_specs META_OPTION_PUT_ALL_HERE
     OPTION_HASH_MANIPULATION OPTION_MATCH_NAME_PREFIX
     OPTION_MATCH_NAME_SUBSTR OPTION_SPEC_SLOT_ALIASES
     META_OPTION_DASH_TO_STDIO SINGLE_CHAR_NOT_AN_OPTION
     add_styles_to_description check_parsed_command_line
     SINGLE_CHAR_OPTION_DEFAULT include_option_descriptions
     parse_and_check_command_line save_current_option_settings
     META_OPTION_HELP_DESCRIPTIONS OPTION_SINGLE_CHAR_COMBINABLE
     SINGLE_CHAR_OPTION_COMBINABLE print_current_option_settings
     read_options_from_config_file META_OPTION_PUT_FILENAMES_HERE
     OPTION_SPEC_SLOT_SET_EXTRA_VARS SINGLE_CHAR_OPTION_NO_VALUE_SEP
     print_command_line_options_help $convert_dash_to_stdin_or_stdout
     META_OPTION_NON_OPTIONS_REQUIRED META_OPTION_ONE_OR_MORE_REQUIRED
     OPTION_NO_SEPARATOR_BEFORE_VALUE @default_config_file_alternatives
     META_OPTION_PUT_INVALID_ARGS_HERE OPTION_SPEC_SLOT_ACTION_AND_FLAGS
     OPTION_SPEC_SLOT_DEF_VALUE_TO_SET preprocess_option_specs_if_needed
     restore_option_settings_from_hash OPTION_TOGGLE_BOOL_ON_EVERY_REPEAT
     OPTION_SPEC_SLOT_DEF_VALUE_ON_RESET OPTION_SPEC_SLOT_SYMBOLIC_VALUE_MAP
     OPTION_SPEC_SLOT_VARIABLE_REFERENCE
     META_OPTION_MUTUALLY_EXCLUSIVE_OPTIONAL
     META_OPTION_MUTUALLY_EXCLUSIVE_REQUIRED
     check_and_expand_prioritized_file_lists);

# 
#  Option Specification Array
#
#                    Option Specification Array:
#                    ---------------------------
#
# The properties of each valid option are specified by an array comprising the
# slots described below. The parse_command_line() function must be passed a
# hash which maps each option name (without the leading '-', as in '-option1')
# to a reference to its associated spec array. (Note that parse_command_line()
# may add its own internal entries to this hash to speed up subsequent parsings;
# the keys of these entries may include the names of any options or aliases).
#
# my %command_line_options = {
#   '-optionname' => [
#      <slot 0>         \$ref_to_scalar_or_array_or_hash_to_receive_option_value,
#      <slot 1>         OPTION_xxx (action) | (optional) OPTION_fff flags,
#      <slot 2>         (optional) alias name or ref to list of alias names
#      <slot 3>         (optional for some actions) default value to set,
#      <slot 4>         (optional) default value to set if option is negated
#                     ], ...
#
# Except for the refernece to the variable, all of the fields above are optional;
# if they are omitted, default values (described below) are automatically used.
#
# Alternatively, for the most common case of a simple boolean scalar option,
# the option spec array may be omitted entirely, and the value in the hash
# may instead be a direct reference to the variable to set or clear if that
# option (i.e. the hash key with a '-' prefix) appears on the command line.
#
#                             Actions:
#                             --------
#
# The following constants should be placed in the low 8 bits of slot [1]
# of the option specification array, along with various optional flags
# in the higher bits if desired. The subsequent slots [2] and [3] are
# used by some types of actions as well.
#
# OPTION_ASSIGN_BOOL:
#
#   Sets the referenced scalar to the value in slot [2] of the spec, or if
#   slot [2] is omitted, uses an integer value of 1 by default. 
#
#   If the option as provided on the command line is of the form "-no-<option>',
#   the "reset" value in slot [3] will be written to the variable instead (if
#   slot [3] is also omitted, the default reset value will be 0 and the default
#   set value will be 1.
#
#   If slot [1] (the actions and flags slot) is also omitted, or if a simple
#   reference to a scalar is given as the option's spec instead of providing
#   any spec array at all, the default action will be OPTION_ASSIGN_BOOL
#   with a set constant of "1" and a reset constant of "0".
#
# OPTION_TOGGLE_BOOL:
#
#   Interpret the referenced scalar as a boolean value, which is then logically
#   inverted and written back to the scalar. 
#
#   The three values (0 | '' | undef) are all considered a boolean "0" (i.e. 
#   the same semantics as Perl itself), and thus write the value 1 into the
#   that scalar variable. 
#
#   On the other hand, any properly defined non-zero integers, non-empty strings
#   or references to any other sort of object are interpreted as a boolean "1", 
#   so this option will clear the scalar back to 0 (unless the previous value was
#   a reference to some other object; in this case the scalar is set to undef).
#
#   If an inverting option is specified multiple times on the same command line, 
#   by default all subsequent repeats are ignored, since processing the later
#   inversions would be very confusing to the user; hence only the pre-initialted
#   default value in the variable is inverted once and only once. If you want the
#   value to invert every time the option appears on the command line, set the
#   OPTION_TOGGLE_BOOL_ON_EVERY_REPEAT bit in slot [1] (see below).
#
# OPTION_VALUE_REQUIRED:
#
#   The option requires an explicit value (<value>) to be specified on the command 
#   line in one of the following three ways:
#
#   - within the same argument as the option, by following it with an equals sign
#     ("=") and then the value (with no intervening spaces), e.g. "-option=<value>"
#
#   - within the same argument without any equals sign or other spearator after the
#     option name, only if the OPTION_NO_SEP_BEFORE_VALUE bit is set in slot [1]
#     (see below for details).
#
#   - as the next argument following the option, which can be given as just "-optname" 
#     without any equals sign or other indication that a value must follow it.
#
#   If the "-option=<value>" form is not used, and the option itself is either followed
#   by another option (starting with -...) as the next argument, or the option itself
#   is the final argument on the command line, an error will be returned to the caller.
#
# OPTION_VALUE_OPTIONAL:
#
#   Some types of options remain both useful and conceptually intuitive even if no value
#   is provided, yet a value can still be provided to override the default value. For
#   example, a hypothetical option called "-list" might be used to print an item specified
#   by the option's value, yet if "-list" is specified without a value, most programs would
#   simply list all known items, rather than returning an error.
#
#   To enable these semantics, the OPTION_VALUE_OPTIONAL action can be specified. If an
#   option specifying this action appears on the command line without any associated value, 
#   the default value in the option's spec array slot [3] is written into the referenced 
#   variable to inform the program that the user is invoking that option's more general
#   default behavior in the absence of a specific value.
#
#   If slot [3] is omitted, the default integer value 1 is written to the referenced variable.
#   (This value of 1 is preferable to using undef as a default value, since undef is normally
#   the initial state of these sorts of variables when they have never been modified by any
#   command line options at all.)
#
#                                 Special Bit Flags:
#                                 ------------------
#
# Along with the aforementioned actions, each variable's option spec can also set 
# several bit flags in the spec array's slot [1] to fine tune the handling of that
# option (some of the applicable bit flags depend on which action is selected).
#
# OPTION_APPEND_REPEATS:
#
#   IF a given option with the OPTION_VALUE_REQUIRED action is specified multiple times on the
#   command line, each subsequent repetition overwrites the referenced variable with the
#   value provided by the last instance of that option on the command line.
#
#   However, these semantics may be undesirable in situations where a given variable holds an
#   ordered list of multiple values specified on the command line. The OPTION_APPEND_REPEATS
#   bit flag facilitates this usage by concatenating all the values specified by all repeats
#   of the associated option; the referenced variable's value is then set to this combined 
#   value (in the form of an array or a string).
#
#   If the variable reference (specified by option spec slot [0]) points to an array, this 
#   array is simply set to the list of values provided for that option on the command line
#   in the order they originally appeared. (If the relevant option never appears even once,
#   the variable will never be overwritten; typically it would remain an empty array).
#
#   If the referenced variable is a scalar, it is assumed to be a text string, and is set to
#   the result of joining all provided values with spaces between them (if this is undesirable,
#   an array should be used instead, since this avoids any ambiguity over separator characters).
#
# OPTION_COMMA_SEP_LISTS:
#
#   If the OPTION_COMMA_SEP_LISTS bit flag is set in option spec slot [1], and the referenced
#   variable is an array or a hash (this flag has no effect on scalars, booleans or other types),
#   and an option with this flag appears on the command line with a value containing ',' or ':',
#   these characters are treated as separators between discrete list elements, and each element
#   is appended to the referenced variable (even if the OPTION_APPEND_REPEATS flag is not set).
#
#   However, unless OPTION_APPEND_REPEATS is also set, a subsequent use of the same option which
#   specifies either a single item or another list of items will cause that later option's list
#   of values to replace any existing list already in the referenced variable. By setting both
#   the OPTION_APPEND_REPEATS and OPTION_COMMA_SEP_LISTS flags for the option, the user is free
#   to mix and match list construction techniques, as shown in the example below:
#
#      programname -option1 ... -listopt a -listopt b,c,d -listopt -e -listopt f
#      programname -option1 ... -listopt a,b,c,d,e,f
#
#   Both of these command lines will result in the variable associated with the option "listopt"
#   containing the array [a, b, c, d, e, f] after the command line has been parsed. These semantics
#   are highly preferable in cases where some command line options may be defined in an environment
#   variable (as in how compiler flags are typically specified by Makefiles), whille others may
#   be specified later on. In these scenarios, it is physically impossible to construct a single
#   comma delimited list of all intended items, so letting the command line parser concatenate
#   several shorter lists of items is the best strategy here.
#
# OPTION_HASH_MANIPULATION:
#
#   If OPTION_HASH_MANIPULATION is set in slot [1] of the option spec array, 
#   for each entry in the list for -option=x,y,...,
#
#   - if the entry is '+x' or just 'x', add a new key 'x' => value 1
#   - if the entry is '-x' or '!x', remove the key 'x' from the hash
#   - if the entry is 'x=y', add a new key 'x' => value 'y'
#
#   If OPTION_HASH_MANIPULATION is not present in the option spec list,
#   the entire value of the option is added to the hash as both the
#   key and the value.
#
# OPTION_NO_SEPARATOR_BEFORE_VALUE:
#
#    If the OPTION_NO_SEPARATOR_BEFORE_VALUE bit flag is set, the affected option will expect to
#    find its value directly after the last character in the option name, without an "=" separating
#    the option name from the value. This can be desirable for both shorthand convenience as well
#    as compatibility with other tools like many compilers (which traditionally use "-Iincludedir"
#    instead of the much less intuitive "-I=includedir" to specify header file directories). 
#
#    Note that this flag will malfunction if it creates any ambiguity, e.g. where "-OptionArgument"
#    (for an option called "-Option" but not requiring the "=" separator) could be misinterpreted as
#    another option genuinely called "-OptionArgument". 
#
#    In these cases, the user should either be instructed to avoid the ambiguity themselves by using 
#    the "-Option=Argument" or "-Option Argument" alternative forms (which are still perfectly valid 
#    even when the OPTION_NO_SEPARATOR_BEFORE_VALUE bit is set) if there is any chance of confusion,
#    or by simply avoiding ambiguity altogether, for instance by refraining from having any other
#    options which begin with the prefix '-Ixxx" if an option named '-I' (with no '=' separator)
#    has also been defined.
#
# OPTION_TOGGLE_BOOL_ON_EVERY_REPEAT:
#
#   When applied to a boolean option, this flag causes the referenced variable to be inverted
#   every time the option is repeatedly listed on the command line (even though this behavior
#   is discouraged since it invariably confuses users compared to the default of only honoring
#   the first inversion, as explained above). This bit is ignored for non-boolean variables.
#

use constant enum (
  OPTION_SPEC_SLOT_VARIABLE_REFERENCE, # [0] reference to a scalar, array or hash into which the value is stored, or undef to only store it into the returned hash
  OPTION_SPEC_SLOT_ACTION_AND_FLAGS,   # [1] bitmask of OPTION_xxx constants below (or 0); may be omitted entirely if alias alias is an array ref or non-numeric string
  OPTION_SPEC_SLOT_ALIASES,            # [2] list of aliased alternative names for the same option (must be globally unique w.r.t. all other options and aliases)
  OPTION_SPEC_SLOT_DEF_VALUE_TO_SET,   # [3] value to store into referenced variable to set the option
  OPTION_SPEC_SLOT_DEF_VALUE_ON_RESET, # [4] value to store into referenced variable to clear the option (if i.e. -option-, -no-option, etc.)to the value stored into the variable
  OPTION_SPEC_SLOT_SYMBOLIC_VALUE_MAP, # [5] optional hash used to map OPTION_VALUE_REQUIRED parameter values from user provided text into the program's preferred form
  OPTION_SPEC_SLOT_SET_EXTRA_VARS,     # [6] list of pairs in the form "\$variable_name => 'valuehere'"; whenever the option is set, all of these variables are written with the specified values too
);

# Constants that can be ORed into spec slot 1 (see above for descriptions):

use constant {
  OPTION_ACTION_BASE    => 0,
  OPTION_ACTION_COUNT   => 4,
  OPTION_ACTION_MASK    => 0xff,

  OPTION_FLAGS_BASE       => 8,
  OPTION_FLAGS_COUNT      => 8,
  OPTION_FLAGS_MASK       => 0x00ffff00,

  OPTION_DATA_TYPE_BASE => 20,
  OPTION_DATA_TYPE_COUNT => 7,
  OPTION_DATA_TYPE_MASK => 0xf000,
};

use constant {
  # Actions (in low 8 bits of spec slot 1):
  OPTION_ASSIGN_BOOL     => 0,
  OPTION_TOGGLE_BOOL     => 1,
  OPTION_VALUE_REQUIRED  => 2,
  OPTION_VALUE_OPTIONAL  => 3,
  OPTION_INCLUDE_FILE    => 4,

  # Flags (in bits 19:8 of spec slot 1):
  OPTION_APPEND_REPEATS    => (1 << (OPTION_FLAGS_BASE + 0)),
  OPTION_COMMA_SEP_LISTS   => (1 << (OPTION_FLAGS_BASE + 1)),
  OPTION_HASH_MANIPULATION => (1 << (OPTION_FLAGS_BASE + 2)),
  OPTION_NO_SEPARATOR_BEFORE_VALUE => (1 << (OPTION_FLAGS_BASE + 3)),
  OPTION_TOGGLE_BOOL_ON_EVERY_REPEAT => (1 << (OPTION_FLAGS_BASE + 4)),
  OPTION_SINGLE_CHAR_COMBINABLE => (1 << (OPTION_FLAGS_BASE + 5)),
  OPTION_MATCH_NAME_PREFIX => (1 << (OPTION_FLAGS_BASE + 6)),
  OPTION_MATCH_NAME_SUBSTR => (1 << (OPTION_FLAGS_BASE + 7)),

  # Allow the value to be in one or more of these data types (may be ORed together);
  # if the option expects an array, each element must match the specified type:
  # Types (in bits 31:20 of spec slot 1):
  OPTION_DATA_TYPE_AUTO  => 0, # (the implied default of either bool or string dpeending on whether a value is expected or required)
  OPTION_STRING          => 1 << (OPTION_DATA_TYPE_BASE + 0),
  OPTION_BOOL            => 1 << (OPTION_DATA_TYPE_BASE + 1),
  OPTION_INTEGER         => 1 << (OPTION_DATA_TYPE_BASE + 2), # in decimal (+/- 123), hex (0xabc123..), octal (076543210) or binary (0b101101101...)
  OPTION_FLOAT           => 1 << (OPTION_DATA_TYPE_BASE + 3), # e.g. 1.234, -4.5678, 123.456e10-23, etc.
  OPTION_FILE            => 1 << (OPTION_DATA_TYPE_BASE + 4), # must be a valid filename (will check if it exists and is readable)
  OPTION_FILE_WRITABLE   => 1 << (OPTION_DATA_TYPE_BASE + 5), # must be a valid filename (will check if it exists and is writable, and/or its parent dir exists and it can be created)
  OPTION_REGEXP          => 1 << (OPTION_DATA_TYPE_BASE + 6), # valid perl regular expression
};

#
# Abbreviated names for the OPTION_... constants above:
#
use constant {
  OPTION_SET             => OPTION_ASSIGN_BOOL,
  OPTION_TOGGLE          => OPTION_TOGGLE_BOOL,
  OPTION_REQ             => OPTION_VALUE_REQUIRED,
  OPTION_OPT             => OPTION_VALUE_OPTIONAL,

  OPTION_REP               => OPTION_APPEND_REPEATS,
  OPTION_COMMAS            => OPTION_COMMA_SEP_LISTS,
  OPTION_HASH_EDIT         => OPTION_HASH_MANIPULATION,
  OPTION_NO_SEP            => OPTION_NO_SEPARATOR_BEFORE_VALUE,
  OPTION_REP_TOGGLE        => OPTION_TOGGLE_BOOL_ON_EVERY_REPEAT,
  OPTION_CHAR              => OPTION_SINGLE_CHAR_COMBINABLE,
  OPTION_PREFIX            => OPTION_MATCH_NAME_PREFIX,
  OPTION_SUBSTR            => OPTION_MATCH_NAME_SUBSTR,
};

use constant {
  # Typical combination of flags used for list options 
  # (e.g.   -option value1 -option value2    or    -option value1,value2,... -option value3
  OPTION_LIST => (OPTION_VALUE_REQUIRED | OPTION_COMMA_SEP_LISTS | OPTION_APPEND_REPEATS),
  OPTION_HASH => (OPTION_VALUE_REQUIRED | OPTION_COMMA_SEP_LISTS | OPTION_APPEND_REPEATS | OPTION_HASH_MANIPULATION),
};

our $command_line_option_re = compile_regexp(
  qr{^ - -? 
      ([^\=\:]*) 
      (?: [\=\:] (.*))? 
      $}oax,
  'Command line option X in one of the forms "-X", "--X", "-<modifier>-X", "-X=<V>", '.
  'or "-X:<V>", where V is a value string, and the optional <modifier> may be '.
  '"no", "disable", "enable" or "not", which imply a V of 0, 0, 1 or the logical '.
  'negation of a user-defined default value, respectively.');

my $modifier_and_option_name_re = 
  qr{($boolean_words_re)-([^\=\:]+)}oax;

my $modifier_re = 
  qr{(?|
       (?> \A ($boolean_words_re)-) |
       (?> (-) \Z)
     )}oax;

our $key_value_option_re = 
  qr{\G ([^\=\:]++) 
     (?> 
       [\=\:] 
       ((?: \\ . | [^,])*+)
     )? 
     (?> , | \Z)}oax;

#
# The $invalid_option_indicator variable and the INVALID_OPTION constant sub
# (which merely returns a const refernece to $invalid_option_indicator) exist 
# solely to let option handler callbacks return a reference to this uniquely 
# defined object to signal that the provided value was invalid. If the callback 
# returns anything else, we assume the option's value was valid.
#
# This lets callers avoid having to explicitly end each and every callback with 
# an explicit return statement (unless the option's value was bogus, of course).
#
# Callbacks should execute "return INVALID_OPTION;" if they decide the provided
# value was invalid; this will mark the option as invalid and force it to be
# listed in the resultant error message.
#

my $invalid_option_indicator = '<invalid>';

sub INVALID_OPTION { return \$invalid_option_indicator; }

#
# The $no_var_for_option_indicator and NO_VAR_FOR_OPTION constant sub
# (which merely returns a const refernece to $no_var_for_option_indicator) are
# used to indicate that a given option name is valid despite not being associated
# with any particular variable - its value will only be accessible through the
# $option_names_to_values hash returned by parse_command_line(). 
#
# Note that this facility can only be used for scalars, since we can't query the
# type of a referenced variable when that "variable" solely exists in a hash
# (because all values in perl hashes are scalars, i.e. strings, numbers or refs).
#
# Callers can use this facility by specifying "NO_VAR_FOR_OPTION" in place of
# the usual reference to a variable. Here's an example:
#
# my $var1;
# my %options = (
#   ...
#   'opt1' => NO_VAR_FOR_OPTION,  # 'opt1' only stored in returned hash
#   'opt2' => \$var1,             # 'opt2' stored in both $var1 and the hash
#   ...);
#

my $no_var_for_option_indicator = '<novariable>';

sub NO_VAR_FOR_OPTION { return \$no_var_for_option_indicator; }

#
# We add a reference to this string to the hash of options to indicate
# we've already expanded any alises and otherwise preprocessed the specs:
#
my $already_preprocesed_option_specs_indicator = '.<preprocessed-options>';

#
# If it's a literal string instead of a reference to the variable to set,
# it means this is an alias from the key ($name) to the real option
# name in $v, so we'll re-check the hash for the option named $v. This
# can be repeated several times if one alias chains to another alias
# before finally terminating in a reference to a variable or an array
# of option attributes (which will include the variable reference).
# (You are responsible for avoiding infinite loops if you chain aliases).
#

#
# Values in the @single_char_option_hints[] array 
# (where undef or 0 indicates neither of these are applicable;
# a given option may either have one or the other (not both),
# or simply have neither of these properties:
#
noexport:; use constant {
  SINGLE_CHAR_NOT_AN_OPTION        => 0,
  SINGLE_CHAR_OPTION_DEFAULT       => 1,
  SINGLE_CHAR_OPTION_COMBINABLE    => 2,
  SINGLE_CHAR_OPTION_NO_VALUE_SEP  => 3,
};

noexport:; use constant { META_OPTION => '!' };
my $is_meta_option_re = qr{\A \!}oax;

sub is_meta_option($) {
  my ($option) = @_;
  return ($option =~ $is_meta_option_re);
}

use constant {
  META_OPTION_HELP_DESCRIPTIONS     => META_OPTION.'help',

  META_OPTION_NON_OPTIONS_REQUIRED  => META_OPTION.'args_required',
  META_OPTION_ONE_OR_MORE_REQUIRED  => META_OPTION.'one_or_more_required',
  META_OPTION_MUTUALLY_EXCLUSIVE_REQUIRED => META_OPTION.'mutually_exclusive_required',
  META_OPTION_MUTUALLY_EXCLUSIVE_OPTIONAL => META_OPTION.'mutually_exclusive_optional',
  META_OPTION_DASH_TO_STDIO         => META_OPTION.'dash_to_stdio',
  META_OPTION_PUT_FILENAMES_HERE    => META_OPTION.'filenames',
  META_OPTION_PUT_ALL_HERE          => META_OPTION.'all',
  META_OPTION_PUT_INVALID_ARGS_HERE => META_OPTION.'invalid_args',
};

#
# This is a special internal meta-option because its name must be unique
# as a key in a hash of options, so we make the key unique by appending
# the refaddr of the value (the array or hash of sub-options to include) 
# passed to include_options() (see below):
#
noexport:; use constant META_OPTION_INCLUDE => META_OPTION.'include:';

#
# Specify another hash or array of pairs of option names and specs
# to include in the enclosing hash or array of options, e.g.:
#
# my %suboptions = (
#   sub1 => ...,
#   ...
# );
#
# my %options = (
#   opt1 => ...,
#   include_options(%suboptions),
#   opt2 => ...
#
# Internally this expands to the pair list:
#
#   !include:12345678 => \%suboptions
#
# where 12345678 is refaddr(\%suboptions) (see META_OPTION_INCLUDE).
#

sub include_options(+) {
  my ($options) = @_;
  return (
    META_OPTION_INCLUDE.refaddr($options), # make the hash key unique
    $options
  );
}

#
# By default, convert '-' to stdin or stdout filename or /dev/stdin or /dev/stdout
# (see details on this below). META_OPTION_DASH_TO_STDIO overrides this default.
#
our $convert_dash_to_stdin_or_stdout = 1;

my $show_help = 0;

noexport:; sub expand_option_specs(+) {
  my ($specs) = @_;

  return pairmap {
    ((starts_with($a, META_OPTION_INCLUDE))
      ? (expand_option_specs($b))
      : ($a => $b));
  } (flatten $specs);
}

noexport: sub preprocess_option_spec($++) {
  my ($name, $spec, $aliases) = @_;

  if ($name =~ /^-/oax) 
    { die('Option "'.$name.'" should not include a leading dash ("-")'); }
  
  if ($name =~ /^META_OPTION_/oax) { 
    die('"'.$name.'" appears to be an option name rather than a meta-option; '.
          'make sure you use the syntax "META_OPTION_xxx , ...", *not* "META_OPTION_xxx => ..."');
  }
  
  # Pass through flags or other parameters for
  # parse_options (not a real user visible option):
  return ($spec) if (is_meta_option($name));

  if (!defined $spec) {
    # expand form without explicit variable: 'name' => undef,
    # where option's value is placed only in the returned hash
    $spec = [ NO_VAR_FOR_OPTION ];
  } elsif (is_scalar_ref($spec)) {
    # expand short form: 'name' => \$scalar_var_name
    $spec = [ $spec ];
  } elsif (!is_array_ref($spec)) {
    die("Option '$name' must be either a ref to a scalar variable ".
          "or a ref to an option specification array");
  }

  #
  # $spec is now in array form, but may not have all fields filled in.
  # Expand abbreviated format that skips the flags and instead uses
  # that slot for the alias string or list of strings, i.e.:
  #
  #   [ \$var, 'alias', ... ]      # abbreviated form
  #   [ \$var, OPTION_FLAG_A|OPTION_FLAG_B, 'alias', ... ]   # normal form
  #
  # If the abbreviated form is used and the alias is a number 
  # (e.g. '9' for option '-9'), the alias must be given as an 
  # array reference to avoid ambiguity.
  #

  my ($varref, $action_and_flags, $alias_list, $default_value_to_set, $default_value_to_reset, $symbolic_value_map, $set_extra_vars) = 
    (is_numeric($spec->[OPTION_SPEC_SLOT_ACTION_AND_FLAGS])) ? @$spec :  # (full form)
      ($spec->[OPTION_SPEC_SLOT_VARIABLE_REFERENCE], undef, $spec->[OPTION_SPEC_SLOT_ACTION_AND_FLAGS], tailof($spec, 2)); # (expand abbrev form)

  my $type = typeof $varref;

  $action_and_flags //=
    is_scalar_ref_typeid($type) ? OPTION_ASSIGN_BOOL :
    ($type == ARRAY_REF) ? OPTION_LIST :
    ($type == HASH_REF) ? OPTION_HASH :
    ($type == CODE_REF) ? OPTION_VALUE_REQUIRED : 0;

  my $action = $action_and_flags & OPTION_ACTION_MASK;
  my $flags = $action_and_flags & ~OPTION_ACTION_MASK;

  $alias_list = [ sort { (length($a) <=> length($b)) } flatten($alias_list) ];

  if (($type == ARRAY_REF || $type == HASH_REF) &&
      (!(($action == OPTION_VALUE_REQUIRED) || ($action == OPTION_VALUE_OPTIONAL)))) { 
        die('Option "'.$name.'": ASSIGN_BOOL and TOGGLE_BOOL actions '.
          'cannot be used on arrays nor on hashes'); 
  }
  
  if ((defined $default_value_to_set) && 
      (is_array_or_hash $default_value_to_set) && 
      (!defined $symbolic_value_map)) {
    # the caller omitted the default_value_to_set and default_value_to_reset
    # fields and just went straight for the symbolic_value_map field here:
    $symbolic_value_map = $default_value_to_set;
    $default_value_to_set = undef;
    $default_value_to_reset = undef;
  }
  
  if (is_scalar_ref_typeid($type)) {
    if (($flags & (OPTION_APPEND_REPEATS|OPTION_COMMA_SEP_LISTS|OPTION_HASH_MANIPULATION)) &&
        (($action == OPTION_ASSIGN_BOOL) || 
         ($action == OPTION_TOGGLE_BOOL)) &&
         ($type == SCALAR_REF)) { 
      die('Option "'.$name.'": Unsupported option flags requested on '.
            'ASSIGN_BOOL or TOGGLE_BOOL action on a numeric variable');
    }

    $default_value_to_set //= 1;
    $default_value_to_reset //= 0;
  } elsif ($type == ARRAY_REF) {
    $default_value_to_set //= [ 1 ];
    $default_value_to_reset //= [ ];
  } elsif ($type == HASH_REF) {
    $default_value_to_set //= { '.default' => 1 };
    $default_value_to_reset //= { };
  } elsif ($type == CODE_REF) {
    # (defaults are decided by the called code)
    # $default_value_to_set //= 0;
    # $default_value_to_reset //= 0;
  } else {
    die("Option '$name': spec references unsupported variable type (".
          $typeid_to_string[$type // UNDEF], ' a.k.a. '.ref($varref).")");
  }
  
  $spec = [ 
    $varref, $action_and_flags, $alias_list, 
    $default_value_to_set, $default_value_to_reset,
    $symbolic_value_map, $set_extra_vars
  ];

  foreach my $alias ($name, @$alias_list) {
    my $old_alias_specs = $aliases->{$alias};
    if ((defined $old_alias_specs) && ($old_alias_specs != $spec)) { 
      die('Duplicate option name or alias "'.$alias.'"'.
            ' (existing specs were for aliases '.M.'['.join(', ', @{$old_alias_specs->[2]}).']'.R.')'.X);
    }
    $aliases->{$alias} = $spec;
  }
  
  return $spec;
}

noexport:; sub preprocess_option_specs(+) {
  my ($origspecs) = @_;

  my @expanded_specs = expand_option_specs($origspecs);

  my @all_option_names = pairkeys @$expanded_specs;

  my $aliases = { };

  my %annotated_specs = pairmap {
    $a => preprocess_option_spec($a, $b, $aliases); 
  } @expanded_specs;

  #
  # Add a '-help' option (aliased to '-?') to simply show the supported options 
  # without printing an error message about any invalid options:
  #
  # (NOTE: this is skipped if ('h', 'e', 'l' 'p') are all valid single character
  # combinable options, since adding 'help' will be ambiguous.)
  #

  if (!exists $aliases->{'help'}) {
    my $help_spec = [ \$show_help, 0, [ '?' ], 1, 0 ];
    
    if (!hash_contains_all_keys($aliases, qw(h e l p))) { 
      $annotated_specs{'help'} = $help_spec; 
      $aliases->{'help'} = $help_spec;
    }
    
    $aliases->{'?'} = $help_spec if (!exists $aliases->{'?'});
  }

  $annotated_specs{META_OPTION.'aliases'} = $aliases;

  #
  # Process each alias with a single character name and a spec which sets
  # either OPTION_SINGLE_CHAR_COMBINABLE or OPTION_NO_SEPARATOR_BEFORE_VALUE:
  #

  my $single_char_option_hints = [ ];

  while (my ($name, $spec) = each %$aliases) {
    my $flags = $spec->[OPTION_SPEC_SLOT_ACTION_AND_FLAGS];

    #
    # It's perfectly valid for single char options to have longer
    # non-abbreviated aliases; in these cases we only consider the 
    # single character variants:
    #
    next if (length($name) != 1);

    if (($flags & OPTION_SINGLE_CHAR_COMBINABLE) && ($flags & OPTION_NO_SEPARATOR_BEFORE_VALUE)) {
      #
      # These two flags are mutually exclusive: if an option lacks any separator 
      # before its value, by definition it must also specify OPTION_VALUE_REQUIRED,
      # which implies it could not be parsed properly if it also claimed to be
      # OPTION_SINGLE_CHAR_COMBINABLE, so this pointless combination is not allowed:
      #
      die("Option or alias '$name' cannot specify both OPTION_SINGLE_CHAR_COMBINABLE and ".
           "OPTION_NO_SEPARATOR_BEFORE_VALUE");
    }

    $single_char_option_hints->[ord($name)] =
      ($flags & OPTION_SINGLE_CHAR_COMBINABLE) ? SINGLE_CHAR_OPTION_COMBINABLE :
        ($flags & OPTION_NO_SEPARATOR_BEFORE_VALUE) ? SINGLE_CHAR_OPTION_NO_VALUE_SEP :
        SINGLE_CHAR_OPTION_DEFAULT;
  }

  if (scalar @$single_char_option_hints) {
    #
    # Sanity check to make sure the caller didn't accidentally
    # define any longer non-single-character options which
    # would be ambiguous because they solely comprise other
    # single character options:
    #
    foreach my $name (sort keys %$aliases) {
      next if (length($name) <= 1);
      my @chars = split(//, $name);
      my $single_char_combinable_opts = 0;

      foreach my $c (@chars) {
        my $hint = $single_char_option_hints->[ord($c)] // 0;
        $single_char_combinable_opts += ($hint & SINGLE_CHAR_OPTION_COMBINABLE) ? 1 : 0;
      }

      if ($single_char_combinable_opts == length($name)) {
        die('Option "'.$name.'" is ambiguous because it only contains other single letter options');
      }
    }
  }

  $annotated_specs{META_OPTION.'single-char-option-hints'} = $single_char_option_hints;    

  # This modifies the original specs hash the caller passed to parse_command_line():
  %$origspecs = %annotated_specs;

  return ($origspecs, $aliases, $single_char_option_hints);
}

sub preprocess_option_specs_if_needed(+) {
  my ($specs) = @_;

  return (exists $specs->{META_OPTION.'aliases'})
    ? ($specs, $specs->{META_OPTION.'aliases'}, $specs->{META_OPTION.'single_char_option_hints'})
    : preprocess_option_specs($specs);
}

#-----------------------------------------------------------------------------
# parse_command_line(%option_specs, @args):
#
sub parse_command_line(+;+) {
  my ($orig_option_specs, $orig_args) = @_;
  $orig_args //= \@ARGV;

  if (!defined $orig_args) { return ([ ], { }, { }); }

  my ($option_specs, $aliases, $single_char_option_hints) = preprocess_option_specs_if_needed($orig_option_specs);

  # returns a list comprising a reference to each of these three structures:
  my $filenames = $option_specs->{META_OPTION_PUT_FILENAMES_HERE} // [ ];
  my $option_names_to_values = $option_specs->{META_OPTION_PUT_ALL_HERE} // { };
  my $invalid_arg_indexes = $option_specs->{META_OPTION_PUT_INVALID_ARGS_HERE} // { };
  $show_help = 0;

  die if ((!defined $aliases) || (!defined $single_char_option_hints));

  #
  # Pre-process the argument list to find any single character options
  # (with the flag OPTION_SINGLE_CHAR_COMBINABLE), which we expand into
  # distinct options in the real array of arguments we'll process:
  #

  my @args = ( );

  foreach (@$orig_args) {
    if (/$command_line_option_re/oax) {
      my ($fullname, $value) = ($1, $2);

      my ($modifier) = ($fullname =~ /$modifier_re/oax);
      my ($name) = ($fullname =~ s{$modifier_re}{}roax);
      $name = ((!exists $aliases->{$fullname}) && (defined $modifier) && (defined $name)) ? $name : $fullname;

      if (exists $aliases->{$name}) 
        { push @args, $_; next; }

      my $firstchar = substr($name, 0, 1);
      my $h = $single_char_option_hints->[ord($firstchar)] // SINGLE_CHAR_OPTION_DEFAULT;
      if (($h == SINGLE_CHAR_OPTION_NO_VALUE_SEP) && (exists $aliases->{$firstchar})) {
        push @args, '-'.$firstchar.'='.substr($name, 1, length($name)-1);
      } else {
        #
        # Check if each character of the unknown option name is in fact an
        # option with the OPTION_SINGLE_CHAR_COMBINABLE flag (using the
        # $valid_single_char_combinable_options array to simplify this):
        #
        my @subopts = split(//, $name);
        my @expanded = ( );
        my $all_subopts_are_single_char_combinable = 1;
        foreach my $subopt (@subopts) {
          $h = $single_char_option_hints->[ord($subopt)] // SINGLE_CHAR_OPTION_DEFAULT;
          next if (!defined $h);
          if ($h != SINGLE_CHAR_OPTION_COMBINABLE)
            { $all_subopts_are_single_char_combinable = 0; last; }
          $subopt = '-'.$subopt;
        }
        
        if ($all_subopts_are_single_char_combinable) {
          # append the sub-options, e.g. '-wxyz' => [qw(-w -x -y -z)]:
          push @args, @subopts;
        } else {
          # If any sub-option characters were not recognized, just let the
          # code below report an error for the bogus combination as a whole:
          push @args, $_;
        }
      }
    } else {
      # pass through filenames and other non-option arguments:
      push @args, $_;
    }
  }

  my $remaining_args_are_filenames = 0;
  my $n = scalar @args;
  my $v = undef;
  my $single_dash_count = 0;
  my $dash_to_stdio = $option_specs->{(META_OPTION_DASH_TO_STDIO)} // $convert_dash_to_stdin_or_stdout;
  for (my $i = 0; $i < $n; $i++) {
    my $arg = $args[$i];
    my $argindex = $i;

    my ($fullname, $value) = ($arg =~ /$command_line_option_re/oax);
    if ($remaining_args_are_filenames || (!defined $fullname)) {
      push @$filenames, $arg;
      next;
    }

    if ($arg eq '--') {
      $remaining_args_are_filenames = 1;
      next;
    } elsif (($arg eq '-') && $dash_to_stdio && ($single_dash_count < 2)) {
      #
      # If the user piped a real file into stdin (e.g. "myprogram < /path/to/file").
      # try to provide the actual path to that file (by checking /proc/<pid>/fd/0).
      # If whatever is connected to stdin is a pipe instead of a real file, just
      # use "/dev/stdin" in place of "-".
      #
      # If this is the second appearance of "-", use stdout instead of stdin,
      # to support multi-pipe command chains like "... | myprogram - - | ...".
      #
      $single_dash_count++;
      $arg = actual_filename_of_open_fd(($single_dash_count == 1) ? STDIN_FD : STDOUT_FD);
      $arg = (defined $arg) ? resolve_path($arg) : ('/dev/std'.(($single_dash_count == 1) ? 'in' : 'out'));
      push @$filenames, $arg;
      next;
    }

    my ($modifier) = ($fullname =~ /$modifier_re/oax);
    my ($name) = ($fullname =~ s{$modifier_re}{}roax);
    $name = ((!exists $aliases->{$fullname}) && (defined $modifier) && (defined $name)) ? $name : $fullname;

    if (!exists $aliases->{$name}) {
      $invalid_arg_warning_message = 'Unknown option '.format_quoted($name);
      goto invalid_option;
    }

    my $specs = $aliases->{$name};

    my ($varref, $action_and_flags, $alias_list, $default_value_to_set, $default_value_to_reset, $symbolic_value_map, $set_extra_vars) = @$specs;

    my $action = $action_and_flags & OPTION_ACTION_MASK;
    my $flags = $action_and_flags & ~OPTION_ACTION_MASK;

    my $named_value_to_internal_value_map = undef;
    if ($action == OPTION_VALUE_REQUIRED) {
      $named_value_to_internal_value_map =
        ((defined $symbolic_value_map) && (is_hash_ref $symbolic_value_map)) ? $symbolic_value_map :
        ((defined $default_value_to_set) && (is_hash_ref $default_value_to_set)) ? $default_value_to_set :
        undef;
    }

    # Only store this option's value in the hash we'll return:
    if ($varref == NO_VAR_FOR_OPTION) {
      $option_names_to_values->{$name} = undef;
      $varref = \ {$option_names_to_values->{$name}};
    }

    my $implied_value = $boolean_words{$modifier // 'enable'} // 1;

    $implied_value = ($implied_value < 0) ? -1 : 
      (($implied_value) ? $default_value_to_set : $default_value_to_reset);

    $invalid_arg_warning_message = undef;

    my $type = typeof $varref;

    my $next_arg_is_value = ($action == OPTION_VALUE_REQUIRED) && ($i < $n-1) && ($args[$i+1] !~ /^-/oax);

    # direct reference to boolean option with implied 0 or 1 value
    if (($action == OPTION_ASSIGN_BOOL) || ($action == OPTION_TOGGLE_BOOL)) {
      my $toggle = ($action == OPTION_TOGGLE_BOOL);

      if ($type != CODE_REF) {
        if (!is_scalar_ref_typeid($type)) {
          $invalid_arg_warning_message = 
            'Cannot negate the default value since this option '.
              'is not a scalar ref to a boolean value';
          goto invalid_option;
        }

        my $initial_value = ${$varref};
        $initial_value = (!is_there($initial_value) || (is_numeric($initial_value) && ($initial_value == 0))) ? 0 : 1;

        $value = ($toggle) ? (($initial_value) ? 0 : 1) : $implied_value;
      } else {                                     # $type == CODE_REF
        $value = 0;
      }
    } elsif ($action == OPTION_VALUE_REQUIRED) {
      if (!defined $value) {
        # if the next argument (if any) is an option (i.e. -xxx), this 
        # implies no value has been provided for this optional argument:
        if ($next_arg_is_value) {
          $value = $args[++$i];
        } else {
          $invalid_arg_warning_message = 
            'Option requires a value, specified either through '.
              $G.'-'.$name.'='.$Y.$U.'value'.$X.$R.' or '.
                $G.'-'.$name.' '.$Y.$U.'value'.$X;
        }
      }                                      # endif (!defined $value)
    } elsif ($action == OPTION_VALUE_OPTIONAL) {
      if (!defined $value) {
        # if the next argument (if any) is an option (i.e. -xxx), this 
        # implies no value has been provided for this optional argument:
        $value = ($next_arg_is_value) ? $args[++$i] : $default_value_to_set;
      }
    }

    invalid_option:

    if (defined $invalid_arg_warning_message) {
      $invalid_arg_warning_message = 
        $invalid_arg_warning_message.$X.$K.'; '.$R.'ignoring argument '.$B.'#'.
          $argindex.$R.' ('.$Y.$arg.$R.')'.$X;
      $invalid_arg_indexes->{$argindex} = $invalid_arg_warning_message;
      next;
    }

    if ((defined $named_value_to_internal_value_map) && (defined $value) &&
          (exists $named_value_to_internal_value_map->{$value} ||
             exists $named_value_to_internal_value_map->{lc($value)})) {
      $value = $named_value_to_internal_value_map->{$value} // $named_value_to_internal_value_map->{lc($value)};;
    }

    if ($flags & OPTION_REGEXP) {
      my $re = undef;
      eval { $re = qr{$value}oax; };
      if (!defined $re) {
        $invalid_arg_warning_message = 'Option value must be a valid Perl regular expression';
        $invalid_arg_indexes->{$argindex} = $invalid_arg_warning_message;
        next;
      }
      $value = $re;
    }

    if (is_scalar_ref_typeid($type)) {
      $value //= '';
      if ($flags & OPTION_APPEND_REPEATS) {
        ${$varref} .= sep_if_not_first(${$varref}).$value;
      } else {
        # if we're toggling a boolean value, $value was already set above 
        # to the inverse of the existing value in the variable:
        ${$varref} = $value;
      }
      $option_names_to_values->{$name} = ${$varref};
    } elsif ($type == ARRAY_REF) {
      if (!defined $value) { 
        die('Invalid option specifications: '.
              'array options must require values (option '.$arg.')'); 
      }

      if (!($flags & OPTION_APPEND_REPEATS)) { @{$varref} = ( ); }

      push @{$varref}, (($flags & OPTION_COMMA_SEP_LISTS) 
          ? split(/,/oax, $value) : ( $value ));

      $option_names_to_values->{$name} = $varref;
    } elsif ($type == HASH_REF) {
      if (!defined $value) { 
        die('Invalid option specifications: '.
              'array options must require values (option '.$arg.')'); 
      }

      if (!($flags & OPTION_APPEND_REPEATS)) { %{$varref} = ( ); }

      parse_list_of_key_equals_value_into_hash($value, $varref, 1);

      $option_names_to_values->{$name} = $varref;
    } elsif ($type == CODE_REF) {
      my @extra_callback_args;
      @extra_callback_args = @$default_value_to_set if (defined $default_value_to_set);
        
      my $rc = $varref->($value, $name, $arg, $argindex, @extra_callback_args);
      if ((defined $rc) && is_ref($rc) && ($rc == INVALID_OPTION)) {
        $invalid_arg_indexes->{$argindex} = 1;
        next;
      }
      $option_names_to_values->{$name} = $rc;
    }
    
    if (defined $set_extra_vars) 
      { pairmap { ${$a} = $b } @$set_extra_vars; }
  }
  return ($filenames, 
          ((scalar %$invalid_arg_indexes) ? $invalid_arg_indexes : undef),
          $option_names_to_values);
}

use constant enum (
  OPTION_HELP_INCLUDE,        # include contents of array specified by right hand side
  OPTION_HELP_LITERAL,        # write literal text argument to output as is
  OPTION_HELP_WRAPPED,        # indent and word wrap argument to screen width
  OPTION_HELP_BULLETED,       # bullet (*) to left of aligned indented wrapped text
  OPTION_HELP_SPACER,         # blank line as spacer between options
  OPTION_HELP_CATEGORY,       # category label tab followed by column headings
  OPTION_HELP_SECTION,        # section label tab by itself
  OPTION_HELP_SYNTAX,         # default command syntax overview
  OPTION_HELP_BANNER,         # standard banner with program name and description
  OPTION_HELP_DEFAULT,        # default action if no options are specified
);

my $option_description_format_code_re =
  qr{(?<! \\) ([\~\^\|\%\#\@])}oamsx;

my $option_within_description_re = 
  qr{(?<! [\w\-]) -([^\s\,\;]+)}oamsx;

my $format_option_within_description = Y_1_2.'-'.Y;

my %option_format_code_to_color = (
  '~' => U,
  '^' => Y,
  '|' => W_2_3,
  '%' => R,
  '#' => G,
  '@' => SKYBLUE,
);

my %option_format_code_to_deactivate = (
  '~' => UX,
  '^' => X,
  '|' => X,
  '%' => X,
  '#' => X,
  '@' => X,
);

sub add_styles_to_description($) {
  my ($description) = @_;
  my $prev_code = '';

  my %active_codes = ( );
  $description =~ s{$option_description_format_code_re}{
    my $active = $active_codes{$1};
    my $color = ($active) 
      ? $option_format_code_to_deactivate{$1}
      : $option_format_code_to_color{$1};
    $active_codes{$1} = !$active;
    $color;
  }oamsxge;
  $description =~ s{($quote_type_and_text_re)}{format_auto_quoted($1)}oamsxge;
  $description =~ s{$option_within_description_re}{$format_option_within_description$1$X}oamsxg;
  return $description;
}

my $option_alias_color = fg_color_rgb(204, 180, 128);
my $option_alias_separator = K_2_3.dashed_vert_bar_3_dashes.$option_alias_color.'-';

my $light_bgcolor = bg_color_rgb(28, 28, 28);
my $dark_bgcolor = scale_rgb_bg($light_bgcolor, RATIO_2_3);
my $header_colors = fg_color_rgb(128, 128, 128).U;

my $header_row = [
  $header_colors.'Options'.UX,
  $header_colors.'Default'.UX,
  $header_colors.'Description'.UX,
];

sub include_option_descriptions(+) {
  my ($ref) = @_;
  return ([ OPTION_HELP_INCLUDE ] => $ref);
}

sub expand_options_help(+);
noexport:; sub expand_options_help(+) {
  my ($info) = @_;

  return (pairmap {
    (((is_array_ref $a) && ($a->[0] == OPTION_HELP_INCLUDE)) 
      ? (expand_options_help($b)) : ($a => $b));
  } @$info);
}

my $three_column_spacer = [ '', '', '' ];

sub print_command_line_options_help(+;+$) {
  my ($orig_options, $help_strings, $fd) = @_;

  $fd //= STDOUT;

  my ($options, $aliases, $single_char_option_hints) =
    preprocess_option_specs_if_needed($orig_options);

  $help_strings //= [ map { $_ => undef } grep { !is_meta_option($_) } (sort keys %$options) ];

  $help_strings = [ expand_options_help($help_strings) ];

  my $screen_width = get_terminal_width_in_columns();

  my @help_commands_providing_section_titles = 
    (OPTION_HELP_CATEGORY, OPTION_HELP_SECTION, OPTION_HELP_SYNTAX);

  my @section_titles = pairmap {
    my $match = undef;
    if (is_array_ref $a) {
      my ($command, $arg1, $arg2) = @$a;
      $match = 
        ($command == OPTION_HELP_CATEGORY ||
         $command == OPTION_HELP_SECTION) ? $b :
         $command == OPTION_HELP_SYNTAX ? Y.'Syntax' :
         undef;
    } 
    (defined $match) ? ( $match ) : ( );
  } @$help_strings;

  my $table_of_contents = undef;

  if ((scalar @section_titles) > 3) {
    # Print a brief table of contents:
    $table_of_contents = print_folder_tab(
      LIGHTBLUE.'Table of Contents', LIGHTBLUE_2_3, ALIGN_CENTER);
    while (my ($i, $section) = each @section_titles) {
      my $number = ((scalar @section_titles) < 10) 
        ? enclosed_digit($i + 1, solid_circled_large_digits) : padstring($i + 1, -3).'.';

      $table_of_contents .= LIGHTBLUE.'  '.$number.'  '.X.$section.NL;
    }
    $table_of_contents .= NL;
  }

  my %shortest_aliases = ( );
  my $shortest_length_of_all_aliases = 32;

  while (my ($option, $spec) = each %$options) {
    next if (is_meta_option($option));
    my ($varref, $action_and_flags, $alias_list) = @$spec;
    my $shortest_alias = $option;
    foreach my $alias (@$alias_list) {
      if ((length $alias) < (length $shortest_alias)) { $shortest_alias = $alias; };
    }

    $shortest_aliases{$option} = $shortest_alias;
    set_min($shortest_length_of_all_aliases, length($shortest_alias));
  }

  my $max_column_widths = [
    #(maxlength(keys %$aliases) * 1.5) + 6,  # aliases
    # $shortest_length_of_all_aliases + 1,
    0,
    0,                                     # default value
    WRAP_TO_REMAINING_SPACE_ON_LINE,       # description
  ];

  my $already_added_header_row = 0;

  my @table_of_options = pairmap {
    my ($option, $description) = ($a, $b);

    $description //= $option;
    my @rows = ( );

    if (is_array_ref $option) {
      my ($command, @args) = @$option;

      if ((defined $table_of_contents) && 
          ($command != OPTION_HELP_BANNER) &&
          ($command != OPTION_HELP_LITERAL)) {
        push @rows, $table_of_contents;
        $table_of_contents = undef;
      }

      if ($command == OPTION_HELP_LITERAL) {
        push @rows, ( $description );
        $already_added_header_row = 0;
      } elsif ($command == OPTION_HELP_SPACER) {
        push @rows, $three_column_spacer;
        $already_added_header_row = 1;
      } elsif ($command == OPTION_HELP_WRAPPED) {
        push @rows, map { $_.NL } (word_wrap_long_lines(add_styles_to_description($description), $screen_width, '  ', '  '));
        $already_added_header_row = 0;
      } elsif ($command == OPTION_HELP_BULLETED) {
        my ($bullet) = @args;
        $bullet //= B.dot;
        push @rows, map { $_.NL } (word_wrap_long_lines(add_styles_to_description($description), $screen_width, '  '.$bullet.X.' ', '    '));
        $already_added_header_row = 0;
      } elsif ($command == OPTION_HELP_CATEGORY || $command == OPTION_HELP_SECTION) {
        my ($tab_color, $tab_align) = @args;
        $tab_color //= SKYBLUE_2_3;
        $tab_align //= ALIGN_LEFT;
        push @rows, ( NL.print_folder_tab(C.$description, $tab_color, $tab_align).NL );
        $already_added_header_row = ($command == OPTION_HELP_SECTION) ? 1 : 0;
      } elsif ($command == OPTION_HELP_BANNER) {
        my ($box_color, $title, $store_banner_text_into_this_ref) = @args;
        $box_color //= B;
        $title //= filename_of($0);
        my $banner = print_banner($title, $description // '', $box_color);
        push @rows, $banner;
        if (defined $store_banner_text_into_this_ref)
          {  $$store_banner_text_into_this_ref = $banner; }
        $already_added_header_row = 1;
      } elsif ($command == OPTION_HELP_SYNTAX) {
        my $s = print_folder_tab(Y.'Syntax', G, ALIGN_LEFT).NL.
          '  '.G.filename_of($0).' '.($description // (
            K.' ['.M.'-option1 -option2 '.K.elipsis_three_dots.'] '.
            C.'file1 file2 '.K.elipsis_three_dots)).NL.NL;
        push @rows, ( $s );
        $already_added_header_row = 0;
      } elsif ($command == OPTION_HELP_DEFAULT) {
        $description = add_styles_to_description($description);

        my $line = [
          M.'(without options):'.X,
          '',
          add_styles_to_description($description)
        ];

        if (!$already_added_header_row) { push @rows, $header_row; };
        push @rows, $line;
        $already_added_header_row = 1;
      } else {
        die('Invalid option help command '.$command);
      }
    } else { # not a special OPTION_HELP_xxx command
      my $specs = $options->{$option};
 
      if (!defined $specs) {
        #
        # The help text includes a description of this option, but neither it nor
        # any of its aliases are actually defined in the actual options hash.
        #
        # We could consider this an error (or at least warn about it), but there
        # are many situations where it's useful to document "pseudo options", e.g.
        # if there are many closely related options like -run-x, -run-y, -run-z
        # which can be more concisely documented by a pseudo-option named e.g.
        # "-run-[x|y|z]".
        #
        # In this situation, we dynamically generate a dummy option spec so
        # the code below won't get confused.
        #
        warning("Option '$option' was described in the help text but it doesn't actually exist");
        $specs = [ undef, 0, [ $option ], 1, 0 ];
      }

      my ($varref, $action_and_flags, $alias_list, $default_value_to_set, $default_value_to_reset) = @$specs;
      my $action = $action_and_flags & OPTION_ACTION_MASK;
      my $flags = $action_and_flags & ~OPTION_ACTION_MASK;
      
      my $named_value_to_internal_value_map = (($action == OPTION_VALUE_REQUIRED) && 
                                               is_hash_ref($default_value_to_set)) ?
                                                 $default_value_to_set : undef;
      
      #
      # (enable if desired):
      #
      # Show all aliases in the first column, even this makes 
      # the first column very wide or splits it into many lines:
      #
      # my $name_and_aliases = Y.'-'.$option.((scalar @$alias_list) ? $option_alias_separator : '').
      #   join($option_alias_separator, @$alias_list);
      #
      
      my $primary_alias = $shortest_aliases{$option} // $option;
      
      my $other_alias_count = 0;

      foreach my $alias (@$alias_list) { 
        $other_alias_count += 
          (($alias ne $option) && ($alias ne $primary_alias)) ? 1 : 0;
      }
      
      my $name_and_aliases = 
        Y.'-'.$primary_alias.
          join_if(
            ($option ne $primary_alias) => $option_alias_separator.$option,
            ((scalar @$alias_list) >= 2) => $option_alias_separator.K.elipsis_three_dots);

      my $arg_help = ($action == OPTION_VALUE_REQUIRED) ? M_2_3.double_left_angle_bracket.M.'arg'.M_2_3.double_right_angle_bracket :
        ($action == OPTION_VALUE_OPTIONAL) ? R_2_3.'['.R.'arg'.R_2_3.']' : '';
         
      my $type = typeof($varref);
      if (($type == ARRAY_REF) && ($flags & OPTION_COMMA_SEP_LISTS)) { $arg_help .= B.', '.elipsis_three_dots; }
      my $default_as_scalar = ($type == SCALAR_REF) ? $$varref : undef;
      
      my $default_value = 
        ($type == SCALAR_REF) ? (
          (!defined $default_as_scalar) ? $arg_help : 
          is_numeric($default_as_scalar) ? (
            (is_hash_ref($default_value_to_reset) && defined($default_value_to_reset->{$default_as_scalar})) ?
              G.$default_value_to_reset->{$default_as_scalar} :
            (($action == OPTION_ASSIGN_BOOL) || ($action == OPTION_TOGGLE_BOOL)) ? 
              (($default_as_scalar == 0) ? R_3_4.x_signed_light.' no' : 
               ($default_as_scalar == 1) ? G.checkmark.' yes' : 
               Y.$default_as_scalar) : 
             Y.$default_as_scalar) :
           is_string($default_as_scalar) ? format_quoted(C.$default_as_scalar) :
           C.$default_as_scalar
         ) :
        ($type == ARRAY_REF) ? ((length(join(', ', @$varref)) <= 20)
                                ? G.join(K.', '.G, @$varref) 
                                : G.($varref->[0]).K.', '.R.elipsis_three_dots) :
        ($type == HASH_REF) ? C.join(K.', '.G, pairmap { C.$a.C_1_2.'='.G.$b } %$varref) :
        $arg_help;

      $description = add_styles_to_description($description);

      @rows = ( );
      if (!$already_added_header_row) { push @rows, $header_row };
      push @rows, [
        $name_and_aliases.' '.$arg_help,
        ($default_value // ''),
        W.($description // '')
      ];

      $already_added_header_row = 1;
    }

    @rows;
  } @$help_strings;

  my $out = format_table(@table_of_options, 
                         colseps => fg_color_rgb(48, 48, 48).' '.long_narrow_vert_bar.' '.X, # '  ', 
                         row_prefix => '  ',
                         wrap_above_max_col_widths => $max_column_widths,
                         subsequent_line_prefix => fg_color_rgb(80, 80, 80).arrow_open_tri.' '.X);
  $out .= NL;
  $out .= format_horiz_line(R_1_2, 'dashed');
  $out .= NL;

  my $line_count = scalar split(/\n/oamsx, $out);
  my $use_pager = ($line_count + 3) >= get_terminal_height_in_lines();
  my $pagerfd = ($use_pager) ? (open_scrollable_stream() // $fd) : $fd;

  printfd($pagerfd, $out);
  close($pagerfd) if ($use_pager);
  return $out;
}

sub print_invalid_options(+;$) {
  my ($invalid_options, $fd) = @_;

  $fd //= STDERR;

  my @invalid_option_indexes = sort keys %$invalid_options;
  my $n = (scalar @invalid_option_indexes);
  if (!$n) { return 0; }

  my $m = Y.warning_sign.' '.U.fg_color_rgb(255, 192, 0).'ERROR:'.UX.
    R.' command line contained '.$n.' invalid options:'.NL.
    '%{div=dashed}'.NL;

  my $prefix = $K.' '.dot.' argument #'.$B;
  my $prefix_length = printed_length($prefix) + 4 + 1;
  my $prefix_padding = ' ' x $prefix_length;

  foreach my $i (@invalid_option_indexes) {
    my $argmsg = $invalid_options->{$i};
    $argmsg =~ s{\n (?! \Z)}{$prefix_padding}oamsxg;
    $argmsg =~ s{\n$}{}oamsx;
    $m .= K.' '.dot.' argument #'.B.padstring($i.':', 4).' '.R.$argmsg.X.NL;
  }

  $m = text_in_a_box($m, ALIGN_LEFT, R, 'double');

  printfd($fd, $m);

  return $n;
}

sub check_parsed_command_line(+;+++) {
  my ($options, $option_names_to_values, $invalid_arg_indexes, $filenames) = @_;
  
  return 0 if ($show_help || (scalar keys %$invalid_arg_indexes) ||
               ((exists $options->{(META_OPTION_NON_OPTIONS_REQUIRED)}) && (!@$filenames)));

  my $one_or_more_required = $options->{(META_OPTION_ONE_OR_MORE_REQUIRED)};

  if (defined $one_or_more_required) {
    if (is_array_ref $one_or_more_required) {
      return 0 if (!hash_contains_any_of_keys($option_names_to_values, @$one_or_more_required));
    } else {
      return 0 if (!scalar keys %$option_names_to_values);
    }
  }

  my $mutually_exclusive_required = $options->{(META_OPTION_MUTUALLY_EXCLUSIVE_REQUIRED)};
  
  if (defined $mutually_exclusive_required) {
    my $n = 0;
    foreach my $option (@$mutually_exclusive_required) 
      { $n += (exists $option_names_to_values->{$option}) ? 1 : 0; }
    return 0 if ($n != 1);
  }

  my $mutually_exclusive_optional = $options->{(META_OPTION_MUTUALLY_EXCLUSIVE_OPTIONAL)};

  if (defined $mutually_exclusive_optional) {
    my $n = 0;
    foreach my $option (@$mutually_exclusive_optional) 
      { $n += (exists $option_names_to_values->{$option}) ? 1 : 0; }
    return 0 if ($n > 1);
  }
  return 1;
}

sub parse_and_check_command_line(+;++&) {
  my ($options, $args, $help_func_or_strings, $validator_func) = @_;
  $args //= \@ARGV;

  my ($filenames, $invalid_arg_indexes, $option_names_to_values) = 
    parse_command_line($options, $args);

  my @validation_call_args = ($options, $option_names_to_values, 
                              $invalid_arg_indexes, $filenames);

  my $invalid_options = ((scalar keys %$invalid_arg_indexes) > 0);

  my $satisfied_constraints = check_parsed_command_line(
    $options, $option_names_to_values, $invalid_arg_indexes, $filenames);

  my $accepted_by_validator_callback = (defined $validator_func) ?
    $validator_func->($options, $option_names_to_values, $invalid_arg_indexes, $filenames) : 1;

  my $invalid = $show_help || $invalid_options ||
    !$satisfied_constraints || !$accepted_by_validator_callback;

  if ($invalid) {
    if ((!$show_help) && (scalar keys %$invalid_arg_indexes))
      { print_invalid_options($invalid_arg_indexes, STDERR); }

    if (is_code_ref($help_func_or_strings)) {
      $help_func_or_strings->($args); 
    } else { 
      print_command_line_options_help($options, $help_func_or_strings); 
    }

    exit(255);
  }

  return ($filenames, $invalid_arg_indexes, $option_names_to_values); 
}

sub save_current_option_settings(+;+) {
  my ($options, $hash_of_specified_options) = @_;
  $hash_of_specified_options //= { };

  my @option_names = grep { (!is_meta_option($_)) } sort keys %$options;

  my $out = { };

  foreach my $name (@option_names) {
    my $spec = $options->{$name};
    my ($varref) = @$spec;
    my $type = generic_typeof($varref);

    # Convert refs to scalars back into strings and numbers,
    # whereas arrays and hashes must be left as refs:
    my $from_hash = $hash_of_specified_options->{$name};

    $varref = (defined $varref) ? $varref : 
      (exists $hash_of_specified_options->{$name}) ? \($hash_of_specified_options->{$name}) :
      undef;

    next if (!defined $varref);

    $out->{name} =
      ($type == SCALAR_REF) ? ${$varref} : 
      ($type == ARRAY_REF) ? [ @{$varref} ] :
      ($type == HASH_REF) ? { %{$varref} } :
      undef;
  }

  return $out;
}

sub restore_option_settings_from_hash(++) {
  my ($options, $hash_of_specified_options) = @_;

  while (my ($name, $value) = each %$hash_of_specified_options) {
    next if (!exists $options->{$name});
    my $spec = $options->{$name};
    my ($varref) = @$spec;
    next if (!defined $varref);

    my $type = generic_typeof($varref);
    my $valtype = generic_typeof(\$value);

    if ($type != $valtype) {
      die("restore_option_settings_from_hash: option $name spec points to ".
          "type $type but value is of type $valtype");
    }

    if ($type == SCALAR_REF) {
      $$varref = $value;
    } elsif ($type == ARRAY_REF) {
      @$varref = @$value;
    } elsif ($type == HASH_REF) {
      %$varref = %$value;
    }
  }

  return $hash_of_specified_options;
}

sub print_current_option_settings(+;$) {
  my ($options, $fd) = @_;

  my @option_names = sort keys %$options;
  my $longest_option_name = printed_length(@option_names);

  my $out = '';

  foreach my $option (@option_names) {
    # skip over internal pseudo-options:
    next if (is_meta_option($option));

    my $spec = $options->{$option};
    my $ref = is_array_ref($spec) ? $spec->[0] : $spec;

    next if (!is_ref($ref)); # skip aliases to other options

    $out .= $K.' '.dot.' '.$Y.'-';
    $out .= padstring($option.' '.fg_color_rgb(64,64,64), 
              $longest_option_name + 4, 
              ALIGN_LEFT, heavy_dashed_horiz_bar_2_dashes).
              $G.(is_code_ref($ref) ? $K.' n/a' : $ref).$X.NL;
  }

  if (defined $fd) { printfd($fd, $out); }

  return $out;
}

my $config_file_line_re = 
  qr{^ \s*+
     (?>
       \-? ([^\=\:\#\s]++) \s*+ 
       (?: [\=\:] \s*+ 
         (?|
           ($inside_quoted_re) |
           ([^\#\n]++)
         )
       )?
     )?
     (?: \# \N+)?
     \n?
     $
  }oamsx;

#
# Check one or more lists of prioritized file paths,
# and return a single list of the first accessible
# file (if any) found in each list.
#
# Each argument is either a file path (which will
# always be in the returned list if it exists), 
# or a reference to an array of alternative file
# paths in descending priority order.
#
# If all the arguments are strings instead of array 
# references, the entire argument list is considered 
# to be a single priority ordered list of alternatives,
# and this function returns the first file that exists.
#
my $placeholder_re = qr{(?<! \\) \%}oamsx;

sub check_and_expand_prioritized_file_lists(+;$$) {
  my ($list_of_lists, $return_only_first_existing, $placeholder) = @_;
  my $program = filename_of($0);
  if ($program eq '-e') { $program = undef; }
  $placeholder //= $program // '?';
  $return_only_first_existing //= 0;
  return (map {
    first_defined_result {
      my $path = ($_ =~ s{$placeholder_re}{$placeholder}roamsxg);
      resolve_path($path);
    } (flatten $_);
  } ($return_only_first_existing 
       ? (map { (flatten $_) } @$list_of_lists)
       : @$list_of_lists));
}

my $homedir = get_home_directory();
my $cwd = getcwd();

our @default_config_file_alternatives = (
  [
    '/etc/%.conf',
    '/etc/%',
    '/etc/.%.conf',
    '/etc/.%'
  ],
  [
    $homedir.'/.%.conf', 
    $homedir.'/%.conf', 
    $homedir.'/.%',
  ],
  [
    $cwd.'/.%.conf',
    $cwd.'/%.conf',
  ],
);

sub read_options_from_config_file {
  my $alternatives = (@_) ? \@_ : \@default_config_file_alternatives;

  my @args = ( );
  my @filenames = check_and_expand_prioritized_file_lists($alternatives);

  foreach my $filename (@filenames) {
    my $data = read_file_as_lines($filename);
    if (!defined $data) { warn('Cannot read '.$filename); next; }
    while (my ($linenum, $line) = each @$data) {
      if ($line =~ /$config_file_line_re/oamsxg) {
        my ($option, $value) = ($1, $2);
        next if (!defined $option); # (line has only comment or is blank)
        push @args, '-'.$option;
        if (defined $value) { push @args, $value; }
      } else {
        warn('Error parsing config file "'.$filename.'": line '.$linenum.' is invalid');
      }
    }
  }

  return @args;
}

1;

