#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Common::PrintDebug
#
# Print debug log text strings if enabled per package at runtime;
# also provides the prints() and printfd() convenience functions
#
# Copyright 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Common::PrintDebug;

use integer; use warnings; use Exporter qw(import);
use MTY::Common::Common;
#pragma end_of_includes

preserve:; our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($undef_placeholder $format_printable_data_callback
     simple_format_printable_data
     prints printfd printdebug is_debug
     %print_debug_enabled_for_package);

our $undef_placeholder = '<undef>';

noexport:; sub simple_format_scalar(+$) {
  my ($obj, $type) = @_;
  
  return 
    ($type == SCALAR) ? (0+$obj) :
    ($type == STRING) ? '"'.$obj.'"' :
    ($type == DUAL) ? 'dual<"'.$obj.'"/'.(0+$obj).'>' :
    undef;
}

noexport:; sub simple_format_array_or_hash_item(+) {
  my ($obj) = @_;
  my $type = typeof($obj);
  return
    ((!defined $_) ? $undef_placeholder :
     (is_scalar_typeid($type)) ? simple_format_scalar($obj, $type) :
     '\\'.lc($typeid_to_string[$type]).'<'.sprintf('0x%x', refaddr($obj)).'>');
}

noexport:; sub simple_format_array(+) {
  my ($array) = @_;
  return ('['.join(', ', (map { simple_format_array_or_hash_item($_) } @$array)).']');
}

noexport:; sub simple_format_hash(+) {
  my ($hash) = @_;
  return ('{'.join(', ', (pairmap {
    "$a".' => '.simple_format_array_or_hash_item($b) 
  } %$hash)).'}');
}

sub simple_format_printable_data(+) {
  my ($obj) = @_;

  my $type = typeof($obj);
  my $gentype = generic_typeid($type);
  my $hexref = sprintf('0x%x', refaddr($obj) // 0);

  return 
    (!defined $obj) ? $undef_placeholder :
    ($gentype == SCALAR) ? simple_format_scalar($obj, $type) :
    ($type == SCALAR_REF) ? '\\# '.simple_format_scalar(${$obj}, $type) :
    ($type == STRING_REF) ? '\\$ '.simple_format_scalar(${$obj}, $type) :
    ($type == DUAL_REF) ? '\\'.simple_format_scalar(${$obj}, $type) :
    ($type == REF_REF) ? '\\ref -> '.$hexref :
    ($type == ARRAY_REF) ? '@'.simple_format_array($obj) :
    ($type == HASH_REF) ? '%'.simple_format_hash($obj) :
    ($type == REGEXP_REF) ? 'qr{'.$obj.'}' :
    ($type == CODE_REF) ? '&sub '.$hexref :
      (lc($typeid_to_string[$type] // 'typeid#'.$type)).
        ' -> '.$hexref;
}

our $format_printable_data_callback = \&simple_format_printable_data;

sub printfd($;@) {
  my ($fd, @args) = @_;

  syswrite($fd, join('', (map { 
    ((!defined $_) ? $undef_placeholder :
     (is_scalar $_) ? $_ : 
       ($format_printable_data_callback->($_)))
  } @args)));
}

sub prints { printfd(STDOUT, @_); }

my %print_debug_enabled_for_package = ( );
my $print_debug_enabled_for_all_packages = 0;

sub is_debug(;$) {
  my $package = $_[0] // caller() // 'main';

  return ($print_debug_enabled_for_all_packages || 
          ($print_debug_enabled_for_package{$package} // 0)) ? 1 : 0;
}

sub printdebug {
  my $package = $_[0] // caller() // 'main';

  if ($print_debug_enabled_for_all_packages || 
     ($print_debug_enabled_for_package{$package} // 0)) {
    printfd(STDERR, @_, NL);
    return 1;
  } 

  return 0;
}

INIT {
  my $print_debug_env = $ENV{'PRINTDEBUG'} // '';
  if ((lc($print_debug_env) eq 'all') || ($print_debug_env eq '*')) {
    $print_debug_enabled_for_all_packages = 1;
  } else {
    my @printdebug_package_list = split(/,|\s+/oax, $print_debug_env);
    %print_debug_enabled_for_package = map { ($_ => 1) } @printdebug_package_list;
  }

  if ((scalar keys %print_debug_enabled_for_package) || $print_debug_enabled_for_all_packages) {
    printfd(STDERR, '# printdebug enabled via PRINTDEBUG environment variable for the following packages:'.NL.
                    '#   '.($print_debug_enabled_for_all_packages ? 
                            'ALL packages' : join(NL.'#   ', @printdebug_package_list)).NL);
  }
}

1;
