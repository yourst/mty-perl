#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Common::SimpleFormat
#
# Simple text formatting of all the major Perl data types
#
# Copyright 1997 - 2014 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Common::SimpleFormat;

use integer; use warnings; use Exporter::Lite;

use MTY::Common::Common;
# use Sub::Identify qw(:all);
#pragma end_of_includes

preserve:; our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(simple_format $undef_placeholder
     prints printfd 
     printdebug is_printdebug_enabled
     %print_debug_enabled_for_package);

our $undef_placeholder = '<undef>';

noexport:; use constant {
  FORMAT_REF_PREFIX => '\\',
};

# In case we're missing the Sub::Identify package:
sub sub_fullname {
  my ($sub) = @_;
  sprintf('&0x%x', refaddr($sub));
}

sub simple_format_scalar(++$;$) {
  my ($obj, $seen, $level, $type) = @_;
  $type //= UNDEF;

  return
    ($type == UNDEF) ? $undef_placeholder :
    ($type == SCALAR) ? $_[0] :
    ($type == STRING) ? '"'.$_[0].'"' :
    ($type == DUAL) ? 'dual<'.$_[0].' | "'.$_[0].'">' :
    undef;
}

sub simple_format_scalar_ref(++$;$) {
  my ($ref, $seen, $level, $type) = @_;
  my $obj = ${$ref};

  return FORMAT_REF_PREFIX.
    (($type == REF_REF) ? ' '.FORMAT_REF_PREFIX.' 0x'.sprintf('%p', $obj).' [ref to ref]' :
       simple_format_scalar($obj, $seen, $level, $type));
}

sub simple_format_array(++$;$) {
  my ($array, $seen, $level, $type) = @_;
  my $prefix = '  ' x $level;
  my $out = '';

  $seen->{$array} = 1;

  printfd(STDERR, $prefix.'enter simple_format_array(#'.scalar(@$array).' = ['.join(', ', map { $_ // $undef_placeholder } @$array).'])'.NL);

  my $n = scalar(@$array);
  $type = typeof($array->[0]) // UNDEF;
  
  my $abbrev = (($n <= 16) && ($type == SCALAR)) || (($n <= 8) && (($type == STRING) || ($type == DUAL)));
  my $trunc = ($type == SCALAR) ? 64 : ($type == STRING) ? 32 : scalar(@$array);

  if ($abbrev) {
    $out .= '[ '.join(' ', map { simple_format($_, $seen, $level) } @$array).' ] (#'.(scalar @$array).')';
  } else {
    $out .= '[ # ('.(scalar @$array).' entries)'.NL;
    
    while (my ($i, $elem) = each @$array) {
      if ($i >= $trunc) {
        $out .= $prefix.'  ['.$i.' ... '.((scalar @$array)-1).'] = ...'.NL;
        last;
      } else {
        $out .= $prefix.'  ['.$i.'] '.simple_format($elem, $seen, $level+1).','.NL;
      }
    }
    $out .= $prefix.'] (#'.scalar(@$array).')';
  }

  printfd(STDERR, $prefix.">>> [".$out."] <<<".NL);
  printfd(STDERR, $prefix.'exit simple_format_array(['.join(', ', @$array).'])'.NL);
  return $out;
}

sub simple_format_hash(++$$) {
  my ($hash, $seen, $level, $type) = @_;
  my $prefix = '  ' x $level;
  my $out = '';

  $seen->{$hash} = 1;

  $out .= '{ # ('.scalar(keys %$hash).' entries)'.NL;
  my $i = 0;

  foreach my $key (sort keys %$hash) {
    $i++;
    if ($i >= 64) {
      $out .= $prefix.'  (remaining '.((scalar keys %$hash)-$i).' entries = ...)'.NL;
    } else {
      my $value = $hash->{$key};
      $out .= $prefix.'  '.simple_format($key, $seen, $level).' => '.
        simple_format($value, $seen, $level+1).','.NL;
    }
  }
  $out .= $prefix.'} (#'.scalar(keys %$hash).')';

  return $out;
}

sub simple_format_code(++$;$) {
  my ($code, $seen, $level, $type) = @_;

  my $addr = sprintf('%p', $code);
  my $name = sub_fullname($code) // '<unknown>';
  #my $name = '<'.$addr.'>';
  my $show_addr = ($name eq '__ANON__') || ($name eq '<unknown>');

  return '& sub '.$name.' @ '.$addr.' { ... }';
}

sub simple_format_regexp(++$;$) {
  my ($regexp, $seen, $level, $type) = @_;

  my $s = "$regexp";
  return 'qr{'.$s.'}';
}

sub simple_format_blessed(++$;$) {
  my ($obj, $seen, $level, $type) = @_;

  my $addr = sprintf('%p', $obj);
  my $class = ref($obj);

  return $class.' @ '.$addr;
}

my %type_to_simple_format_func = (
  UNDEF,       \&simple_format_scalar,
  SCALAR,      \&simple_format_scalar,
  STRING,      \&simple_format_scalar,
  DUAL,        \&simple_format_scalar,
  REF_REF,     \$simple_format_scalar_ref,
  SCALAR_REF,  \$simple_format_scalar_ref,
  STRING_REF,  \$simple_format_scalar_ref,
  DUAL_REF,    \$simple_format_scalar_ref,
  ARRAY_REF,   \&simple_format_array,
  HASH_REF,    \&simple_format_hash,
  CODE_REF,    \&simple_format_code,
  REGEXP_REF,  \&simple_format_regexp,
  BLESSED_REF, \&simple_format_blessed,
);

sub simple_format(+;+$$) {
  my ($obj, $seen, $level, $type) = @_;
  $seen //= { };
  $level //= 0;
  $type //= typeof($_[0]) // UNDEF;

  my $seen_key = (is_ref($_[0])) ? $_[0] : undef;

  if (defined $seen_key) {
    if (exists $seen->{$seen_key})
      { return '<already printed '.$ref_type_index_to_string[$type].' @ 0x'.sprintf('%p', $obj).'>'; }
    $seen->{$seen_key} = 1;
  }

  my $func = $type_to_simple_format_func{$type};
  printfd(STDERR, ('  ' x $level), 'simple_format(', sprintf('%p', $obj), ', level ', $level, ', type ', $ref_type_index_to_string[$type], ') => func ', (sub_fullname($func).' @ '.$func), NL);
  my $out = ((defined $func) ? $func->($obj, $seen, $level+1, $type) :
               lc($ref_type_index_to_string[$type]).' '.$obj);
  printfd(STDERR, ('  ' x $level), '(return to simple_format of ', sprintf('%p', $obj), ')', NL);
  return $out;
}

sub printfd($;@) {
  my ($fd, @args) = @_;

  syswrite($fd, join('', (map { 
    (!defined $_) ? $undef_placeholder :
    is_ref($_) ? $_ : # simple_format($_) :
    $_
  } @args)));
}

sub prints { printfd(STDOUT, @_); }

our %print_debug_enabled_for_package = ( );

sub printdebug {
  my $package = caller() // 'main';
  if ($print_debug_enabled_for_package{$package} // 0) { printfd(STDERR, @_); }
}

sub is_printdebug_enabled(;$) {
  my $package = $_[0] // caller() // 'main';
  return ($print_debug_enabled_for_package{$package} // 0) ? 1 : 0;
}

INIT {
  my @printdebug_package_list = split(/,|\s+/oax, ($ENV{'PRINTDEBUG'} // ''));

  %print_debug_enabled_for_package = map { ($_ => 1) } @printdebug_package_list;

  if (scalar keys %print_debug_enabled_for_package) {
    printfd(STDERR, '# printdebug enabled via PRINTDEBUG environment variable for the following packages:'.NL.
                   '#  '.join(NL.'#  ', @printdebug_package_list).NL);
  }
}

1;
