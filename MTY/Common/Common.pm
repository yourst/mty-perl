#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Common::Common
#
# Common miscellaneous useful functions and tools for Perl
# (this module is included by all others in the MTY::...
# namespace, so it only depends on bullt-in perl modules).
#
# Copyright 1997 - 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Common::Common;

use integer; use warnings; use Exporter qw(import);
use re qw(is_regexp regexp_pattern regmust regname regnames regnames_count);

use Scalar::Util qw(reftype looks_like_number openhandle isdual blessed);
use re qw(is_regexp);

use List::Util qw(reduce any all none notall first sum0 pairgrep pairfirst pairmap pairs pairkeys pairvalues); # qw(max min)
#pragma end_of_includes

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw($empty_array_ref $empty_hash_ref $empty_scalar $empty_scalar_ref
     $undef_scalar $zero_scalar %empty_hash @empty_array
     @ref_type_index_to_symbol @typeid_to_generic_typeid @typeid_to_string
     ARRAY_REF BILLION BLESSED_REF CLASS_REF CODE_REF CR DUAL DUAL_REF EB ESC
     FORMAT_REF GB GLOB_REF HASH_REF IO_REF KB LVALUE_REF MB MILLION NL
     OBJECT_REF QUADRILLION RATIO_1_10 RATIO_1_2 RATIO_1_3 RATIO_1_4 RATIO_2_3
     RATIO_3_4 RATIO_9_10 REF_REF REGEXP_REF SCALAR SCALAR_REF STRING
     STRING_REF TAB TB THOUSAND TRILLION UNDEF UNDEF_REF UNKNOWN_REF
     VSTRING_REF addrof all_defined all_empty all_filled all_there
     all_undefined any_defined any_empty any_filled any_there any_undefined
     bit bitmask bits classof clipto copy_array_elements_where_undef enum
     enumbits extenum filter_pairs first_specified flatten generic_typeid
     generic_typeof getfields inrange is_array_or_blessed_array is_array_ref
     is_blessed_ref is_class_ref is_code_ref is_dual is_empty is_filled
     is_glob_ref is_hash_or_blessed_hash is_hash_ref is_numeric is_object_ref
     is_ref is_ref_ref is_ref_typeid is_regexp_ref is_scalar
     is_scalar_or_blessed_scalar is_scalar_ref is_scalar_ref_typeid
     is_scalar_typeid is_string is_there join_if join_with_sep_if
     list_contains longest_common_array_prefix lowbits max max_in_list min
     min_in_list named_or_ordered_args null pad_array pair_list_with_value
     prealloc push_if_defined ratio_to_percent ref_to_args ref_to_first_undef
     ref_type_string_to_typeid refaddr remove_dups remove_dups_in_place
     remove_undefs remove_undefs_in_place set_clipto set_max set_min setfields
     shifted_bitmask single_value_sparse_array sizeof slice_of_array
     sort_by_descending_length_then_alphabetical sparse_array typeof
     unblessed_typeof undefs_to undefs_to_empty_strings
     undefs_to_empty_strings_inplace undefs_to_inplace);

# For convenience, re-export these functions from List::Util:
push @EXPORT, qw(reduce any all none notall first 
                 pairgrep pairfirst pairmap pairs pairkeys pairvalues);

# Common control characters:
use constant {
  NL => "\n",
  CR => "\r",
  TAB => "\t",
  ESC => "\e",
};

# Dummy variables to simplify creation of references (but these must not be modified!):
our @empty_array = ( );
our %empty_hash = ( );
our $empty_scalar = '';
our $empty_array_ref = \@empty_array;
our $empty_hash_ref = \@empty_hash;
our $empty_scalar_ref = \$empty_scalar;
our $zero_scalar = +0;
our $undef_scalar = undef;

use constant {
  UNDEF          => 0,  # undefined value
  SCALAR         => 1,  # numerical scalar passed by value
  STRING         => 2,  # string scalar passed by value
  DUAL           => 3,  # dual use type (string and scalar) passed by value
  # ... or a reference to any of the following:
  REF_REF        => 4,  # indirect reference to another reference
  SCALAR_REF     => 5,  # (see above)
  STRING_REF     => 6,  # (see above)
  DUAL_REF       => 7,  # (see above)
  ARRAY_REF      => 8,  # array
  HASH_REF       => 9,  # hash
  CODE_REF       => 10, # entry point of compiled perl function, subroutine or lambda
  REGEXP_REF     => 11, # regular expression pre-compiled and optimized by qr{...} et al.
  BLESSED_REF    => 12, # blessed reference to object or instance of class
  GLOB_REF       => 13, # global symbol, potentially with per-type slots
  LVALUE_REF     => 14, # assignable lvalue (as returned by 'sub xxx: lvalue { ... }'
  FORMAT_REF     => 15, # precompiled string output format
  IO_REF         => 16, # I/O capable object
  VSTRING_REF    => 17, # version string (e.g. 1.23.456); treated specially for comparisons
  UNKNOWN_REF    => 18, # unknown type of object
};

our @typeid_to_generic_typeid = (
  SCALAR, SCALAR,  SCALAR, SCALAR,
  REF_REF, SCALAR_REF, SCALAR_REF, SCALAR_REF,
  ARRAY_REF, HASH_REF, CODE_REF, REGEXP_REF,
  BLESSED_REF, GLOB_REF, LVALUE_REF, FORMAT_REF,
  IO_REF, VSTRING_REF, SCALAR_REF
);

# Aliases to the *_REF constants above:
use constant {
  CLASS_REF  => BLESSED_REF,
  OBJECT_REF => BLESSED_REF,
  UNDEF_REF  => UNDEF,
  null       => UNDEF,
};

our @typeid_to_string = 
  qw(UNDEF SCALAR STRING DUAL
     REF_REF SCALAR_REF STRING_REF DUAL_REF
     ARRAY_REF HASH_REF CODE_REF REGEXP_REF
     BLESSED_REF GLOB_REF LVALUE_REF FORMAT_REF
     IO_REF VSTRING_REF UNKNOWN_REF);

our @ref_type_index_to_symbol =
  qw(! $ $ $ \\ \$ \$ \$ @ % & // :: * = FM IO VS ?);

#
# Note: the typeof() function below is faster than
# checking $ref_type_string_to_index{ref($...)},
# so this hash is for special uses only:
#
my %ref_type_string_to_typeid_map = (
  '' => SCALAR,
  'REF' => REF_REF,
  'SCALAR' => SCALAR_REF,
  'ARRAY' => ARRAY_REF,
  'HASH' => HASH_REF,
  'CODE' => CODE_REF,
  'Regexp' => REGEXP_REF,
  # '<Class::Name::Here>' => BLESSED_REF, # (handled specially below)
  'GLOB' => GLOB_REF,
  'LVALUE' => LVALUE_REF,
  'FORMAT' => FORMAT_REF,
  'IO' => IO_REF,
  'VSTRING' => VSTRING_REF,
);

sub ref_type_string_to_typeid($) {
  my ($s) = @_;

  #
  # Using ref() on a blessed class instance will return the package
  # name of that class in lieu of one of the primitive types in the
  # table above. If ref() is called on a scalar or undef, it will
  # return an empty string ('').
  #
  return 
    (!defined $s) ? UNDEF :
    (!length $s) ? SCALAR :
    ($ref_type_string_to_typeid_map{$s} // BLESSED_REF);
}

#
# The typeof(<obj>) function returns one of the xxx_REF constants listed above
# deppending on the data type of <obj> (which may be passed either as a true
# reference or as e.g. @obj, %obj, &obj, *obj, $obj, etc). This function is
# much faster than comparing the strings returned by ref(), since it only has
# to examine the first character of the reference type string to find the type
# of the reference (all type strings in perl (as of 5.18 at least) each have
# different initial characters, thus making it easy to disambiguate them (with
# the sole exception of (R)EF vs (R)egexp, but this is handled as a special
# case since it's not very common). 
#

my @ref_type_string_first_char_to_index = (
  SCALAR, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,          # 0   - 15
  0,      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,          # 16  - 31
  0,      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,          # 32  - 47
  0,      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,          # 48  - 63
  0,                                                            # 64
  ARRAY_REF, 0, CODE_REF, 0, 0, FORMAT_REF, GLOB_REF, HASH_REF, # 0  -  7 (A-H)
  IO_REF, 0, 0, LVALUE_REF, 0, 0, 0, 0,                         # 8  - 15 (I-P)
  0, REGEXP_REF, SCALAR_REF);                                   # 16 - 18 (Q-S)

sub typeof(+) {
  return UNDEF if (!defined $_[0]);
  my $r = ref $_[0];
  my $t = ((blessed $_[0]) && (!is_regexp($_[0]))) ? BLESSED_REF : $ref_type_string_first_char_to_index[ord($r)];
  return 
    ($t == SCALAR) ? ((isdual($_[0])) ? DUAL : (looks_like_number($_[0])) ? SCALAR : STRING) :
    ($t == SCALAR_REF) ? ((isdual ${$_[0]}) ? DUAL_REF : (looks_like_number(${$_[0]})) ? SCALAR_REF : STRING_REF) :
    ($t == REGEXP_REF) ? ((re::is_regexp($_[0])) ? REGEXP_REF : REF_REF) : $t;
}

sub unblessed_typeof(+) {
  return UNDEF if (!defined $_[0]);
  my $r = reftype $_[0];
  my $t = (defined $r) ? $ref_type_string_first_char_to_index[ord($r)] : SCALAR;
  return 
    ($t == SCALAR) ? ((isdual($_[0])) ? DUAL : (looks_like_number($_[0])) ? SCALAR : STRING) :
    ($t == SCALAR_REF) ? ((isdual ${$_[0]}) ? DUAL_REF : (looks_like_number(${$_[0]})) ? SCALAR_REF : STRING_REF) :
    ($t == REGEXP_REF) ? ((re::is_regexp($_[0])) ? REGEXP_REF : REF_REF) : $t;
}

sub addrof { return Scalar::Util::refaddr(\$_[0]); }  # (this is faster and more reliable)

sub refaddr { return (Scalar::Util::refaddr($_[0]) // Scalar::Util::refaddr(\$_[0])); }

sub is_scalar(+) { return (!ref($_[0])); }
sub is_ref { return (!!(ref $_[0])); }
sub is_scalar_ref { return (ord ref $_[0]) == 83; }
sub is_array_ref { return (ord ref $_[0]) == 65; }
sub is_hash_ref { return (ord ref $_[0]) == 72; }
sub is_code_ref { return (ord ref $_[0]) == 67; }
sub is_glob_ref { return (ord ref $_[0]) == 71; }
sub is_ref_ref { return ((ord ref $_[0]) == 82) && (!is_regexp($_[0])); }
sub is_regexp_ref { return ((ord ref $_[0]) == 82) && (is_regexp($_[0])); }
sub is_blessed_ref { return (blessed $_[0]); }
sub is_object_ref { return (blessed $_[0]); }
sub is_class_ref { return (blessed $_[0]); }

sub is_string { return ((defined $_[0]) && (!ref $_[0]) && (!looks_like_number $_[0])); }
sub is_numeric { return ((defined $_[0]) && (!ref $_[0]) && looks_like_number($_[0])); }
sub is_dual { goto &Scalar::Util::isdual; }

sub is_scalar_or_blessed_scalar { return (ord reftype $_[0]) == 83; }
sub is_array_or_blessed_array { return (ord reftype $_[0]) == 65; }
sub is_hash_or_blessed_hash { return (ord reftype $_[0]) == 72; }

sub classof(+) { return blessed(@_); }

sub generic_typeid { return $typeid_to_generic_typeid[$_[0]]; }
sub generic_typeof { return $typeid_to_generic_typeid[typeof($_[0])]; }

sub is_scalar_typeid($) {
  my ($typeid) = @_;
  my $gentype = $typeid_to_generic_typeid[$typeid];
  return ($gentype == SCALAR);
}

sub is_ref_typeid($) {
  my ($typeid) = @_;
  return ($typeid >= REF_REF);
}

sub is_scalar_ref_typeid($) {
  my ($typeid) = @_;
  my $gentype = $typeid_to_generic_typeid[$typeid];
  return (($gentype == SCALAR_REF) || ($gentype == REF_REF));
}

# Syntax: getfields %myhash, field1, field2, ...
sub getfields(+;@) {
  my ($hash, @fields) = @_;
  return @{$hash}{@fields};
}

# Syntax: setfields %myhash, field1 => val1, field2 => val2, ...
sub setfields(+;@) {
  my ($hash, %fields) = @_;
  @{$hash}{keys %fields} = values %fields;
  return $hash;
}

#
# Return a reference to the array of this function's arguments:
#

sub ref_to_args { return \@_; }

#
# flatten() flattens the referenced hash or array into
# a list of (key, value) pairs. This is useful when we
# don't know if the argument is a reference to a hash
# or an array of pairs, but we always want a list of
# pairs regardless of the argument type.
#
sub flatten(+) {
  my ($aoh) = @_;
  ((is_array_ref $aoh) ? @$aoh : %$aoh);
}

#
# Return a reference to a slice of an array, specified by
# its starting index and number of elements:
#
sub slice_of_array(+$;$) {
  my ($array, $start, $length) = @_;
  my $n = scalar @$array;
  if ($start < 0) { $start = $n + $start; }
  $length //= $n - $start;
  
  return ref_to_args @{$array}[$start .. ($start + $length - 1)];
}

#
# Automatically accept either named or ordered function arguments:
#
# Functions should invoke this like:
#
# sub xyz {
#   my ($arg1, $arg2, $arg3) = 
#     named_or_ordered_args @_, qw(arg1 arg2 arg3);
#   ...
# }
#
# Callers of xyz can then use either "xyz(1, 2, 3)" or 
# "xyz {arg1 => 1, arg2 => 2, arg3 => 3}".
#
# Some functions may take so many optional arguments that it would
# be impossibly confusing to ever blindly pass those arguments as an
# ordered list. For these functions, named_or_ordered_args can also
# be used as follows so callers can use funcname(a => ..., b => ...):
#
# sub xyz {
#   my ($arg1, $arg2, $arg3) = 
#     named_or_ordered_args { @_ }, qw(arg1 arg2 arg3);
# }
#

sub named_or_ordered_args(+@) {
  my $args = shift;

  return 
    (is_hash_ref $args) ? @{$args}{@_} :
    (is_hash_ref $args->[0]) ? @{$args->[0]}{@_} :
    @$args;
}

#
# Convenient constructors for constant declarations:
#

#
# e.g.     use constant enum qw(A B C 123 D)
# becomes: use constant { A => 0, B => 1, C => 2, D => 123}
#
sub enum {
  my $id = 0;
  return { map { ($_ => $id++) } @_ };
}

sub extenum {
  my $id = 0;
  return { map { 
    if ($_ =~ /\A \d+ \Z/oax) {
      $id = int($_);
      ( );
    } else {
      ($_ => $id++); 
    }
  } @_};
}

#
# e.g.     use constant enumbits qw(A B C D)
# becomes: use constant { A => (1 << 0), B => (1 << 1), C => (1 << 2), D => (1 << 3)}
#
sub enumbits {
  my $id = 0;
  return { map { ($_ => (1 << ($id++))) } @_};
}

#
# Numerical convenience functions
#

sub min($$;@) {
  return (($_[0] < $_[1]) ? $_[0] : $_[1]);
}

sub set_min($$) {
  my ($a, $b) = @_;
  $a //= 0;
  $a = ((!defined $b) || ($a < $b)) ? $a : $b;
  $_[0] = $a;
  return $a;
}

sub min_in_list {
  if (!@_) { return 0; }
  my $list = (is_array_ref($_[0])) ? $_[0] : @_;
  my $min = undef;
  foreach my $v (@$list) {
    next if (!defined $v);
    $min = ($v <= ($min // $v)) ? $v : $min;
  }
  return $min;
}

sub max($$) {
  return (($_[0] > $_[1]) ? $_[0] : $_[1]);
}

sub set_max($$) {
  my ($a, $b) = @_;
  $a //= 0;
  $a = ((!defined $b) || ($a > $b)) ? $a : $b;
  $_[0] = $a;
  return $a;
}

sub max_in_list {
  if (!@_) { return 0; }
  my $list = (is_array_ref($_[0])) ? $_[0] : @_;
  my $max = 0;
  foreach my $v (@$list) {
    next if (!defined $v);
    $max = ($v > $max) ? $v : $max;
  }
  return $max;
}

sub inrange($$$) { return (($_[0] >= $_[1]) && ($_[0] <= $_[2])) ? 1 : 0; }

sub clipto($$$) {
  return ($_[0] < $_[1]) ? $_[1] : ($_[0] > $_[2]) ? $_[2] : $_[0];
}

sub set_clipto($$$) {
  $_[0] = ($_[0] < $_[1]) ? $_[1] : ($_[0] > $_[2]) ? $_[2] : $_[0];
  return $_[0];
}

#
# Utility functions which consider both defined-vs-undef
# state of the argument, and iff it's defined, they'll
# only return true if the argument (taken as a string)
# is filled in (i.e. it has a non-zero length). Obviously
# is_empty() returns the exact opposite of is_filled().
#
# There are also all_filled() and any_empty() to check
# these properties for every item in the specified list.
#
sub is_there($) { return ((defined $_[0]) && (length $_[0])) ? 1 : 0; }
sub is_filled($) { return ((defined $_[0]) && (length $_[0])) ? 1 : 0; }
sub is_empty($) { return ((!defined $_[0]) || (!length $_[0])) ? 1 : 0; }

sub all_defined { return (all { defined } @_); }
sub any_defined { return (any { defined } @_); }
sub all_undefined { return (all { !defined } @_); }
sub any_undefined { return (any { !defined } @_); }
sub all_there { return (all { defined && length } @_); }
sub all_filled { return (all { defined && length } @_); }
sub all_empty { return (none { defined && length } @_); }
sub any_there { return (any { defined && length } @_); }
sub any_filled { return (any { defined && length } @_); }
sub any_empty { return (notall { defined && length } @_); }

sub first_specified { return (first { defined && length } @_); }

sub undefs_to { my $to = shift; return (map { $_ // $to } @_); }

sub undefs_to_inplace { my $to = shift; return (map { $_ //= $to } @_); }

sub undefs_to_empty_strings { return map { $_ // '' } @_; }
sub undefs_to_empty_strings_inplace { return map { $_ //= '' } @_; }

sub ref_to_first_undef { first { return \$_ if (!defined); } @_; return undef; }

sub list_contains(+$) {
  my ($list, $target) = @_;
  while (my ($i, $v) = each @$list) { return $i if ($v eq $target); }
  return undef;
}

sub sizeof(+) {
  local $t = typeof($_[0]);
  return
    (!defined $_[0]) ? 0 :
    ($t == ARRAY_REF) ? scalar @{$_[0]} :
    ($t == HASH_REF) ? scalar keys %{$_[0]} :
    ($t == STRING_REF) ? length ${$_[0]} :
    ($t == STRING) ? length $_[0] :
    ($t == SCALAR_REF || $t == SCALAR) ? 1 :
    ($t == REF_REF) ? 1 :
    undef;
}

#
# Pre-allocate an array or hash of a certain length when we know
# we'll be assigning to indexes up to that length (or for hashes,
# we'll be inserting the specified number of keys).
#
# NOTE: It is NOT safe to use a pre-allocated array for push
# operations, since the next array index written by the push
# will be the preallocated length, rather than the actual
# number of elements pushed so far.
#

sub prealloc(+$;$) {
  my ($array_or_hash, $length_or_fit_to, $filler) = @_;

  my $type = typeof($array_or_hash);
  my $length_type = typeof($length_or_fit_to);

  my $n = 
    ($length_type == ARRAY_REF) ? scalar @$length_or_fit_to :
    ($length_type == HASH_REF) ? scalar keys %$length_or_fit_to :
    ($length_type == STRING) ? length($length_or_fit_to) :
    $length_or_fit_to;

  if ($type == ARRAY_REF) {
    my $c = scalar(@$array_or_hash);

    if ((defined $filler) && ($n > $c)) {
      splice(@$array_or_hash, $c, $n-$c, (($filler) x ($n-$c)));
    } else {
      $#{$array_or_hash} = $n-1;
    }
  } elsif ($type == HASH_REF) {
    keys %$array_or_hash = $n;
  } elsif ($type == STRING) {
    my $c = length($_[0]);
    my $delta = max($n - $c, 0);
    $_[0] .= ("\0" x $delta) if ($delta);
    substr($_[0], $c, $delta, '');
  } else {
    die('Cannot preallocate data of type '.$typeid_to_string[$type]);
  }

  return $array_or_hash;
}

sub sparse_array {
  my @array = ( );
  pairmap { $array[$a] = $b; ( ); } @_;
  return @array;
}

sub single_value_sparse_array {
  my $value = shift;
  my @array = ( );

  map { $array[$_] = $value; } @_;
  return @array;
}

sub pair_list_with_value(+;$) {
  my ($list, $value) = @_;
  $value //= 1;
  return (map { ($_, $value) } @$list);
}

sub filter_pairs { return (pairmap { ($a) ? ($b) : ( ) } @_); }

sub join_if { return join('', pairmap { ($a) ? ($b) : ( ) } @_); }

sub join_with_sep_if($;@) {
  my $sep = shift; 
  return join($sep, pairmap { ($a) ? ($b) : ( ) } @_); 
}

sub remove_undefs { return (grep { defined } @_); }

sub remove_undefs_in_place(+) { my ($a) = @_; @$a = grep { defined } @$a; }

sub remove_dups(+) {
  my ($a) = @_;
  my %found = ( );
  return (grep { my $inc = (exists $found{$_}) ? 0 : 1; $found{$_} = 1; $inc; } @$a);
}

sub remove_dups_in_place(+) { my ($a) = @_; @$a = remove_dups($a); }

sub push_if_defined(+@) {
  my ($a) = shift;
  push @$a, (grep { defined $_ } @_);
  return (scalar(@$a));
}

sub copy_array_elements_where_undef(++) {
  my ($a, $b) = @_;

  #
  # Use the larger size as our limit, since perl will fill in 
  # any elements past the end of the smaller array with undefs
  # (if @b is larger than @a, this effectively means all elements
  # in @b at indexes greater than the size of @a will be copied
  # unconditionally into the corresponding indexes in @a).
  #
  my $size = max(scalar(@$a), scalar(@$b));

  my @out = ( );
  for (my $i = 0; $i < $size; $i++) { $out[$i] = $a->[$i] // $b->[$i]; }

  return (wantarray ? @out : \@out);
}

sub pad_array(+;$$) {
  my ($array, $newsize, $pad) = @_;
  
  my $n = scalar(@$array);

  $pad //= (($n > 0) ? $array->[-1] : undef);

  if ($newsize > $n) {
    splice(@$array, $n, $newsize-$n, (($pad) x ($newsize-$n)));
  } else {
    $#{$array} = $n-1;
  }

  return (wantarray ? @$array : $array);
}

sub bit($$) { return ($_[0] >> $_[1]) & 1; }
sub bitmask($) { return ($_[0] >= 64) ? (~0) : ((1 << $_[0]) - 1); }
sub shifted_bitmask($$) { return (bitmask($_[1]) << ($_[0])); }
sub bits($$$) { return (($_[0] >> $_[1]) & bitmask($_[2])); }
sub lowbits($$) { return ($_[0] & bitmask($_[1])); }

use constant {
  THOUSAND => 1000,
  MILLION => 1000000,
  BILLION => 1000000000,
  TRILLION => 1000000000000,
  QUADRILLION => 1000000000000000,
  KB => 1024,
  MB => 1024*1024,
  GB => 1024*1024*1024,
  TB => 1024*1024*1024*1024,
  EB => 1024*1024*1024*1024*1024,
};

sub sort_by_descending_length_then_alphabetical(+) {
  my ($list) = @_;

  return sort {
    my $r = length($b) <=> length($a);
    return ($r) ? $r : ($a cmp $b);
  } @$list;
}

no integer;
use constant {
  RATIO_9_10 => 0.90,
  RATIO_3_4 => 0.75,
  RATIO_2_3 => 2.0 / 3.0,
  RATIO_1_2 => 0.5,
  RATIO_1_3 => 1.0 / 3.0,
  RATIO_1_4 => 0.25,
  RATIO_1_10 => 0.10,
};
use integer;

sub ratio_to_percent($$) {
no integer;
  my ($a, $b) = @_;
  $a //= 0; $b //= 0;
  return ($b > 0) ? int((($a / $b) * 100.0) + 0.5) : 0;
use integer;
}

sub longest_common_array_prefix {
  my $n = scalar @_;
 
  if ($n <= 1) { return (($n) ? @{$_[0]} : ( )); }
  my $prev = $_[0];
  my $longest = scalar(@$prev);

  foreach my $array (@_[1..($n-1)]) {
    my $n = min($longest, min((scalar @$prev), (scalar @$array)));

    my $i = 0;
    for ($i = 0; $i < $n; $i++) { last if ($prev->[$i] ne $array->[$i]); }
    set_min($longest, $i);
    $prev = $array;

    last if (!$longest);
  }

  return (($longest) ? @{$prev}[0..($longest-1)] : ( ));
}

1;
