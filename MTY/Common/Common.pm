#!/usr/bin/perl -w
# -*- cperl -*-
#
# MTY::Common::Common
#
# Common miscellaneous useful functions and tools for Perl
# (this module is included by all others in the MTY::...
# namespace, so it only depends on bullt-in perl modules).
#
# Copyright 1997 - 2015 Matt T. Yourst <yourst@yourst.com>
#

package MTY::Common::Common;

use integer; use warnings; use Exporter qw(import);
use re qw(is_regexp regexp_pattern regmust regname regnames regnames_count);

use List::Util qw(reduce any all none notall first sum0 pairgrep pairfirst pairmap pairs pairkeys pairvalues);
use List::MoreUtils qw(pairwise zip uniq after before before_incl part indexes firstidx lastidx sort_by nsort_by minmax);
use Scalar::Util qw(reftype blessed isdual looks_like_number openhandle readonly isvstring tainted);
use Data::Alias qw(alias copy);
use re qw(is_regexp);
#pragma end_of_includes

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(CR EB GB KB MB NL TB ESC TAB bit max min DUAL bits bool enum null UNDEF
     IO_REF SCALAR STRING addrof clipto is_ref sizeof tailof typeof BILLION
     MILLION REF_REF bitmask classof cond_or extenum flatten inrange is_dual
     is_glob join_if lowbits refaddr reflist set_max set_min CODE_REF DUAL_REF
     GLOB_REF HASH_REF THOUSAND TRILLION all_true any_true enumbits if_there
     is_empty is_there multikey prealloc ARRAY_REF CLASS_REF RATIO_1_2
     RATIO_1_3 RATIO_1_4 RATIO_2_3 RATIO_3_4 UNDEF_REF all_empty all_false
     all_there any_empty any_false any_there getfields hash_args is_in_set
     is_scalar is_string none_true pad_array set_ifdef setfields undefs_to
     ALL_8_BITS FORMAT_REF LVALUE_REF OBJECT_REF RATIO_1_10 RATIO_9_10
     REGEXP_REF SCALAR_REF STRING_REF array_args count_true first_true
     flattenref is_numeric is_ref_ref is_tainted is_vstring named_args
     none_false set_clipto split_dual %empty_hash ALL_16_BITS ALL_32_BITS
     ALL_48_BITS ALL_64_BITS BLESSED_REF QUADRILLION UNKNOWN_REF VSTRING_REF
     all_defined any_defined count_empty count_false count_there first_there
     is_code_ref is_glob_ref is_hash_ref max_in_list min_in_list ref_to_args
     remove_dups $zero_scalar @empty_array bit_names_of filter_pairs
     is_array_ref is_class_ref is_read_only set_if_empty set_if_there
     sparse_array $empty_scalar $undef_scalar all_undefined any_undefined
     count_defined first_defined is_object_ref is_ref_typeid is_regexp_ref
     is_scalar_ref list_contains multikey_list remove_undefs blessed_typeof
     generic_typeid generic_typeof infinite_array is_blessed_ref
     slice_of_array $empty_hash_ref count_undefined first_specified
     push_if_defined shifted_bitmask $empty_array_ref arrays_identical
     escape_metachars hashes_identical is_array_or_hash is_scalar_typeid
     join_with_sep_if ratio_to_percent unblessed_typeof $empty_scalar_ref
     @typeid_to_string first_true_result undefs_to_inplace mutually_exclusive
     ref_to_first_undef first_defined_result is_scalar_ref_typeid
     pair_list_with_value remove_dups_in_place MODIFY_REF_ATTRIBUTES
     highest_set_bit_index index_list_to_bitmask named_or_ordered_args
     MODIFY_CODE_ATTRIBUTES MODIFY_HASH_ATTRIBUTES first_non_empty_result
     remove_undefs_in_place MODIFY_ARRAY_ATTRIBUTES infinite_writable_array
     is_array_or_hash_typeid is_hash_or_blessed_hash undefs_to_empty_strings
     MODIFY_Regexp_ATTRIBUTES MODIFY_SCALAR_ATTRIBUTES
     @ref_type_index_to_symbol @typeid_to_generic_typeid
     is_array_or_blessed_array ref_type_string_to_typeid
     single_value_sparse_array sparse_array_with_default
     is_blessed_or_array_or_hash is_scalar_or_blessed_scalar
     longest_common_array_prefix optional_mutually_exclusive
     escape_metachars_if_unescaped cond_and_index_list_to_bitmask
     copy_array_elements_where_undef undefs_to_empty_strings_inplace
     infinite_array_using_final_stride __sort_by_length_then_alphabetical
     sort_by_ascending_length_then_alphabetical
     sort_by_descending_length_then_alphabetical);

# For convenience, re-export these functions from 
# Data::Alias, List::Util and List::MoreUtils:
push @EXPORT, qw(alias copy reduce any all none notall first reftype
                 pairgrep pairfirst pairmap pairs pairkeys pairvalues
                 pairwise zip uniq after before before_incl part indexes
                 firstidx lastidx sort_by nsort_by minmax);

#
# Default no-op attribute handlers so we can tag functions, constants,
# variables, @EXPORT arrays, etc with attributes like :export, :noexport,
# :optexport, :preserve, :method, :nobundle, :autoexport, :noautoexport, 
# etc. for perl-mod-deps and similar tools to process.
# 
sub MODIFY_SCALAR_ATTRIBUTES { }
sub MODIFY_ARRAY_ATTRIBUTES { }
sub MODIFY_HASH_ATTRIBUTES { }
sub MODIFY_REF_ATTRIBUTES { }
sub MODIFY_CODE_ATTRIBUTES { }
sub MODIFY_Regexp_ATTRIBUTES { }

# Common control characters:
use constant {
  NL => "\n",
  CR => "\r",
  TAB => "\t",
  ESC => "\e",
};

# Dummy variables to simplify creation of references (but these must not be modified!):
our @empty_array = ( );
our %empty_hash = ( );
our $empty_scalar = '';
our $empty_array_ref = \@empty_array;
our $empty_hash_ref = \@empty_hash;
our $empty_scalar_ref = \$empty_scalar;
our $zero_scalar = +0;
our $undef_scalar = undef;

use constant {
  UNDEF          => 0,  # undefined value
  SCALAR         => 1,  # numerical scalar passed by value
  STRING         => 2,  # string scalar passed by value
  DUAL           => 3,  # dual use type (string and scalar) passed by value
  # ... or a reference to any of the following:
  REF_REF        => 4,  # indirect reference to another reference
  SCALAR_REF     => 5,  # (see above)
  STRING_REF     => 6,  # (see above)
  DUAL_REF       => 7,  # (see above)
  ARRAY_REF      => 8,  # array
  HASH_REF       => 9,  # hash
  CODE_REF       => 10, # entry point of compiled perl function, subroutine or lambda
  REGEXP_REF     => 11, # regular expression pre-compiled and optimized by qr{...} et al.
  BLESSED_REF    => 12, # blessed reference to object or instance of class
  GLOB_REF       => 13, # global symbol, potentially with per-type slots
  LVALUE_REF     => 14, # assignable lvalue (as returned by 'sub xxx: lvalue { ... }'
  FORMAT_REF     => 15, # precompiled string output format
  IO_REF         => 16, # I/O capable object
  VSTRING_REF    => 17, # version string (e.g. 1.23.456); treated specially for comparisons
  UNKNOWN_REF    => 18, # unknown type of object
};

# Aliases to the *_REF constants above:
use constant {
  CLASS_REF  => BLESSED_REF,
  OBJECT_REF => BLESSED_REF,
  UNDEF_REF  => UNDEF,
  null       => UNDEF,
};

our @typeid_to_string = 
  qw(UNDEF SCALAR STRING DUAL
     REF_REF SCALAR_REF STRING_REF DUAL_REF
     ARRAY_REF HASH_REF CODE_REF REGEXP_REF
     BLESSED_REF GLOB_REF LVALUE_REF FORMAT_REF
     IO_REF VSTRING_REF UNKNOWN_REF);

our @ref_type_index_to_symbol =
  qw(! $ $ $ \\ \$ \$ \$ @ % & // :: * = FM IO VS ?);

#
# Note: the typeof() function below is faster than
# checking $ref_type_string_to_index{ref($...)},
# so this hash is for special uses only:
#
my %ref_type_string_to_typeid_map = (
  '' => SCALAR,
  'REF' => REF_REF,
  'SCALAR' => SCALAR_REF,
  'ARRAY' => ARRAY_REF,
  'HASH' => HASH_REF,
  'CODE' => CODE_REF,
  'Regexp' => REGEXP_REF,
  # '<Class::Name::Here>' => BLESSED_REF, # (handled specially below)
  'GLOB' => GLOB_REF,
  'LVALUE' => LVALUE_REF,
  'FORMAT' => FORMAT_REF,
  'IO' => IO_REF,
  'VSTRING' => VSTRING_REF,
);

sub ref_type_string_to_typeid($) {
  my ($s) = @_;

  #
  # Using ref() on a blessed class instance will return the package
  # name of that class in lieu of one of the primitive types in the
  # table above. If ref() is called on a scalar or undef, it will
  # return an empty string ('').
  #
  return 
    (!defined $s) ? UNDEF :
    (!length $s) ? SCALAR :
    ($ref_type_string_to_typeid_map{$s} // BLESSED_REF);
}

#
# The typeof(<obj>) function returns one of the xxx_REF constants listed above
# deppending on the data type of <obj> (which may be passed either as a true
# reference or as e.g. @obj, %obj, &obj, *obj, $obj, etc). This function is
# much faster than comparing the strings returned by ref(), since it only has
# to examine the first character of the reference type string to find the type
# of the reference (all type strings in perl (as of 5.18 at least) each have
# different initial characters, thus making it easy to disambiguate them (with
# the sole exception of (R)EF vs (R)egexp, but this is handled as a special
# case since it's not very common). 
#

my @ref_type_string_first_char_to_index = (
  SCALAR, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,          # 0   - 15
  0,      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,          # 16  - 31
  0,      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,          # 32  - 47
  0,      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,          # 48  - 63
  0, ARRAY_REF, 0, CODE_REF, 0, 0, FORMAT_REF, GLOB_REF,        # 64  - 71 (@, A-G)
  HASH_REF, IO_REF, 0, 0, LVALUE_REF, 0, 0, 0,                  # 72  - 79 (H-O)
  0, 0, REGEXP_REF, SCALAR_REF, 0, 0, VSTRING_REF, 0);          # 80 -  87 (P-W)

sub typeof {
  alias my $obj = $_[0];

  return UNDEF if (!defined $obj);

  my $r = reftype $obj;
  my $t = (defined $r) ? $ref_type_string_first_char_to_index[ord $r] : SCALAR;

  return
    ($t == SCALAR) ? (
      (isdual $obj) ? DUAL : 
      (looks_like_number $obj) ? SCALAR : 
      STRING) :
    ($t == SCALAR_REF) ? (
      (!defined ${$obj}) ? SCALAR_REF :
      (isdual ${$obj}) ? DUAL_REF : 
      (looks_like_number ${$obj}) ? SCALAR_REF : 
      STRING_REF) :
    ($t == REGEXP_REF) ? (
      # Resolve ambiguity of first char of ref/reftype w.r.t. REGEXP vs REF:
      (re::is_regexp $obj) ? REGEXP_REF : 
      REF_REF) : 
    $t;
}

sub generic_typeof {
  alias my $obj = $_[0];

  return UNDEF if (!defined $obj);

  my $r = reftype $obj;
  my $t = (defined $r) ? $ref_type_string_first_char_to_index[ord $r] : SCALAR;

  # Resolve ambiguity of first char of ref/reftype w.r.t. REGEXP vs REF:
  return (($t == REGEXP_REF) ? ((re::is_regexp $obj) ? REGEXP_REF : REF_REF) : $t);
}

sub unblessed_typeof { goto &typeof; }

sub blessed_typeof { 
  return BLESSED_REF if ((blessed @_) && (!re::is_regexp @_));
  goto &typeof;
}

sub addrof { (defined $_[0]) ? Scalar::Util::refaddr(\$_[0]) : 0; }

sub refaddr { return (Scalar::Util::refaddr($_[0]) // Scalar::Util::refaddr(\$_[0])); }

sub is_scalar(+) { (!ref($_[0])); }
sub is_ref { (!!(ref $_[0])); }
sub is_scalar_ref { (ord ref $_[0]) == 83; }
sub is_array_ref { (ord ref $_[0]) == 65; }
sub is_hash_ref { (ord ref $_[0]) == 72; }
sub is_code_ref { (ord ref $_[0]) == 67; }
sub is_glob_ref { (ord ref $_[0]) == 71; }
sub is_ref_ref { ((ord ref $_[0]) == 82) && (!is_regexp($_[0])); }
sub is_regexp_ref { ((ord ref $_[0]) == 82) && (is_regexp($_[0])); }
sub is_blessed_ref { (blessed $_[0]); }
sub is_object_ref { (blessed $_[0]); }
sub is_class_ref { (blessed $_[0]); }
sub is_glob { (ord ref (\$_[0])) == 71; }

sub is_string { ((defined $_[0]) && (!ref $_[0]) && (!looks_like_number $_[0])); }
sub is_numeric { ((defined $_[0]) && (!ref $_[0]) && looks_like_number($_[0])); }
sub is_dual { goto &Scalar::Util::isdual; }

sub is_scalar_or_blessed_scalar { (ord reftype $_[0]) == 83; }
sub is_array_or_blessed_array { (ord reftype $_[0]) == 65; }
sub is_hash_or_blessed_hash { (ord reftype $_[0]) == 72; }

sub is_array_or_hash { my $t = ord ref $_[0]; (($t == 65) || ($t == 72)); }
sub is_blessed_or_array_or_hash { my $t = ord reftype $_[0]; (($t == 65) || ($t == 72)); }

sub is_read_only { goto &Scalar::Util::readonly; }
sub is_tainted { goto &Scalar::Util::tainted; }
sub is_vstring { goto &Scalar::Util::isvstring; }

sub split_dual { 
  alias my $dual = $_[0]; 
  return ((isdual $dual) ? ((0+$dual), "$dual") : ($dual, $dual));
}

sub classof { return (!is_regexp $_[0]) ? blessed($_[0]) : undef; }

our @typeid_to_generic_typeid = (
  SCALAR, SCALAR,  SCALAR, SCALAR,
  REF_REF, SCALAR_REF, SCALAR_REF, SCALAR_REF,
  ARRAY_REF, HASH_REF, CODE_REF, REGEXP_REF,
  BLESSED_REF, GLOB_REF, LVALUE_REF, FORMAT_REF,
  IO_REF, VSTRING_REF, SCALAR_REF
);

sub generic_typeid { $typeid_to_generic_typeid[$_[0]]; }

sub is_scalar_typeid($) {
  my ($typeid) = @_;
  my $gentype = $typeid_to_generic_typeid[$typeid];
  return ($gentype == SCALAR);
}

sub is_ref_typeid($) {
  my ($typeid) = @_;
  return ($typeid >= REF_REF);
}

sub is_scalar_ref_typeid($) {
  my ($typeid) = @_;
  my $gentype = $typeid_to_generic_typeid[$typeid];
  return (($gentype == SCALAR_REF) || ($gentype == REF_REF));
}

sub is_array_or_hash_typeid($) 
  { (($_[0] == ARRAY_REF) || ($_[0] == HASH_REF)); }

# Syntax: getfields %myhash, field1, field2, ...
sub getfields(+;@) {
  my ($hash, @fields) = @_;
  return @{$hash}{@fields};
}

# Syntax: setfields %myhash, field1 => val1, field2 => val2, ...
sub setfields(+;@) {
  my ($hash, %fields) = @_;
  @{$hash}{keys %fields} = values %fields;
  return $hash;
}

#
# Generate a list of pairs which map the specified keys to the same value,
# where the final argument is the value, and all other arguments are the keys.
# The multikey function can be intuitively invoked as follows (but remember
# both the list of keys and the common value after the '=>' operator must be
# enclosed in the same pair of parentheses - otherwise Perl won't know where
# the multikey argument list ends and the next key => value pair starts!).
#
# my %hash = (
#   ... => ...,
#   multikey (qw(aaa bbb ccc ...) => value),
#   ... => ...,                           ^ notice it's all within parentheses!
#
# This yields a list of pairs:
#   aaa => value,
#   bbb => value,
#   ccc => value,
#
# (Since a list of pairs is returned, constructing a hash is optional).
#
sub multikey {
  my $value = pop @_;
  (map { ($_ => $value) } @_);
}

#
# The multikey_list function accepts a list of (key, value) pairs, where
# each key is either a scalar key or a reference to an array of scalar
# keys. The returned list of pairs is equivalent to applying multi_key
# to each pair:
#
# my %hash = (
#   ... => ...
#   multikey_list (aaa => value1, [ qw(bbb, ccc, ddd) ] => value2, ...),
#   ... => ...
# )
# 
# This yields a list of pairs:
#   aaa => value1,
#   bbb => value2,
#   ccc => value2,
#   ddd => value2
#
# (Do not forget to surround any qw(...) lists with [ ] brackets;
# otherwise the words within qw(...) will be flattened into the
# top level list and misinterpreted as pairs).
#
sub multikey_list {
  pairmap { ((is_array_ref $a) ? (map { ($_ => $b) } @$a) : ($a => $b)) } @_;
}

#
# flatten($aoh) returns the following for the argument $aoh:
#
# - @$aoh if it's an array reference,
# - %$aoh if it's a hash reference (this will be an array of pairs)
# - ($aoh) if it's a scalar or some other type
# - ( ) if it's undefined
#
# This function is useful when we don't know if the argument 
# is a reference to a hash or an array of pairs, but we always
# want a list of pairs regardless of the argument type.
#
sub flatten(+) {
  my ($aoh) = @_;
  return ( ) if (!defined $aoh);
  return (
    (!defined $aoh) ? ( ) :
    (is_array_ref $aoh) ? (@$aoh) : 
    (is_hash_ref $aoh) ? (%$aoh) : 
    ($aoh)
  );
  return @out;
}

#
# flattenref($aoh) returns the following for the argument $aoh:
#
# - $aoh itself if it's already an array reference
# - the same result as [ flatten($aoh) ] in all other cases
#
# This function is faster than using "[ flatten($ref) ]" since
# it simply returns $ref if it's already an array reference.
#

sub flattenref(+) {
  my ($aoh) = @_;
  ((!defined $aoh) ? [ ] : 
   (is_array_ref $aoh) ? $aoh : 
   (is_hash_ref $aoh) ? [ %$aoh ] : 
   [ ($aoh) ]);
}

#
# Return a reference to the array of this function's arguments.
#
# Since the elements of @_ are in fact aliases to the caller's
# local variables, for any variables it used as the arguments to
# the called function (i.e. Perl uses call-by-reference semantics,
# not call-by-value), the elements of @_ are in fact l-values
# from within the called function's scope.
#
# This means that if we make a reference to the entire @_,
# accessing any element of that referenced array later on
# will directly manipulate the corresponding original variable.
#
# These semantics can be used to create a reference to a slice
# of an array or hash, since really we're just referencing a
# new array whose elements are all internal aliases to the
# original variables.
#
sub ref_to_args { return \@_; }

#
# Return a reference to a slice of an array, specified by
# its starting index and number of elements:
#
sub slice_of_array(+$;$) {
  my ($array, $start, $length) = @_;
  my $end = $#{$array};
  my $n = $end+1;
  if ($start < 0) { $start = $n - (-$start); }
  $end = ((defined $length) && (($start + $length) < $end)) 
    ? ($start + $length) : $end;
  return ( ref_to_args @{$array}[$start..$end] ); 
}

#
# tailof(@array or $arrayref, $offset) returns any elements after the
# first $offset elements (by default, 1 element, i.e. returning the
# tail portion of the list without the very first element), or returns
# an empty list if there are fewer than $offset elements in the list.
#
# Faster equivalent to slice_of_array($arrayref, $offset, (scalar @$arrayref) - $offset + 1).
#
sub tailof(+;$) :lvalue {
  my ($array, $offset) = @_;
  $offset //= 1;
  alias return @{$array}[$offset..$#{$array}];
}

#
# If the first argument $_[0] is a reference to an array,
# this function shifts it out of @_ and returns it. If
# $_[0] is a reference to a hash, this also shifts it out
# of @_ and returns a reference to an array of the pairs
# comprising the hash. Otherwise, if $_[0] is a scalar
# or some other non-container type, or if there is more
# than one element in @_, this returns a reference to the
# entire argument array.
#
# This function should be used as follows at the start of 
# another function which accepts either an array reference 
# as its only argument or otherwise considers the entire
# argument list to be the array:
#
# sub caller_of_array_args(+;@) {
#   my $array = &array_args;
#   ... use elements of @$array ...
# }
#
# Notice that array_args is called using "&array_args"
# instead of array_args(@_): the &array_args syntax
# causes the input argument list seen by array_args
# to be an alias to the caller's argument list, which
# allows the first array reference argument to be
# shifted out and directly modify the caller's @_.
# If this is not desired, use the (less efficient)
# "my $array = array_args(@_)" instead. 
#
# That is slower because the @_ list must be copied 
# onto the stack instead of just calling array_args
# with the existing argument list. (Also remember
# that shifting an array is fast in Perl because
# it internally only needs to increment the pointer 
# to the start of the array, without any copying.)
#
sub array_args {
  # 65 = 'A', as in 'ARRAY'
  my $type = (ord ref $_[0]);
  ($type == 65) || ($type == 72) ? shift : \@_;
}

#
# hash_args has the same semantics as array_args (see above)
# except it returns a hash reference instead of an array
# reference, and the argument list must be in the form of
# (key => value) pairs with an even number of elements.
#
sub hash_args { 
  # 72 = 'H', as in 'HASH'
  ((ord ref $_[0]) == 72) ? shift : { @_ };
}

#
# Automatically accept either named or ordered function arguments:
#
# Functions should invoke this like:
#
# sub xyz {
#   my ($arg1, $arg2, $arg3) = 
#     named_or_ordered_args @_, qw(arg1 arg2 arg3);
#   ...
# }
#
# Callers of xyz can then use either "xyz(1, 2, 3)" or 
# "xyz {arg1 => 1, arg2 => 2, arg3 => 3}".
#
# Some functions may take so many optional arguments that it would
# be impossibly confusing to ever blindly pass those arguments as an
# ordered list. For these functions, named_or_ordered_args can also
# be used as follows so callers can use funcname(a => ..., b => ...):
#
# sub xyz {
#   my ($arg1, $arg2, $arg3) = 
#     named_or_ordered_args { @_ }, qw(arg1 arg2 arg3);
# }
#
sub named_or_ordered_args(+@) {
  my $args = shift;

  return 
    (is_hash_ref $args) ? @{$args}{@_} :
    (is_hash_ref $args->[0]) ? @{$args->[0]}{@_} :
    @$args;
}

#
# Like named_or_ordered_args, but always assumes all arguments
# are in the form of a list of (name, value) pairs:
#
sub named_args(+@) {
  my ($args, $names) = @_;
  @{$args}{@$names};
}

#
# Add an escape character ('\\') before any Perl regexp metacharacters
# found in each of the arguments, then return the escaped argument list.
# (This is equivalent to quotemeta applied to each argument)
#
sub escape_metachars { map { quotemeta } @_; }

#
# Like escape_metachars(), but if the first character of each argument
# is already an escape character ('\\'), returns that argument as is;
# otherwise escapes it with escape_metachars.
#

sub escape_metachars_if_unescaped { 
  map { (ord == 92) ? $_ : quotemeta } @_; 
}

#
# The absurdly long and repetitive prototype for reflist(++++++...)
# is intended to ensure any arrays or hashes passed by the caller will
# be seen by reflist (and the list it returns) as references to these
# intact structures, rather than having them expanded into long lists 
# of scalars. This "mega-prototype" enforces these semantics for up to
# 128 consecutive arguments.
#
sub reflist(;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++) {
  return @_;
}

#
# Convenient constructors for declaring a series of constants
# that are automatically sequentially enumerated, either 
# incrementing by 1 after each declaration (for enum), or
# by a factor of 2 for enumbits, which is ideal for declaring
# bitfields or for defining various types of flag bits.
#
# These are used as follows:
#
# use constant enum qw(NAME1 NAME2 NAME3 ...)
#                      ^ 0   ^ 1   ^ 2   ...
#
# use constant enumbits qw(NAME1 NAME2 NAME3 ...)
#                          ^ 1   ^ 2   ^ 4   ...
# 
# If you need to redefine the starting point (or next value)
# of an enumeration, extenum can be used in place of enum,
# since extenum will interpret a numeric value interspersed
# within the list of constant names as a command that makes
# the value of the next name in the list equal to the 
# most recent integer in the list. For example, this could
# be written as:
#
#   use constant extenum qw(A B C 90 D E) 
#
# In this case, A, B, C are 0, 1, 2, while D, E are 90, 91.
# (If your enumeration does *not* require this renumbering,
# use enum instead of extenum since it's faster to compile).
#

#
# e.g.     use constant enum qw(A B C 123 D)
# becomes: use constant { A => 0, B => 1, C => 2, D => 123}
#
sub enum {
  my $id = 0;
  return { map { ($_ => $id++) } @_ };
}

sub extenum {
  my $id = 0;
  return { map { 
    if ($_ =~ /\A \d+ \Z/oax) {
      $id = int($_);
      ( );
    } else {
      ($_ => $id++); 
    }
  } @_};
}

#
# e.g.     use constant enumbits qw(A B C D)
# becomes: use constant { A => (1 << 0), B => (1 << 1), C => (1 << 2), D => (1 << 3)}
#
sub enumbits {
  my $id = 0;
  return { map { ($_ => (1 << ($id++))) } @_};
}

#
# Numerical convenience functions
#

sub min($$;@) {
  return (($_[0] < $_[1]) ? $_[0] : $_[1]);
}

sub set_min($$) {
  my ($a, $b) = @_;
  $a //= 0;
  $a = ((!defined $b) || ($a < $b)) ? $a : $b;
  $_[0] = $a;
  return $a;
}

sub min_in_list {
  if (!@_) { return 0; }
  my $list = (is_array_ref($_[0])) ? $_[0] : @_;
  my $min = undef;
  foreach my $v (@$list) {
    next if (!defined $v);
    $min = ($v <= ($min // $v)) ? $v : $min;
  }
  return $min;
}

sub max($$) {
  return (($_[0] > $_[1]) ? $_[0] : $_[1]);
}

sub set_max($$) {
  my ($a, $b) = @_;
  $a //= 0;
  $a = ((!defined $b) || ($a > $b)) ? $a : $b;
  $_[0] = $a;
  return $a;
}

sub max_in_list {
  if (!@_) { return 0; }
  my $list = (is_array_ref($_[0])) ? $_[0] : @_;
  my $max = 0;
  foreach my $v (@$list) {
    next if (!defined $v);
    $max = ($v > $max) ? $v : $max;
  }
  return $max;
}

sub inrange($$$) { return (($_[0] >= $_[1]) && ($_[0] <= $_[2])) ? 1 : 0; }

sub clipto($$$) {
  return ($_[0] < $_[1]) ? $_[1] : ($_[0] > $_[2]) ? $_[2] : $_[0];
}

sub set_clipto($$$) {
  $_[0] = ($_[0] < $_[1]) ? $_[1] : ($_[0] > $_[2]) ? $_[2] : $_[0];
  return $_[0];
}

#
# Utility functions which consider both defined-vs-undef
# state of the argument, and iff it's defined, they'll
# only return true if the argument (taken as a string)
# is filled in (i.e. it has a non-zero length). Obviously
# is_empty() returns the exact opposite of is_filled().
#
# There are also all_filled() and any_empty() to check
# these properties for every item in the specified list.
#
sub bool { (($_[0]) ? 1 : 0); }
sub if_there { ((length $_[0]) ? $_[0] : undef) }
sub is_there { ((length $_[0]) ? 1 : 0) }
sub is_empty { ((length $_[0]) ? 0 : 1) }

sub set_if_there { $_[0] = $_[1] if (length $_[1]); $_[0]; }
sub set_ifdef { $_[0] = $_[1] if (defined $_[1]); $_[0]; }
sub set_if_empty { $_[0] = $_[1] if (!length $_[0]); $_[0]; }
# (set_ifndef is equivalent to the standard //= operator)

sub all_defined { (all { defined } @_) }
sub all_undefined { (all { !defined } @_) }
sub all_there { (all { length } @_) }
sub all_empty { (none { length } @_) }
sub all_true  { (all { $_ } @_) }
sub all_false { (all { ! $_ } @_) }

sub any_defined { (any { defined } @_) }
sub any_undefined { (any { !defined } @_) }
sub any_there { (any { length } @_) }
sub any_empty { (notall { length } @_) }
sub any_true  { (any { $_ } @_) }
sub any_false { (any { ! $_ } @_) }

sub none_true { (all { ! $_ } @_) }
sub none_false { (all { $_ } @_) }

sub count_defined { grep { defined } @_ }
sub count_undefined { grep { ! defined } @_ }
sub count_there { grep { length } @_ }
sub count_empty { grep { !length } @_ }
sub count_true { grep { $_ } @_ }
sub count_false { grep { !$_ } @_ }

sub first_defined { (first { defined } @_) }
sub first_there { (first { length } @_) }
sub first_true  { (first { $_ } @_) }

sub mutually_exclusive { (grep { $_ } @_) == 1 }
sub optional_mutually_exclusive { (grep { $_ } @_) <= 1 }

sub first_specified { (first { length } @_) }

sub first_defined_result(&;@) {
  my $func = shift;
  foreach (@_) { my $result = $func->($_); return $result if (defined $result); }
  return (wantarray ? ( ) : undef);
}

sub first_true_result(&;@) {
  my $func = shift;
  foreach (@_) { my $result = $func->($_); return $result if ($result); }
  return (wantarray ? ( ) : undef);
}

sub first_non_empty_result(&;@) {
  my $func = shift;
  foreach (@_) { my $result = $func->($_); return $result if (length $result); }
  return (wantarray ? ( ) : undef);
}

sub undefs_to { my $to = shift; return (map { $_ // $to } @_); }

sub undefs_to_inplace { my $to = shift; return (map { $_ //= $to } @_); }

sub undefs_to_empty_strings { return map { $_ // '' } @_; }
sub undefs_to_empty_strings_inplace { return map { $_ //= '' } @_; }

sub ref_to_first_undef { first { return \$_ if (!defined); } @_; return undef; }

sub list_contains(+$) {
  my ($list, $target) = @_;
  while (my ($i, $v) = each @$list) { return $i if ($v eq $target); }
  return undef;
}

sub is_in_set($@) {
  my $target = shift;
  my $found = first { $_ eq $target } @_;
  return (defined $found);
}

sub sizeof(+) {
  local $t = typeof($_[0]);
  return
    (!defined $_[0]) ? 0 :
    ($t == ARRAY_REF) ? scalar @{$_[0]} :
    ($t == HASH_REF) ? scalar keys %{$_[0]} :
    ($t == STRING_REF) ? length ${$_[0]} :
    ($t == STRING) ? length $_[0] :
    ($t == SCALAR_REF || $t == SCALAR) ? 1 :
    ($t == REF_REF) ? 1 :
    undef;
}

#
# Pre-allocate an array or hash of a certain length when we know
# we'll be assigning to indexes up to that length (or for hashes,
# we'll be inserting the specified number of keys).
#
# NOTE: It is NOT safe to use a pre-allocated array for push
# operations, since the next array index written by the push
# will be the preallocated length, rather than the actual
# number of elements pushed so far.
#

sub prealloc(+$;$) {
  my ($array_or_hash, $length_or_fit_to, $filler) = @_;

  my $type = typeof($array_or_hash);
  my $length_type = typeof($length_or_fit_to);

  my $n = 
    ($length_type == ARRAY_REF) ? scalar @$length_or_fit_to :
    ($length_type == HASH_REF) ? scalar keys %$length_or_fit_to :
    ($length_type == STRING) ? length($length_or_fit_to) :
    $length_or_fit_to;

  if ($type == ARRAY_REF) {
    my $c = scalar(@$array_or_hash);

    if ((defined $filler) && ($n > $c)) {
      splice(@$array_or_hash, $c, $n-$c, (($filler) x ($n-$c)));
    } else {
      $#{$array_or_hash} = $n-1;
    }
  } elsif ($type == HASH_REF) {
    keys %$array_or_hash = $n;
  } elsif ($type == STRING) {
    my $c = length($_[0]);
    my $delta = max($n - $c, 0);
    $_[0] .= ("\0" x $delta) if ($delta);
    substr($_[0], $c, $delta, '');
  } else {
    die('Cannot preallocate data of type '.$typeid_to_string[$type]);
  }

  return $array_or_hash;
}

sub sparse_array {
  my @array = ( );
  pairmap { $array[$a] = $b; ( ); } @_;
  return @array;
}

sub sparse_array_with_default {
  my $default = shift;
  my @array = ( );
  pairmap { $array[$a] = $b; ( ); } @_;
  map { $_ //= $default } @array;
  return @array;
}

sub single_value_sparse_array {
  my $value = shift;
  my @array = ( );

  map { $array[$_] = $value; } @_;
  return @array;
}

sub pair_list_with_value(+;$) {
  my ($list, $value) = @_;
  $value //= 1;
  return (map { ($_, $value) } @$list);
}

sub filter_pairs { return (pairmap { ($a) ? ($b) : ( ) } @_); }

sub join_if { return join('', pairmap { ($a) ? ($b) : ( ) } @_); }

sub join_with_sep_if($;@) {
  my $sep = shift; 
  return join($sep, pairmap { ($a) ? ($b) : ( ) } @_); 
}

sub remove_undefs { return (grep { defined } @_); }

sub remove_undefs_in_place(+) { my ($a) = @_; @$a = grep { defined } @$a; }

sub remove_dups(+) {
  my ($a) = @_;
  my %found = ( );
  return (grep { my $inc = (exists $found{$_}) ? 0 : 1; $found{$_} = 1; $inc; } @$a);
}

sub remove_dups_in_place(+) { my ($a) = @_; @$a = remove_dups($a); }

sub push_if_defined(+@) {
  my ($a) = shift;
  push @$a, (grep { defined $_ } @_);
  return (scalar(@$a));
}

sub copy_array_elements_where_undef(++) {
  my ($a, $b) = @_;

  #
  # Use the larger size as our limit, since perl will fill in 
  # any elements past the end of the smaller array with undefs
  # (if @b is larger than @a, this effectively means all elements
  # in @b at indexes greater than the size of @a will be copied
  # unconditionally into the corresponding indexes in @a).
  #
  my $size = max(scalar(@$a), scalar(@$b));

  my @out = ( );
  for my $i (0..($size-1)) { $out[$i] = $a->[$i] // $b->[$i]; }

  return (wantarray ? @out : \@out);
}

sub pad_array(+;$$) {
  my ($array, $newsize, $pad) = @_;
  
  my $n = scalar(@$array);

  $pad //= (($n > 0) ? $array->[-1] : undef);

  if ($newsize > $n) {
    splice(@$array, $n, $newsize-$n, (($pad) x ($newsize-$n)));
  } else {
    $#{$array} = $n-1;
  }

  return (wantarray ? @$array : $array);
}

sub arrays_identical(++) {
  my ($aa, $bb) = @_;

  return 0 if ((scalar @$aa) != (scalar @$bb));

  pairwise { return 0 if ($a ne $b); } @$aa, @$bb;
  return 1;
}

sub hashes_identical(++) {
  my ($aa, $ab) = @_;

  return 0 if ((scalar keys %$aa) != (scalar keys %$bb));

  my @aa_keys = sort keys %$aa;
  my @bb_keys = sort keys %$bb;

  return 0 if (!arrays_identical(@aa_keys, @bb_keys));

  foreach my $key (@aa_keys) {
    my $a = $aa->{$key};
    my $b = $bb->{$key};
    return 0 if ($a ne $b);
  }

  return 1;
}

{
  no warnings qw(portable);

  use constant {
    ALL_8_BITS  => 0xff,
    ALL_16_BITS => 0xffff,
    ALL_32_BITS => 0xffffffff,
    ALL_48_BITS => 0xffffffffffff,
    ALL_64_BITS => 0xffffffffffffffff,
  };
};

sub bit($$) { return ($_[0] >> $_[1]) & 1; }
sub bitmask($) { return ($_[0] >= 64) ? (~0) : ((1 << $_[0]) - 1); }
sub shifted_bitmask($$) { return (bitmask($_[1]) << ($_[0])); }
sub bits($$$) { return (($_[0] >> $_[1]) & bitmask($_[2])); }
sub lowbits($$) { return ($_[0] & bitmask($_[1])); }

#
# Returns the bit index of the highest numbered bit that is '1'
# in the specified integer argument, which is either 32-bit or
# 64-bit (almost always on modern machines). If the input word
# is 0 (no bits are set), undef is returned instead.
#
sub highest_set_bit_index($) { 
  my $index = (&POSIX::2008::ffs)-1; 
  return ($index >= 0) ? $index : undef;
}

sub cond_or(@) {
  my $m = 0;
  pairmap { $m |= (($a) ? $b : 0); } @_;
  return $m;
}

sub cond_and_index_list_to_bitmask(@) {
  my $m = 0;
  pairmap { $m |= (($a) ? (1 << $b) : 0) } @_;
  return $m;
}

sub index_list_to_bitmask(@) {
  my $m = 0;
  map { $m |= (1 << $_) if (defined $_) } @_;
  return $m;
}

sub bit_names_of($+;$) {
  my ($bitmask, $bit_to_name, $sep) = @_;

  my @set_bit_names = ( );

  for my $i (0..$#{$bit_to_name}) {
    if ($bitmask & (1 << $i)) 
      { push @set_bit_names, ($bit_to_name->[$i] // $i); }
  }

  return ((wantarray && (!defined $sep)) 
            ? @set_bit_names : join($sep // ' ', @set_bit_names));
}

use constant {
  THOUSAND => 1000,
  MILLION => 1000000,
  BILLION => 1000000000,
  TRILLION => 1000000000000,
  QUADRILLION => 1000000000000000,
  KB => 1024,
  MB => 1024*1024,
  GB => 1024*1024*1024,
  TB => 1024*1024*1024*1024,
  EB => 1024*1024*1024*1024*1024,
};

noexport:; sub __sort_by_length_then_alphabetical(+$$) {
  my ($list, $descending_length, $descending_alpha) = @_;

  return sort {
    my $r = length($a) <=> length($b);
    $r = -$r if ($descending_length);
    return ($r) ? $r : (($descending_alpha) ? ($b cmp $a) : ($a cmp $b));
  } @$list;
}

sub sort_by_ascending_length_then_alphabetical {
  my $list = &array_args;
  return __sort_by_length_then_alphabetical($list, 0, 0); 
}

sub sort_by_descending_length_then_alphabetical { 
  my $list = &array_args;
  return __sort_by_length_then_alphabetical($list, 1, 0); 
}

no integer;
use constant {
  RATIO_9_10 => 0.90,
  RATIO_3_4 => 0.75,
  RATIO_2_3 => 2.0 / 3.0,
  RATIO_1_2 => 0.5,
  RATIO_1_3 => 1.0 / 3.0,
  RATIO_1_4 => 0.25,
  RATIO_1_10 => 0.10,
};
use integer;

sub ratio_to_percent($$) {
no integer;
  my ($a, $b) = @_;
  $a //= 0; $b //= 0;
  return ($b > 0) ? int((($a / $b) * 100.0) + 0.5) : 0;
use integer;
}

sub longest_common_array_prefix {
  my $n = scalar @_;

  return ( ) if (!scalar @_);
  return ($_[0]) if ((scalar @_) == 1);

  my @prefix = ( );
  my $prefix_length = (1 << 30);

  foreach my $array (@_) {
    foreach my $i (0..$#{$array}) {
      my $f = $array->[$i];
      $prefix[$i] //= $f;
      if ($f ne $prefix[$i]) { set_min($prefix_length, $i); }
    }
  }

  return @prefix[0..($prefix_length-1)];
}

#
# If the specified index is within the size of the specified array,
# return the indexed element; otherwise return the $value_beyond_end
# argument's value (or if not specified, the value of the last array
# element).
#
sub infinite_array(+;$$) {
  my ($array, $index, $value_beyond_end) = @_;

  $array = (is_array_ref $array) ? $array : \($array);
  my $n = scalar @$array;
  $value_beyond_end //= $array->[$n-1];

  return ($index < $n) ? $array->[$n] : $value_beyond_end;
}

#
# If the specified index is within the size of the specified array,
# return the indexed element as a writable lvalue; otherwise return
# the $value_beyond_end argument as a writable lvalue (or if not
# specified, return the last array element as an lvalue). Writing
# to a returned lvalue resulting from an index outside the array
# will therefore modify either the provided $value_beyond_end or
# if not specified, the final array element will be modified.
#
sub infinite_writable_array(+;$$) :lvalue {
  my ($array, $index) = @_;
  alias $value_beyond_end = $_[2];

  $array = (is_array_ref $array) ? $array : \($array);
  my $n = scalar @$array;
  $value_beyond_end //= $array->[$n-1];

  return ($index < $n) ? $array->[$n] : 
    ($value_beyond_end // $array->[$n-1]);
}

#
# Based on the specified array and index, return either the indexed
# array element if the index is within the length of the array.
# If the index is N greater than the last array element's index
# (i.e. length - 1), and the $stride argument is specified, this
# function will return N times the specified stride, or if no
# stride is given, it will use a default stride of the difference
# between the last two existing array entries (i.e. at length-1 
# and length-2). For example, given the array:
#
#   [ 100, 110, 130, 160, 200 ]
#
# the index 4 would return the last real entry (200), while the
# index 5 would return 240 (i.e. 200 - 160 = 40), index 6 returns
# 280, index 7 returns 320, and so on.
#
# If the last entry is less than the next-to-last entry (i.e. the
# array was in descending order), this order will be preserved,
# with results beyond the end of the array also descending by
# the (negative) difference between the last two entries, and
# will become infinitely negative given an infinite index.
#
sub infinite_array_using_final_stride(+;$$) {
  my ($array, $index, $stride) = @_;

  $array = (is_array_ref $array) ? $array : \($array);
  my $n = scalar @$array;

  return $array->[$n] if ($index < $n);

  my $last = $array->[$n-1] // 0;
  $stride //= ($last - ($array->[$n-2] // 0));
  return $last + (($index - ($n-1)) * $stride);
}

1;
