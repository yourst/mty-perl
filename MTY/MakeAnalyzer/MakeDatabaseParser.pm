# -*- cperl -*-
#
# MTY::MakeAnalyzer::MakeDatabaseParser
#
# Parse the database of make rules and recipes output of 'make -p' 
# so it can be saved and reloaded to accelerate make's performance
# on complex collections of many makefiles, or analyzed for many
# other useful applications
#
# Copyright 2003-2014 Matt T. Yourst <yourst@yourst.com>. All rights reserved.
#

package MTY::MakeAnalyzer::MakeDatabaseParser;

use integer; use warnings; use Exporter::Lite;

our @EXPORT = # (auto-generated by perl-mod-deps)
  qw(DIRECTORIES_PHASE END_PHASE IMPLICIT_RULES_PHASE NO_PHASE RULES_PHASE
     START_PHASE VARIABLES_PHASE parse_make_database);

use MTY::MakeAnalyzer::Common;
use MTY::Common::Common;
use MTY::Common::Hashes;
use MTY::Common::Strings;
use MTY::RegExp::Define;

noexport:; use constant {
  NO_PHASE => 0,
  START_PHASE => 1,
  VARIABLES_PHASE => 2,
  DIRECTORIES_PHASE => 3,
  IMPLICIT_RULES_PHASE => 4,
  RULES_PHASE => 5,
  END_PHASE => 6,
};

my $recipe_to_execute_comment_re = compile_regexp(qr{
  ^\# \s*+ recipe \s to \s execute \s \( 
  from \s '([^\']+)'(?: , \s line \s (\d+))?
  }oax, 'make_recipe_to_execute_comment');

my $phony_target_re = compile_regexp(qr{^\#\s+Phony}oax, 'phony_target');

my $make_variable_flavor_from_file_line_re = compile_regexp(qr{
  ^ \# \s*
  (
    command \s line |
    environment (?: \s override)? |
    automatic |
    undefined |
    override |
    makefile | 
    default |
    file
  )
  (?: \s \( from \s 
    \' ([^\']+) \' 
    (?: , \s line \s (\d+))? \)
  )? $
  }oax, 'make_recipe_to_execute_comment');

my $make_dump_start_line_re = qr{^\#\Q Make data base, printed on \E}oa;  

sub parse_make_database(;$) {
  my $fd = $_[0] // STDIN;

  my $current_target = undef;
  my $current_variable = undef;
  my $var_origin = undef;
  my $var_defined_in_file = undef;
  my $var_defined_at_line = undef;
  my $phase = NO_PHASE;
  my $ignore_next_target = 0;

  my %variables = ( );
  my %targets = ( );
  my %variables_by_category = ( );
  my %targets_by_category = ( );
  my @makefiles;

  while (<$fd>) {
    chomp;
    my $input = $_;
    my $input_line_number = $. // 0;

    if ($phase == NO_PHASE) {
      if ($input =~ /$make_dump_start_line_re/oa) { $phase = START_PHASE; }
    } elsif ($phase == START_PHASE) {
      if ($input eq '# Variables') { $phase = VARIABLES_PHASE; }
    } elsif ($phase == VARIABLES_PHASE) {
      if ($input eq '# Directories') { $phase = DIRECTORIES_PHASE; }
    } elsif ($phase == DIRECTORIES_PHASE) {
      if ($input eq '# Implicit Rules') { $phase = IMPLICIT_RULES_PHASE; }
    } elsif ($phase == IMPLICIT_RULES_PHASE) {
      if ($input eq '# Files') { $phase = RULES_PHASE; }
    }

    if ($phase == VARIABLES_PHASE) {
      if (defined($current_variable)) {
        if ($input eq 'endef') {
          $current_variable = undef;
        } else {
          $current_variable->{value} .= $input.NL;
        }
      } elsif ($input =~ /$make_variable_flavor_from_file_line_re/oax) {
        $var_origin = ($1 =~ s/\s//roamsxg);
        $var_defined_in_file = $2 // '';
        $var_defined_at_line = $3 // '';
      } elsif ($input =~ /$make_variable_or_define_re/oax) {
        my ($define, $name, $op, $value) = ($1 // '', $2, $3 // '=', $4 // '');
        my $multiline = ($define eq 'define') ? 1 : 0;
        $var_origin //= 'unknown';
        my $flavor = ($op eq ':=') ? 'immediate' : 'recursive';
        my $special = ($name =~ /^\./) ? 1 : 0;
        my $special_str = ($special) ? '.special' : '';
        my $category = $var_origin.'.'.$flavor.$special_str;

        my %v = (
          __is_a_variable__ => 1,
          name => $name,
          value => $value,
          multiline => $multiline,
          op => $op,
          origin => $var_origin,
          flavor => $flavor,
          special => $special,
          defined_in_makefile => $var_defined_in_file // '-',
          defined_in_makefile_line => $var_defined_at_line // 0,
          input_line => $input_line_number,
          category => $category);

        $variables{$name} = \%v;

        if (exists $variables_by_category{$category}) {
          push @{$variables_by_category{$category}},\%v;
        } else {
          $variables_by_category{$category} = [ \%v ];
        }

        if ($multiline) { $current_variable = \%v; }
      }
    } elsif (($phase == RULES_PHASE) || ($phase == IMPLICIT_RULES_PHASE)) {
      if ($input =~ /$make_rule_re/oax) {
        if ($ignore_next_target) { $ignore_next_target = 0; next; }
        my ($target, $deps, $order_only_deps) = ($1, $2 // '', $3 // '');
        my @dep_list = split(/\s+/oax, $deps);
        my @order_only_dep_list = split(/\s+/oax, $order_only_deps);
        my @recipe = ( );
        my $type = (($target =~ /$special_rule_re/oax) ? 'special' :
                      ($phase == IMPLICIT_RULES_PHASE) ? 'implicit' : 
                        'explicit');
        my %t = (
          __is_a_target__ => 1,
          name => $target,
          type => $type,
          phony => 0,
          deps => \@dep_list,
          order_only_deps => \@order_only_dep_list,
          recipe => \@recipe,
          input_line => $input_line_number);
        $current_target = \%t;
      } elsif ($current_target) {
        if ($input =~ /$phony_target_re/oax) {
          $current_target->{phony} = 1;
          $current_target->{type} = 'phony';
        } elsif ($input =~ /$recipe_to_execute_comment_re/oax) {
          $current_target->{defined_in_makefile} = $1 // '-';
          $current_target->{defined_in_makefile_line} = $2 // 0;
        } elsif ($input =~ /$make_recipe_re/oax) {
          push @{$current_target->{recipe}},$1;
        } elsif (length($input) == 0) {
          # (end of the recipe)
          my $target_name = $current_target->{name};
          my $target_type = $current_target->{type};
          my $phony = ($current_target->{phony} == 1);
          my $phony_or_file = ($phony) ? 'phony' : 'file';

          $targets{$target_name} = $current_target;

          my $category = $target_type.'.'.$phony_or_file;
          $current_target->{category} = $category;

          if (exists $targets_by_category{$category}) {
            push @{$targets_by_category{$category}},$current_target;
          } else {
            $targets_by_category{$category} = [ $current_target ];
          }

          $current_target = undef;
        }
      } elsif ($input eq '# Not a target:') {
        # The next line that looks like a target definition is really 
        # just a status report on the disposition of the target file:
        $ignore_next_target = 1;
      }
    }
  }

  @makefiles = split(/\s+/, $variables{'MAKEFILE_LIST'} // '');

  return (\%variables, \%targets, \%variables_by_category, \%targets_by_category, \@makefiles);
}

